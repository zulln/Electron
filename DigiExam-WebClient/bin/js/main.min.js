(function() {
var client;
client = angular.module("digiexamclient", [ "ngRoute", "ngAnimate", "digiexamclient.platform", "digiexamclient.user", "digiexamclient.storage", "digiexamclient.preconditiontest", "digiexamclient.lockdown", "digiexamclient.session", "digiexamclient.exam", "digiexamclient.validation", "digiexamclient.jsobjcbridge", "dx.webui.blockEditor", "dx.webui.scroll", "dx.webui.sticky", "dx.webui.grading", "angular-minimodal" ]), 
client.config([ "$routeProvider", "$compileProvider", "Urls", function($routeProvider, $compileProvider, Urls) {
return $compileProvider.aHrefSanitizationWhitelist(/^\s*(data|https?|ftp|mailto|file|chrome-extension):/), 
$routeProvider.when(Urls.routes.login, {
template:'<div id="login" class="pv-900"><div class="logo"><img src="images/digiexam-logo.png" alt="DigiExam"></div><loader ng-show="isLoading"><p class="text-center">Initializing DigiExam</p></loader><div dx-container="narrow" class="auth clearfix" ng-show="showAuth"><user-details user="user"></user-details></div></div>',
controller:"LoginController"
}), $routeProvider.when(Urls.routes.overview, {
template:'<div layout layout-align="start start" layout-padding id="overview"><div flex="33"><div class="sheet"><h3 class="mb-300">A. Find exams</h3><button class="btn btn-raised" ng-click="refreshExams()">Refresh exams</button></div><div class="sheet"><h3 class="mb-300">B. Open exam</h3><label for="overViewOpenExamCode" class="display-block">Enter exam ID</label><input type="number" min="0" inputmode="numeric" pattern="[0-9]*" ng-model="openExamCode" id="overViewOpenExamCode" ng-enter="getOpenExam()"> <button class="btn btn-raised btn-green mt-300" ng-click="getOpenExam()" ng-disabled="!isValidOpenExamCode(openExamCode)">Get open exam</button> <span class="color-text-error ml" ng-show="openExamError.length > 0">{{openExamError}}</span></div><div class="sheet"><h3 class="mb-300">C. Offline exam</h3><span ng-if="DX_PLATFORM !== \'IOS_WEBVIEW\'"><p class="mv-300">Your mentor will provide you with this on a USB-stick.</p><button class="btn btn-raised" ng-click="openOfflineFile()">Load exam from device</button> <span class="color-text-error ml" ng-show="openOfflineFileError.length > 0">{{openOfflineFileError}}</span></span> <span ng-if="DX_PLATFORM === \'IOS_WEBVIEW\'"><p>Not supported on iOS devices</p></span></div><div class="sheet"><h3 class="mb-300">D. Start demo exam</h3><p class="mv-300">You can start a demo exam here</p><button class="btn btn-raised" ng-click="getDemoExam()">Get demo exam</button> <span class="color-text-error ml" ng-show="demoExamError.length > 0">{{demoExamError}}</span></div></div><div flex="33"><div class="sheet"><loader ng-show="loadingExams"><p class="text-center">Loading exams...</p></loader><div class="alert alert-info" ng-show="exams.length == 0 && !loadingExams"><p>Could not find exams.</p></div><ul class="examlist" ng-show="exams.length > 0 && !loadingExams"><li ng-repeat="exam in exams" ng-class="{selected: selectedExam.id == exam.id}"><a href="" ng-click="toggleSelectedExam(exam)">{{exam.title}}</a></li></ul></div></div><div flex="33" ng-show="exams.length > 0"><div class="sheet"><div class="alert alert-info" ng-show="selectedExam == null && !loadingExams"><p>No exam selected. Please select an exam.</p></div><div class="overview-exam-details" ng-if="selectedExam != null"><h2 class="text-normal">{{selectedExam.title}}</h2><div class="overview-exam-details-description mb mt-300"><p class="pre-wrap">{{getDescription(selectedExam)}} <a href="" ng-click="toggleExamDescription()" ng-show="selectedExam.about.length > 299 && truncateDescription"><span ng-show="truncateDescription">more</span></a></p></div></div><div><button class="btn btn-green btn-raised floatRight" ng-click="confirmStartExam(selectedExam.id)" ng-show="selectedExam != null && !loadingExam">Start exam</button><div style="clear: right"></div></div></div></div></div>',
controller:"OverviewController"
}), $routeProvider.when(Urls.routes.userEdit, {
template:'<div dx-container="narrow" class="pv-900" id="user-edit"><h1 class="mb-700">Edit details</h1><user-details user="user"></user-details></div>',
controller:"UserEditController"
}), $routeProvider.when(Urls.routes.exam, {
template:'<div dx-container="medium" class="exam pv-900" ng-class="{\'rtl\': exam.rightToLeft}"><loader ng-show="isLoading"><p class="text-center">Loading exam</p></loader><div ng-show="!isLoading"><div class="exam-title"><h1 class="text-center">{{exam.title}}</h1></div><div class="exam-about mv-700"><p class="pre-wrap">{{exam.about}}</p></div><div class="question-wrapper"><div class="question sheet" ng-repeat="q in exam.questions"><h3 class="question-title mb">{{q.title}}</h3><p class="pre-wrap mv">{{q.about}}</p><div class="question-images mv"><dx-image-list images="q.images" track="q.id"></dx-image-list></div><p ng-if="exam.gradingType == GradingTypeEnum.SCORE" class="text-bold mv">Max score: {{q.maxScore}}</p><dx-block-editor-manager ng-if="q.type == QuestionType.TEXT_QUESTION" question="q" answer="answers[$index]" on-change="onAnswerChange"></dx-block-editor-manager><ul class="single-choice-question unstyledList spacedList" ng-if="q.type == QuestionType.SINGLE_CHOICE"><li ng-repeat="a in q.alternatives"><label for="a-{{a.$$hashKey}}" class="radio"><input type="radio" id="a-{{a.$$hashKey}}" ng-checked="answers[$parent.$index].hasThisAlternative(a.id)" ng-click="answers[$parent.$index].setCorrectAlternative(a.id); onAnswerChange(answers[$parent.$index])"> {{a.title}}</label></li></ul><ul class="multi-choice-question unstyledList spacedList" ng-if="q.type == QuestionType.MULTIPLE_CHOICE"><li ng-repeat="a in q.alternatives"><label for="a-{{a.$$hashKey}}" class="checkbox"><input type="checkbox" id="a-{{a.$$hashKey}}" ng-checked="answers[$parent.$index].hasThisAlternative(a.id)" ng-click="answers[$parent.$index].toggleCorrectAlternative(a.id); onAnswerChange(answers[$parent.$index])"> {{a.title}}</label></li></ul></div></div><div class="exam-control clearfix" ng-show="showTurnInButton"><button class="btn btn-green btn-raised exam-turn-in-btn floatRight" ng-click="confirmTurnIn()">Hand in exam and exit</button></div><div class="demoExamWatermark" ng-if="exam.isDemo">demo exam</div></div></div>',
controller:"ExamController"
}), $routeProvider.otherwise({
redirectTo:"/"
});
} ]);
}).call(this), function() {
angular.module("digiexamclient.exam", [ "dx.webui.answer", "dx.webui.question", "dx.webui.blockEditor" ]);
}.call(this), angular.module("digiexamclient.jsobjcbridge", [ "digiexamclient.platform" ]), 
angular.module("digiexamclient.platform", []), function() {
angular.module("digiexamclient.session", [ "digiexamclient.storage" ]);
}.call(this), angular.module("digiexamclient.storage", [ "digiexamclient.storage.filesystem", "digiexamclient.storage.localstorage" ]), 
function() {
angular.module("digiexamclient.user", []);
}.call(this), angular.module("digiexamclient.storage.filesystem", []), angular.module("digiexamclient.storage.localstorage", []), 
angular.module("digiexam-preconditiontest", [ "digiexamclient.platform", "digiexamclient.storage", "digiexamclient.jsobjcbridge", "digiexamclient.preconditiontest" ]), 
angular.module("digiexamclient").factory("DXClient", function($window, $route, $rootScope, $location, DXLocalStorage, JsObjcBridge, DX_PLATFORM) {
"use strict";
var DXClient = {};
return DXClient.isKiosk = $window.isKiosk, DXClient.close = function(modalInstance) {
if ("ELECTRON_APP" === DX_PLATFORM) $window.close(); else if ("CHROME_APP" === DX_PLATFORM) $window.chrome.app.window.current().close(); else if ("BROWSER" === DX_PLATFORM) $location.path("/"), 
modalInstance.resolve(); else {
if ("IOS_WEBVIEW" !== DX_PLATFORM) return angular.noop();
JsObjcBridge.unlockFromGuidedAcess(function() {
$location.path("/"), modalInstance.resolve();
}, function() {
$location.path("/"), $rootScope.$emit("Toast:Notification", "Could not unlock from guided access"), 
modalInstance.reject();
});
}
}, DXClient;
}), function() {
angular.module("digiexamclient.exam").factory("Alternative", function() {
var Alternative;
return Alternative = function(data) {
return angular.extend(this, {
id:0,
title:""
}), null != data ? (null == data.correct || data.right || (data.right = data.correct), 
angular.extend(this, data)) :void 0;
};
});
}.call(this), function() {
angular.module("digiexamclient.exam").factory("Answer", function($q, QuestionType, DXLocalStorage, AnswerBlock) {
var Answer, multiChoiceQuestionTemplate, singleChoiceQuestionTemplate, textualQuestionTemplate;
return textualQuestionTemplate = {
data:"",
answerBlocks:[]
}, singleChoiceQuestionTemplate = {
data:-1,
setCorrectAlternative:function(aId) {
return this.data = aId;
},
hasThisAlternative:function(aId) {
return this.data === aId;
}
}, multiChoiceQuestionTemplate = {
data:[],
toggleCorrectAlternative:function(aId) {
return this.hasThisAlternative(aId) ? this.data.splice(this.data.indexOf(aId), 1) :this.data.push(aId);
},
hasThisAlternative:function(aId) {
return this.data.indexOf(aId) > -1;
}
}, Answer = function(type, questionId, answerData) {
var blockData, existingBlocks, i, instantiatedBlocks, k, len, unsupported, v;
null == answerData && (answerData = {}), angular.extend(this, {
_id:Math.uuid(),
questionId:questionId,
data:"",
type:type,
hasAttachmentsChanged:!1,
attachments:[]
}), unsupported = !0;
for (k in QuestionType) v = QuestionType[k], QuestionType[k] === type && (unsupported = !1);
if (unsupported) throw Error("Unsupported question type on answer " + type);
if (type === QuestionType.TEXT_QUESTION ? angular.extend(this, angular.copy(textualQuestionTemplate)) :type === QuestionType.SINGLE_CHOICE ? angular.extend(this, angular.copy(singleChoiceQuestionTemplate)) :angular.extend(this, angular.copy(multiChoiceQuestionTemplate)), 
type === QuestionType.TEXT_QUESTION) {
if (existingBlocks = answerData.answerBlocks, instantiatedBlocks = [], existingBlocks && existingBlocks.length) for (i = 0, 
len = existingBlocks.length; len > i; i++) blockData = existingBlocks[i], instantiatedBlocks.push(new AnswerBlock(blockData)); else instantiatedBlocks.push(new AnswerBlock());
answerData.answerBlocks = instantiatedBlocks, answerData.data = "";
}
return angular.extend(this, answerData);
}, Answer.getFromStorageByExamId = function(examId, studentCode) {
var answers, key, promise;
return answers = [], key = "u-" + studentCode + "-exam-" + examId + "-answers", 
promise = DXLocalStorage.get(key), promise.then(function(data) {
var a, i, len, storedAnswers;
if (storedAnswers = data[key], null != storedAnswers && storedAnswers.length > 0) for (i = 0, 
len = storedAnswers.length; len > i; i++) a = storedAnswers[i], answers.push(new Answer(a.type, a.questionId, a));
return answers;
});
}, Answer;
});
}.call(this), function() {
angular.module("digiexamclient.exam").factory("AnswerQueue", function($q, $http, $interval) {
var AnswerQueue;
return AnswerQueue = function(examId, studentId, studentCode, firstName, lastName, email) {
var intervalPromise;
return intervalPromise = null, angular.extend(this, {
examId:examId,
studentId:studentId,
studentCode:studentCode,
firstName:firstName,
lastName:lastName,
email:email,
state:1,
answers:[],
_isRunning:!1,
_sendInterval:3e4,
add:function(a) {
var storedA;
return storedA = this.get(a._id), null != storedA ? angular.extend(storedA, a) :this.answers.push(angular.copy(a));
},
get:function(id) {
var a, j, len, ref;
for (ref = this.answers, j = 0, len = ref.length; len > j; j++) if (a = ref[j], 
a._id === id) return a;
},
getDXR:function() {
var a, data, j, len, ref;
for (data = {
examId:this.examId,
studentId:this.studentId,
studentCode:this.studentCode,
firstName:this.firstName,
lastName:this.lastName,
email:this.email,
state:this.state,
answers:angular.copy(this.answers)
}, ref = data.answers, j = 0, len = ref.length; len > j; j++) a = ref[j], delete a._id;
return data;
},
send:function() {
var data;
if (0 !== this.answers.length) return data = JSON.stringify(this.getDXR()), this.clear(), 
$http({
method:"post",
url:_apiBaseUrl + "api_answer.go",
data:$.param({
report:data
}),
headers:{
"Content-Type":"application/x-www-form-urlencoded;charset=utf-8"
}
}).then(function(response) {
return !response.data || response.data.error && response.data.code ? $q.reject(response) :void 0;
});
},
clear:function() {
return this.answers = [];
},
setInterval:function(i) {
return this._sendInterval = i, this.stop(), this.start();
},
setState:function(state) {
return this.state = state;
},
setStudentId:function(id) {
return this.studentId = id;
},
start:function() {
var _self;
return this._isRunning ? !1 :(_self = this, this._isRunning = !0, intervalPromise = $interval(function() {
return _self.send();
}, this._sendInterval), !0);
},
stop:function() {
return $interval.cancel(intervalPromise), this._isRunning = !1;
}
});
};
});
}.call(this), function() {
angular.module("digiexamclient.exam").factory("ExamInfo", function($q, $http, Question, Answer, DXLocalStorage) {
var ExamInfo;
return ExamInfo = function(data) {
var i, len, q, questions, ref;
if (angular.extend(this, {
about:"",
ancestor:0,
anonymous:!1,
at:new Date(),
blank:!1,
courseId:0,
defaultFontSize:0,
encryptionKey:"",
examStatus:0,
examType:0,
gradeId:0,
groupId:0,
id:0,
images:[],
isArchived:!1,
isDemo:!1,
isPlanned:!1,
isQuestionsLoaded:!1,
lastOfflineDownload:new Date(),
limit:0,
lockedFontSize:!1,
needPassword:!1,
needVersion:0,
open:!1,
organizationId:0,
parent:0,
published:!1,
questions:[],
start:new Date(),
stop:new Date(),
studentId:null,
subject:"",
title:"",
userId:0,
rightToLeft:!1,
_startOffline:!1,
extractAnswers:function() {
var answers, i, len, q, ref;
for (answers = [], ref = this.questions, i = 0, len = ref.length; len > i; i++) q = ref[i], 
answers.push(new Answer(q.type, q.id, q.answer)), delete q.answer;
return answers;
}
}), null != data) {
if (data.at = new Date(data.at), data.lastOfflineDownload = new Date(data.lastOfflineDownload), 
data.start = new Date(data.start), data.stop = new Date(data.stop), isArray(data.questions) && data.questions.length > 0) {
for (questions = [], ref = data.questions, i = 0, len = ref.length; len > i; i++) q = ref[i], 
questions.push(new Question(q.type, q));
data.questions = questions;
}
return angular.extend(this, data);
}
}, ExamInfo.getFromStorageById = function(id, studentCode) {
var key, promise;
return key = "u-" + studentCode + "-exam-" + id, promise = DXLocalStorage.get(key), 
promise.then(function(data) {
var exam;
return exam = data[key], null != exam ? new ExamInfo(exam) :null;
});
}, ExamInfo;
});
}.call(this), function() {
angular.module("digiexamclient.exam").service("ExamInfoRepository", function($q, $http, ExamInfo) {
var ExamInfoRepository, encode;
return encode = encodeURIComponent, ExamInfoRepository = {}, ExamInfoRepository.getByStudentCode = function(code) {
return code = encode(code), $http.get(_apiBaseUrl + "api_exams.go?studentId=" + code).then(function(response) {
var e, exams, i, len, ref;
if (200 !== response.status || null == response.data || response.data.error || response.data.code) return $q.reject(response);
for (exams = [], ref = response.data.examList, i = 0, len = ref.length; len > i; i++) e = ref[i], 
exams.push(new ExamInfo(e));
return exams;
});
}, ExamInfoRepository.getByOpenExamCode = function(code) {
return code = encode(code), $http.get(_apiBaseUrl + "api_exam_info.go?exam=" + code).then(function(response) {
return 200 !== response.status || null == response.data || response.data.error || response.data.code ? $q.reject(response) :new ExamInfo(response.data.examInfo);
});
}, ExamInfoRepository.get = function(examId, studentCode, firstname, lastname, email) {
return examId = encode(examId), studentCode = encode(studentCode), firstname = encode(firstname), 
lastname = encode(lastname), email = encode(email), $http.get(_apiBaseUrl + "api_exam.go?exam=" + examId + "&studentCode=" + studentCode + "&firstName=" + firstname + "&lastName=" + lastname + "&email=" + email).then(function(response) {
return 200 !== response.status || null == response.data || response.data.error || response.data.code ? $q.reject(response) :new ExamInfo(response.data);
});
}, ExamInfoRepository.offlineGet = function(examId, studentCode, firstname, lastname, email) {
return examId = encode(examId), studentCode = encode(studentCode), firstname = encode(firstname), 
lastname = encode(lastname), email = encode(email), $http.get(_apiBaseUrl + "api_offline_start.go?exam=" + examId + "&studentCode=" + studentCode + "&firstName=" + firstname + "&lastName=" + lastname + "&email=" + email).then(function(response) {
var id;
return 200 !== response.status || isObject(response) && isObject(response.data) ? $q.reject(response) :(id = parseInt(response.data, 10), 
isNaN(id) ? $q.reject(response) :id);
});
}, ExamInfoRepository;
});
}.call(this), function() {
angular.module("digiexamclient.exam").factory("Question", function(Answer, QuestionType, CapSettingEnum, Alternative) {
var Question, choiceQuestionTemplate, textualQuestionTemplate;
return textualQuestionTemplate = {
capSetting:CapSettingEnum.NONE,
capValue:null
}, choiceQuestionTemplate = {
alternatives:[]
}, Question = function(type, data) {
var a, alternatives, i, k, len, ref, unsupported, v;
angular.extend(this, {
id:0,
type:type,
title:"",
about:"",
images:[],
maxScore:null
}), unsupported = !0;
for (k in QuestionType) v = QuestionType[k], QuestionType[k] === type && (unsupported = !1);
if (unsupported) throw Error("Unsupported question type on question " + type);
if (type === QuestionType.TEXT_QUESTION ? angular.extend(this, angular.copy(textualQuestionTemplate)) :angular.extend(this, angular.copy(choiceQuestionTemplate)), 
null != data) {
if (type === QuestionType.SINGLE_CHOICE || type === QuestionType.MULTIPLE_CHOICE) {
for (alternatives = [], data.alternatives = data.alternatives || [], ref = data.alternatives, 
i = 0, len = ref.length; len > i; i++) a = ref[i], alternatives.push(new Alternative(a));
data.alternatives = alternatives;
}
angular.extend(this, data);
}
};
});
}.call(this), angular.module("digiexamclient.lockdown", []).factory("ElectronLockdown", function($q, $window) {
"use strict";
var ipc = $window.require("ipc"), modulePath = "./platforms/electron/node/build/Release/dxlockdown", nativeModule = $window.require(modulePath), prepareLockdown = function() {
$window.console.log("prepareLockdown");
}, executeLockdown = function() {
$window.console.log("Lockdown message: " + nativeModule.getName()), nativeModule.executeLockdown();
}, onLockdown = function() {
$window.console.log("Lockdown onLockdown"), ipc.send("kioskMode", !0), $window.console.log(nativeModule.onLockdown());
}, tearDown = function() {
$window.console.log("Lockdown teardown"), nativeModule.teardownLockdown();
};
return {
prepareLockdown:prepareLockdown,
executeLockdown:executeLockdown,
onLockdown:onLockdown,
tearDown:tearDown
};
}), angular.module("digiexamclient.lockdown").service("DXLockdown", function($window, ElectronLockdown, DX_PLATFORM) {
"use strict";
$window.console.log("DXLockdown");
var PLATFORM_LOCKDOWN = {
ELECTRON_APP:ElectronLockdown
};
return PLATFORM_LOCKDOWN[DX_PLATFORM];
}), angular.module("digiexamclient.platform").config(function($provide) {
"use strict";
var SYSTEMS = [ {
name:"ELECTRON_APP",
isCurrentSystem:function() {
return !window.isElectron;
}
}, {
name:"CHROME_APP",
isCurrentSystem:function() {
return !!(window.chrome && window.chrome.runtime && window.chrome.runtime.id);
}
}, {
name:"IOS_WEBVIEW",
isCurrentSystem:function() {
return /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
}
}, {
name:"BROWSER",
isCurrentSystem:function() {
return !0;
}
} ], getCurrentSystemName = function() {
for (var systemName = "UNKNOWN", i = 0; i < SYSTEMS.length; i++) {
var system = SYSTEMS[i];
if (system.isCurrentSystem.call()) {
systemName = system.name;
break;
}
}
return systemName;
}, systemName = getCurrentSystemName();
$provide.constant("DX_PLATFORM", systemName);
}), angular.module("digiexamclient.platform").run(function() {
"use strict";
}), angular.module("digiexamclient.preconditiontest", []).factory("ElectronPreconditionTest", function($q, $window, $http, DXFileSystem) {
"use strict";
var testCount, fs = $window.require("fs"), modulePath = "./platforms/electron/node/build/Release/dxpreconditiontests", nativeModule = $window.require(modulePath), appDataFolderPermissionRequired = function() {
return "Win32" === $window.navigator.platform ? 16822 :16832;
}(), subFolderPermissionRequired = function() {
return "Win32" === $window.navigator.platform ? 16822 :16877;
}(), dirs = [], fatalFailArray = [], folderPermissions = [ appDataFolderPermissionRequired, subFolderPermissionRequired, subFolderPermissionRequired ], statsReceived = [], warningArray = [], finishedTests = 0, onAllTestsDoneCallback = null, onTestDone = function(result) {
result.isSuccess || (result.isFailFatal ? fatalFailArray.push(result) :warningArray.push(result)), 
finishedTests++ === testCount && onAllTestsDoneCallback(warningArray, fatalFailArray);
}, internetAccessTest = function(callback) {
var apiBaseUrl = "https://digiexam-release.appspot.com/app#/";
$http.get(apiBaseUrl).then(function(response) {
var result = {
failTitle:"Internet access test",
failMessage:"No internet connection.",
isFailFatal:!1,
isSuccess:!1
};
result.isSuccess = 200 === response.status ? !0 :!1, callback(result);
});
}, createOnStatDoneCallback = function(dir, callback) {
var result = {
failTitle:"Write permission error.",
failMessage:"DigiExam does not have write permission in the cache directory on the file system.							Make sure that you have sufficient privileges to the DigiExam cache directory, 							otherwise please contact DigiExam for further troubleshooting",
isFailFatal:!0,
isSuccess:!1
};
return function(error, stats) {
if (statsReceived.push(stats), statsReceived.length === dirs.length) {
for (var i = 0; i < statsReceived.length; i++) {
if (statsReceived[i].mode !== folderPermissions[i]) {
result.isSuccess = !1;
break;
}
result.isSuccess = !0;
}
callback(result);
}
};
}, writePermissionTest = function() {
null === DXFileSystem.getExamDir() && DXFileSystem.makeDir(), null === DXFileSystem.getLogDir() && DXFileSystem.makeLogDir(), 
dirs = [ DXFileSystem.getAppDataDir(), DXFileSystem.getExamDir(), DXFileSystem.getLogDir() ];
for (var i = 0; i < dirs.length; i++) {
var onStatDoneCallback = createOnStatDoneCallback(dirs[i], onTestDone);
fs.stat(dirs[i], onStatDoneCallback);
}
}, init = function(callback) {
onAllTestsDoneCallback = callback, testCount = nativeModule.run(onTestDone) + 1, 
$window.console.log("Testcount: " + testCount), internetAccessTest(onTestDone), 
writePermissionTest();
};
return {
init:init
};
}), angular.module("digiexamclient.preconditiontest").service("DXPreConditionTest", function($window, ElectronPreconditionTest, DX_PLATFORM) {
"use strict";
var PLATFORM_PRECONDITIONTEST = {
ELECTRON_APP:ElectronPreconditionTest
};
return PLATFORM_PRECONDITIONTEST[DX_PLATFORM];
}), angular.module("digiexamclient.jsobjcbridge").factory("JsObjcBridge", function(DX_PLATFORM) {
"use strict";
var connectWebViewJavascriptBridge = function(callback) {
window.WebViewJavascriptBridge ? callback(WebViewJavascriptBridge) :document.addEventListener("WebViewJavascriptBridgeReady", function() {
callback(WebViewJavascriptBridge);
}, !1);
}, sendToObjc = function(message, callback) {
"IOS_WEBVIEW" === DX_PLATFORM && connectWebViewJavascriptBridge(function(bridge) {
"undefined" == typeof callback ? bridge.send(message) :bridge.send(message, callback);
});
}, sendCommand = function(command, data, callback) {
var message = {
command:command
};
data && (message.data = data), sendToObjc(message, callback);
}, setGuidedAccessLock = function(lock, successCallback, failCallback) {
var command = lock ? "lock_to_guided_access" :"unlock_from_guided_access";
sendCommand(command, null, function(didSucceed) {
"true" === didSucceed ? "function" == typeof successCallback && successCallback.call() :"function" == typeof failCallback && failCallback.call();
});
}, lockToGuidedAccess = function(successCallback, failCallback) {
setGuidedAccessLock(!0, successCallback, failCallback);
}, unlockFromGuidedAcess = function(successCallback, failCallback) {
setGuidedAccessLock(!1, successCallback, failCallback);
}, init = function() {
connectWebViewJavascriptBridge(function(bridge) {
bridge.init();
});
};
return init(), {
sendToObjc:sendToObjc,
sendCommand:sendCommand,
lockToGuidedAccess:lockToGuidedAccess,
unlockFromGuidedAcess:unlockFromGuidedAcess
};
}), function() {
angular.module("digiexamclient.session").factory("Session", function($rootScope, User, DXLocalStorage) {
var Session;
return Session = function() {
return angular.extend(this, {
user:null,
setUser:function(user) {
return null != user ? (this.user = user, DXLocalStorage.set("user", user)) :(this.user = null, 
DXLocalStorage.remove("user")), $rootScope.$broadcast("Session:User", this.user);
},
isAuthenticated:function() {
return null !== this.user;
},
restore:function() {
var _self, promise;
return _self = this, promise = DXLocalStorage.get("user"), promise.then(function(data) {
var user;
return user = new User(data.user), user.isValid() ? (_self.user = user, user) :null;
});
}
});
};
});
}.call(this), angular.module("digiexamclient.storage").factory("ExamStorage", function() {
"use strict";
var saveAnswers = function() {}, loadAnswers = function() {};
return {
saveAnswers:saveAnswers,
loadAnswers:loadAnswers
};
}), function() {
angular.module("digiexamclient.user").factory("User", function(ValidationService) {
var User, blobStoreBaseUrl, gravatarBaseUrl;
return gravatarBaseUrl = "https://www.gravatar.com/avatar/%h?s=64&d=mm", blobStoreBaseUrl = "blob/get/%h", 
User = function(data) {
angular.extend(this, {
email:"",
firstname:"",
lastname:"",
code:"",
image:"",
name:function() {
return this.firstname + " " + this.lastname;
},
isValidFirstname:function() {
return this.firstname.length > 0;
},
isValidLastname:function() {
return this.lastname.length > 0;
},
isValidCode:function() {
return this.code.length > 0;
},
isValidEmail:function() {
return ValidationService.isValidEmail(this.email);
},
isValid:function() {
return this.isValidEmail() && this.isValidFirstname() && this.isValidLastname() && this.isValidCode();
},
getProfileImage:function() {
var base, h;
if (base = gravatarBaseUrl, null != this.image && this.image.length > 0) base = blobStoreBaseUrl, 
h = this.image; else {
if (!(this.email.length > 0 && this.email[0].length > 0)) return null;
h = md5(this.email.toLowerCase());
}
return base.replace("%h", h);
}
}), null != data && angular.extend(this, data);
};
});
}.call(this), angular.module("digiexamclient.storage.filesystem").factory("BrowserFileSystem", function($window, $q, $timeout) {
"use strict";
var mockedPromise = function(resolveData) {
var deferred = $q.defer();
return $timeout(function() {
deferred.resolve(resolveData);
}, 0), deferred.promise;
}, requestFileSystem = function() {
return mockedPromise();
}, listDirectory = function() {
return mockedPromise();
}, makeDir = function() {
return mockedPromise();
}, openFile = function() {
return $window.alert("Browser file system"), mockedPromise();
}, readFile = function() {
return mockedPromise();
}, requestQuota = function() {
return mockedPromise();
}, saveAs = function() {
return mockedPromise();
}, writeFile = function() {
return mockedPromise();
};
return {
requestFileSystem:requestFileSystem,
listDirectory:listDirectory,
makeDir:makeDir,
openFile:openFile,
readFile:readFile,
requestQuota:requestQuota,
saveAs:saveAs,
writeFile:writeFile
};
}), function() {
angular.module("digiexamclient.storage.filesystem").factory("ChromeAppFileSystem", function($rootScope, $q, $window) {
var ChromeAppFileSystem, getPath, requestFileSystem;
return requestFileSystem = $window.requestFileSystem ? $window.requestFileSystem :$window.webkitRequestFileSystem, 
ChromeAppFileSystem = {}, ChromeAppFileSystem.openFile = function(accepts) {
var deferred;
return deferred = $q.defer(), $window.chrome.fileSystem.chooseEntry({
type:"openFile",
accepts:accepts
}, function(readOnlyEntry) {
return readOnlyEntry.file(function(file) {
var reader;
return reader = new FileReader(), reader.onerror = function() {
return deferred.reject("Could not open file."), $rootScope.$apply();
}, reader.onloadend = function(e) {
return deferred.resolve(e.target.result), $rootScope.$apply();
}, reader.readAsText(file);
});
}), deferred.promise;
}, ChromeAppFileSystem.saveAs = function(data, name, mime, accepts) {
var deferred;
return deferred = $q.defer(), $window.chrome.fileSystem.chooseEntry({
type:"saveFile",
suggestedName:name,
accepts:accepts
}, function(writableFileEntry) {
return writableFileEntry.createWriter(function(writer) {
return writer.onwrite = function() {
return writer.onwrite = null, writer.truncate(writer.position);
}, writer.onerror = function() {
return deferred.reject("Could not write to file.");
}, writer.onwriteend = function(e) {
return deferred.resolve(e);
}, writer.write(new Blob([ data ]), {
type:mime
});
});
}), deferred.promise;
}, ChromeAppFileSystem.requestQuota = function(bytes) {
var deferred, storageInfo;
return deferred = $q.defer(), storageInfo = null != $window.storageInfo ? $window.storageInfo :$window.webkitStorageInfo, 
storageInfo.requestQuota($window.PERSISTENT, bytes, function(quotaGranted) {
return deferred.resolve(quotaGranted);
}, function() {
return deferred.reject();
}), deferred.promise;
}, ChromeAppFileSystem.requestFileSystem = function(quota) {
var deferred;
return deferred = $q.defer(), requestFileSystem($window.PERSISTENT, quota, function(fs) {
return deferred.resolve(fs);
}, function(ex) {
return deferred.reject(ex);
}), deferred.promise;
}, getPath = function(path) {
return path = "/" === path[0] ? path.substr(1, path.length) :path, path = "/" !== path[path.length] ? path += "/" :path;
}, ChromeAppFileSystem.makeDir = function(quota, path, name) {
var deferred, fsPromise;
return deferred = $q.defer(), path = getPath(path), fsPromise = ChromeAppFileSystem.requestFileSystem(), 
fsPromise.then(function(fs) {
return fs.root.getDirectory("" + path + name, {
create:!0
}, function() {
return deferred.resolve();
}, function(ex) {
return deferred.reject(ex);
});
}, function() {}), deferred.promise;
}, ChromeAppFileSystem.readFile = function(quota, path, name) {
var deferred, fsPromise;
return deferred = $q.defer(), path = getPath(path), fsPromise = ChromeAppFileSystem.requestFileSystem(), 
fsPromise.then(function(fs) {
return fs.root.getFile("" + path + name, function(fileEntry) {
return fileEntry.file(function(file) {
var reader;
return reader = new FileReader(), reader.onloadend = function() {
return deferred.resolve(this.result);
}, reader.onerror = function(ex) {
return deferred.reject(ex);
}, reader.readAsText(file);
}, function(ex) {
return deferred.reject(ex);
});
}, function(ex) {
return deferred.reject(ex);
});
}, function(ex) {
return deferred.reject(ex);
}), deferred.promise;
}, ChromeAppFileSystem.writeFile = function(quota, path, filename, data, mime) {
var deferred, fsPromise;
return deferred = $q.defer(), path = getPath(path), fsPromise = ChromeAppFileSystem.requestFileSystem(), 
fsPromise.then(function(fs) {
return fs.root.getFile("" + path + filename + ".dxr", {
create:!0,
exclusive:!0
}, function(fileEntry) {
return fileEntry.createWriter(function(writer) {
return writer.onwriteend = function() {
return deferred.resolve();
}, writer.onerror = function(ex) {
return deferred.reject(ex);
}, writer.write(new Blob([ data ], {
type:mime
}));
}, function(ex) {
return deferred.reject(ex);
});
}, function(ex) {
return deferred.reject(ex);
});
}, function(ex) {
return deferred.reject(ex);
}), deferred.promise;
}, ChromeAppFileSystem.listDirectory = function(quota, path) {
var deferred, onError, onGetDirectorySuccess, onRequestFileSystemSuccess;
return deferred = $q.defer(), onError = function(ex) {
return deferred.reject(ex);
}, onRequestFileSystemSuccess = function(fs) {
return fs.root.getDirectory(path, {
create:!1
}, onGetDirectorySuccess, onError);
}, onGetDirectorySuccess = function(examDir) {
var files, onFinishedReading, readEntries, reader;
return reader = examDir.createReader(), files = [], onFinishedReading = function() {
return deferred.resolve(files);
}, readEntries = function() {
return reader.readEntries(function(results) {
return results.length ? (files = files.concat(results), readEntries()) :onFinishedReading();
});
}, readEntries();
}, ChromeAppFileSystem.requestFileSystem(quota).then(onRequestFileSystemSuccess, onError), 
deferred.promise;
}, ChromeAppFileSystem;
});
}.call(this), angular.module("digiexamclient.storage.filesystem").factory("ElectronFileSystem", function($q, $timeout, $window) {
"use strict";
var printModuleName = function() {
$window.console.log("Electron FS");
}, appDataFolder = null, delimiter = function() {
return "Win32" === $window.navigator.platform ? "\\" :"/";
}(), examDir = null, logDir = null, fs = $window.require("fs"), ipc = $window.require("ipc"), path = $window.require("path"), remote = $window.require("remote"), mockedPromise = function(resolveData) {
var deferred = $q.defer();
return $timeout(function() {
deferred.resolve(resolveData);
}, 0), deferred.promise;
}, requestFileSystem = function() {
return appDataFolder = remote.require("app").getPath("userData");
}, getAppDataDir = function() {
return appDataFolder;
}, getLogDir = function() {
return logDir;
}, getExamDir = function() {
return examDir;
}, makeLogDir = function(quota, filepath, name) {
name = "logs";
var deferred = $q.defer();
return ("" === filepath || void 0 === filepath) && (filepath = requestFileSystem()), 
filepath = path.join(filepath, name), fs.mkdir(filepath, function(err) {
err ? fs.statSync(filepath).isDirectory() ? deferred.resolve("Path " + filepath + delimiter + name + " already exists") :deferred.reject("Could not create dir: " + filepath) :deferred.resolve("filepath " + filepath + " created");
}), logDir = filepath, deferred.promise;
}, makeDir = function(quota, filepath, name) {
name = "exams";
var deferred = $q.defer();
return ("" === filepath || void 0 === filepath) && (filepath = requestFileSystem()), 
filepath = path.join(filepath, name), fs.mkdir(filepath, function(err) {
err ? fs.statSync(filepath).isDirectory() ? deferred.resolve("Path " + filepath + delimiter + name + " already exists") :deferred.reject("Could not create dir: " + filepath) :deferred.resolve("filepath " + filepath + " created");
}), examDir = filepath, deferred.promise;
}, listDirectory = function(quota, filepath) {
fs.readdir(filepath, function(err, files) {
return err ? [] :files;
});
}, readFile = function(quota, filepath, name) {
var deferred = $q.defer(), fileContent = "";
return fs.readFile(filepath + name, "utf8", function(err, data) {
err ? deferred.reject(err) :(fileContent = data, deferred.resolve(fileContent));
}), deferred.promise;
}, openFile = function(accepts) {
var fileType = accepts[0].extensions[0], deferred = $q.defer(), fileDescriptor = ipc.sendSync("openFile", fileType);
if (null === fileDescriptor) deferred.reject(); else {
fileDescriptor = fileDescriptor[0];
var filepath = fileDescriptor.substring(0, fileDescriptor.lastIndexOf(delimiter) + 1), filename = fileDescriptor.substring(fileDescriptor.lastIndexOf(delimiter) + 1, fileDescriptor.length), readFilePromise = readFile(null, filepath, filename);
readFilePromise.then(function(fileData) {
deferred.resolve(fileData);
}, function(reason) {
deferred.reject(reason);
});
}
return deferred.promise;
}, requestQuota = function() {
return mockedPromise();
}, writeFile = function(quota, filepath, filename, data) {
var deferred = $q.defer();
return path.isAbsolute(filepath) || (filepath = path.join(appDataFolder, filepath)), 
fs.writeFile(filepath + filename, data, function(err) {
err ? deferred.reject(err) :deferred.resolve();
}), deferred.promise;
}, saveAs = function(data, name, mime, accepts) {
var fileType = accepts[0].extensions[0], deferred = $q.defer(), fileDescriptor = ipc.sendSync("saveFile", fileType);
if (null === fileDescriptor) deferred.reject(); else {
var filepath = fileDescriptor.substring(0, fileDescriptor.lastIndexOf(delimiter) + 1), filename = fileDescriptor.substring(fileDescriptor.lastIndexOf(delimiter) + 1, fileDescriptor.length), writeFilePromise = writeFile(null, filepath, filename, data, mime);
writeFilePromise.then(function() {
deferred.resolve("success");
}, function(reason) {
deferred.reject(reason);
});
}
return deferred.promise;
};
return {
requestFileSystem:requestFileSystem,
listDirectory:listDirectory,
getAppDataDir:getAppDataDir,
getExamDir:getExamDir,
getLogDir:getLogDir,
makeLogDir:makeLogDir,
makeDir:makeDir,
openFile:openFile,
readFile:readFile,
requestQuota:requestQuota,
saveAs:saveAs,
writeFile:writeFile,
printModuleName:printModuleName
};
}), angular.module("digiexamclient.storage.filesystem").service("DXFileSystem", function($window, BrowserFileSystem, ElectronFileSystem, ChromeAppFileSystem, IOSFileSystem, DX_PLATFORM) {
"use strict";
var PLATFORM_FILE_SYSTEMS = {
ELECTRON_APP:ElectronFileSystem,
BROWSER:BrowserFileSystem,
CHROME_APP:ChromeAppFileSystem,
IOS_WEBVIEW:IOSFileSystem
};
return PLATFORM_FILE_SYSTEMS[DX_PLATFORM];
}), angular.module("digiexamclient.storage.filesystem").factory("IOSFileSystem", function($q, $timeout, JsObjcBridge) {
"use strict";
var COMMAND = {
MAKE_DIR:"make_dir",
READ_FILE:"read_file",
WRITE_FILE:"write_file",
LIST_DIRECTORY:"list_directory"
}, mockedPromise = function(resolveData) {
var deferred = $q.defer();
return $timeout(function() {
deferred.resolve(resolveData);
}, 0), deferred.promise;
}, makePromiseAndCallback = function() {
var deferred = $q.defer(), callback = function(data) {
deferred.resolve(data);
};
return {
promise:deferred.promise,
callback:callback
};
}, sendToObjc = function(data) {
var promiseAndCallback = makePromiseAndCallback(), promise = promiseAndCallback.promise, callback = promiseAndCallback.callback;
return JsObjcBridge.sendToObjc(data, callback), promise;
}, requestFileSystem = function() {
return mockedPromise();
}, listDirectory = function(quota, path) {
var data = {
command:COMMAND.LIST_DIRECTORY,
data:{
path:path
}
}, promise = sendToObjc(data);
return promise;
}, makeDir = function(quota, path, name) {
var data = {
command:COMMAND.MAKE_DIR,
data:{
path:path,
name:name
}
}, promise = sendToObjc(data);
return promise;
}, openFile = function() {
return mockedPromise();
}, readFile = function(quota, path, name) {
var data = {
command:COMMAND.READ_FILE,
data:{
path:path,
name:name
}
}, promise = sendToObjc(data);
return promise;
}, requestQuota = function() {
return mockedPromise();
}, saveAs = function() {
return mockedPromise();
}, writeFile = function(quota, path, filename, fileData, mime) {
var data = {
command:COMMAND.WRITE_FILE,
data:{
path:path,
filename:filename,
data:fileData,
mime:mime
}
}, promise = sendToObjc(data);
return promise;
};
return {
requestFileSystem:requestFileSystem,
listDirectory:listDirectory,
makeDir:makeDir,
openFile:openFile,
readFile:readFile,
requestQuota:requestQuota,
saveAs:saveAs,
writeFile:writeFile
};
}), angular.module("digiexamclient.storage.localstorage").factory("BrowserLocalStorage", function($q, $window) {
"use strict";
var BadLocalStorageArgumentType = function(message) {
var defaultMessage = "This implementation of local storage's get, set and remove methods requires key arguments to be of type string";
Error.call(this), Error.captureStackTrace(this, this.constructor), this.name = "BadLocalStorageArgumentType", 
this.message = message || defaultMessage;
};
BadLocalStorageArgumentType.prototype = Error.prototype;
var verifyKeyTypeIsString = function(key, deferred) {
if ("string" != typeof key) {
var e = new BadLocalStorageArgumentType();
throw deferred.reject(e), e;
}
}, get = function(key) {
var deferred = $q.defer(), ret = {};
return verifyKeyTypeIsString(key, deferred), void 0 !== !$window.localStorage.getItem(key) && (ret[key] = $window.localStorage.getItem(key) ? JSON.parse($window.localStorage[key]) :void 0, 
deferred.resolve(ret)), deferred.promise;
}, set = function(key, value) {
var deferred = $q.defer();
return verifyKeyTypeIsString(key, deferred), $window.localStorage.setItem(key, JSON.stringify(value)), 
deferred.resolve(), deferred.promise;
}, remove = function(key) {
var deferred = $q.defer();
verifyKeyTypeIsString(key, deferred);
try {
$window.localStorage.removeItem(key), deferred.resolve();
} catch (e) {
deferred.reject(e);
}
return deferred.promise;
}, clear = function() {
var deferred = $q.defer();
try {
for (var key in $window.localStorage) $window.localStorage.hasOwnProperty(key) && $window.localStorage.removeItem(key);
deferred.resolve();
} catch (e) {
deferred.reject(e);
}
return deferred.promise;
};
return {
get:get,
set:set,
remove:remove,
clear:clear
};
}), function() {
angular.module("digiexamclient.storage.localstorage").factory("ChromeAppLocalStorage", function($rootScope, $window, $q) {
var ChromeAppLocalStorage;
return ChromeAppLocalStorage = {
get:function(data) {
var deferred;
return deferred = $q.defer(), $window.chrome.storage.local.get(data, function(data) {
return null != $window.chrome.runtime.lastError ? deferred.reject($window.chrome.runtime.lastError) :deferred.resolve(data);
}), deferred.promise;
},
set:function(key, value) {
var copy, deferred, obj;
return deferred = $q.defer(), obj = {}, "string" == typeof key && (obj[key] = value), 
isObject(key) && (obj = key), copy = JSON.parse(JSON.stringify(obj)), $window.chrome.storage.local.set(copy, function() {
return null != $window.chrome.runtime.lastError ? deferred.reject($window.chrome.runtime.lastError) :deferred.resolve();
}), deferred.promise;
},
remove:function(data) {
var deferred;
return deferred = $q.defer(), $window.chrome.storage.local.remove(data), null != $window.chrome.runtime.lastError ? deferred.reject($window.chrome.runtime.lastError) :deferred.resolve(), 
deferred.promise;
},
clear:function() {
var deferred;
return deferred = $q.defer(), $window.chrome.storage.local.clear(), null != $window.chrome.runtime.lastError ? deferred.reject($window.chrome.runtime.lastError) :deferred.resolve(), 
deferred.promise;
}
};
});
}.call(this), angular.module("digiexamclient.storage.localstorage").factory("ElectronLocalStorage", function($q, $window) {
"use strict";
var BadLocalStorageArgumentType = function(message) {
var defaultMessage = "This implementation of local storage's get, set and remove methods requires key arguments to be of type string";
Error.call(this), Error.captureStackTrace(this, this.constructor), this.name = "BadLocalStorageArgumentType", 
this.message = message || defaultMessage;
};
BadLocalStorageArgumentType.prototype = Error.prototype;
var verifyKeyTypeIsString = function(key, deferred) {
if ("string" != typeof key) {
var e = new BadLocalStorageArgumentType();
throw deferred.reject(e), e;
}
}, get = function(key) {
var deferred = $q.defer(), ret = {};
return verifyKeyTypeIsString(key, deferred), void 0 !== !$window.localStorage.getItem(key) && (ret[key] = $window.localStorage.getItem(key) ? JSON.parse($window.localStorage[key]) :void 0, 
deferred.resolve(ret)), deferred.promise;
}, set = function(key, value) {
var deferred = $q.defer();
return verifyKeyTypeIsString(key, deferred), $window.localStorage.setItem(key, JSON.stringify(value)), 
deferred.resolve(), deferred.promise;
}, remove = function(key) {
var deferred = $q.defer();
verifyKeyTypeIsString(key, deferred);
try {
$window.localStorage.removeItem(key), deferred.resolve();
} catch (e) {
deferred.reject(e);
}
return deferred.promise;
}, clear = function() {
var deferred = $q.defer();
try {
for (var key in $window.localStorage) $window.localStorage.hasOwnProperty(key) && $window.localStorage.removeItem(key);
deferred.resolve();
} catch (e) {
deferred.reject(e);
}
return deferred.promise;
};
return {
get:get,
set:set,
remove:remove,
clear:clear
};
}), angular.module("digiexamclient.storage.localstorage").factory("IOSLocalStorage", function($q, $timeout, $rootScope, JsObjcBridge) {
"use strict";
var COMMAND = {
GET:"get_local_storage_key",
SET:"set_local_storage_key",
REMOVE:"remove_local_storage_key",
CLEAR:"clear_local_storage"
}, sendToObjc = function(data, dataTranformer) {
var deferred = $q.defer(), callback = function(responseData) {
try {
responseData = JSON.parse(responseData);
} catch (e) {
angular.noop();
}
"undefined" != typeof dataTranformer && (responseData = dataTranformer.call(this, responseData)), 
deferred.resolve(responseData), $rootScope.$apply();
};
return JsObjcBridge.sendToObjc(data, callback), deferred.promise;
}, get = function(key) {
var data = {
command:COMMAND.GET,
data:{
key:key
}
}, dataTranformer = function(inData) {
var retData = {};
return retData[key] = inData || null, retData;
}, promise = sendToObjc(data, dataTranformer);
return promise;
}, set = function(key, value) {
var data = {
command:COMMAND.SET,
data:{
key:key,
value:JSON.stringify(value)
}
}, promise = sendToObjc(data);
return promise;
}, remove = function(key) {
var data = {
command:COMMAND.REMOVE,
data:{
key:key
}
}, promise = sendToObjc(data);
return promise;
}, clear = function() {
var data = {
command:COMMAND.CLEAR
}, promise = sendToObjc(data);
return promise;
};
return {
get:get,
set:set,
remove:remove,
clear:clear
};
}), angular.module("digiexamclient.storage.localstorage").service("DXLocalStorage", function($window, BrowserLocalStorage, ChromeAppLocalStorage, ElectronLocalStorage, IOSLocalStorage, DX_PLATFORM) {
"use strict";
var PLATFORM_LOCAL_STORAGES = {
ELECTRON_APP:ElectronLocalStorage,
BROWSER:BrowserLocalStorage,
CHROME_APP:ChromeAppLocalStorage,
IOS_WEBVIEW:IOSLocalStorage
};
return PLATFORM_LOCAL_STORAGES[DX_PLATFORM];
}), function() {
angular.module("digiexamclient").constant("AnswerState", {
NO_DATA:0,
DRAFT:1,
FINAL:2,
BLANK:3
});
}.call(this), function() {
angular.module("digiexamclient").constant("DebugMessageType", {
CRITICAL:0,
WARNING:1,
NORMAL:2
});
}.call(this), function() {
angular.module("digiexamclient").constant("QuestionType", {
TEXT_QUESTION:0,
SINGLE_CHOICE:1,
MULTIPLE_CHOICE:2,
TEXT_ONLY:3
});
}.call(this), function() {
angular.module("digiexamclient").constant("Urls", {
get:function(route, parameters) {
var key, url, value;
if (null == parameters && (parameters = {}), url = this.routes[route], "string" != typeof url) throw Error("[Urls] Route does not exist: " + route);
for (key in parameters) value = parameters[key], value instanceof Array && (value = value.join(",")), 
url = url.replace(":" + key, value);
return url;
},
routes:{
login:"/",
overview:"/overview",
userEdit:"/user/edit",
exam:"/exam/:id/:startOffline"
}
});
}.call(this), function() {
angular.module("digiexamclient").directive("dxImageList", function() {
return {
restrict:"E",
scope:{
images:"=",
track:"="
},
template:"<div class='image-list'></div>",
replace:!0,
link:function($scope, element) {
var generateList, hasGenerated;
return hasGenerated = !1, generateList = function(track, images) {
var data, i, image, len, link, results, thumb;
for (results = [], i = 0, len = images.length; len > i; i++) data = images[i], thumb = document.createElement("div"), 
thumb.setAttribute("class", "thumb"), link = document.createElement("a"), link.setAttribute("href", "data:image/png;base64," + data), 
link.setAttribute("data-lightbox", "image-" + track), image = new Image(), image.src = "data:image/png;base64," + data, 
image.setAttribute("alt", "Image attachment"), image.setAttribute("data-lightbox", "image-" + track), 
link.appendChild(image), thumb.appendChild(link), results.push(element.append(thumb));
return results;
}, $scope.$watch("images", function() {
return null == $scope.images || hasGenerated || 0 === $scope.images.length ? void 0 :(generateList($scope.track, $scope.images), 
hasGenerated = !0);
});
}
};
});
}.call(this), angular.module("digiexamclient").directive("dxSetPlatformClass", function(DX_PLATFORM) {
"use strict";
var link = function(scope, element) {
element.addClass("dx-" + DX_PLATFORM.toLowerCase().replace("_", "-"));
};
return {
restrict:"A",
link:link
};
}), function() {
angular.module("digiexamclient").directive("email", function(ValidationService) {
return {
require:"ngModel",
link:function(scope, element, attrs, ngModel) {
return ngModel.$parsers.unshift(function(viewValue) {
return ValidationService.isValidEmail(viewValue) ? (ngModel.$setValidity("email", !0), 
viewValue) :(ngModel.$setValidity("email", !1), viewValue);
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("loader", function() {
return {
restrict:"E",
template:'<div class="loader"><div ng-transclude></div><div class="loader-indicator"><svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ng-bind-attrs="getSVGAttributes()" xml:space="preserve"><path opacity="0.2" fill="#ce4e41" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/><path fill="#ce4e41" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.7s" repeatCount="indefinite"/></path></svg></div></div>',
transclude:!0,
replace:!0
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("ngEnter", function($parse) {
return {
restrict:"A",
link:function(scope, element, attrs) {
var fn;
return fn = $parse(attrs.ngEnter), element.on("keydown keypress", function(event) {
return 13 === event.which ? (scope.$apply(function() {
return (fn || angular.noop)(scope, {
$event:event
});
}), event.preventDefault()) :void 0;
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("noNavigateOnDisabled", function() {
return {
restrict:"A",
link:function(scope, element) {
return element.on("click", function(event) {
return element.attr("disabled") && "false" !== element.attr("disabled") && element.attr("disabled") !== !1 ? event.preventDefault() :void 0;
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("noPaste", function() {
return {
link:function(scope, element) {
return element.on("paste", function(e) {
return e.preventDefault();
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("noWhitespace", function() {
return {
require:"ngModel",
link:function(scope, element, attrs, ngModel) {
return ngModel.$parsers.unshift(function(viewValue) {
return /\s+/.test(viewValue) === !1 ? (ngModel.$setValidity("noWhitespace", !0), 
viewValue) :(ngModel.$setValidity("noWhitespace", !1), viewValue);
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("sameAs", function($parse) {
return {
require:"ngModel",
link:function(scope, element, attrs, ngModel) {
return ngModel.$parsers.unshift(function(viewValue) {
var match;
return match = $parse(attrs.sameAs)(scope), viewValue === match ? (ngModel.$setValidity("sameAs", !0), 
viewValue) :(ngModel.$setValidity("sameAs", !1), viewValue);
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("toLowercase", function() {
return {
require:"ngModel",
link:function(scope, element, attrs, ngModel) {
return ngModel.$parsers.unshift(function(viewValue) {
return (viewValue || "").toLowerCase();
});
}
};
});
}.call(this), function() {
angular.module("digiexamclient").directive("userDetails", function() {
return {
restrict:"E",
template:'<form name="details"><ul class="unstyledList mb"><li class="mb-300"><label for="studentCode">Student code</label><div class="input-error-wrapper"><input type="text" id="studentCode" ng-model="user.code" name="code" required autocorrect="off" autocapitalize="off" no-whitespace to-lowercase> <span class="input-error" ng-show="details.code.$error.noWhitespace && !details.code.$pristine">Student code can\'t contain spaces</span> <span class="input-error" ng-show="details.code.$error.required && !details.code.$pristine">Student code is required</span></div></li><li class="mb-300"><label for="firstname">First name</label><div class="input-error-wrapper"><input type="text" id="firstname" ng-model="user.firstname" name="firstname" required autocorrect="off"> <span class="input-error" ng-show="details.firstname.$invalid && !details.firstname.$pristine">First name is required</span></div></li><li class="mb-300"><label for="lastname">Last name</label><div class="input-error-wrapper"><input type="text" id="lastname" ng-model="user.lastname" name="lastname" required autocorrect="off"> <span class="input-error" ng-show="details.lastname.$invalid && !details.lastname.$pristine">Last name is required</span></div></li><li class="mb-300"><label for="email">E-mail address</label><div class="input-error-wrapper"><input type="email" id="email" ng-model="user.email" name="email" required email> <span class="input-error" ng-show="details.email.$invalid && !details.email.$pristine">A valid e-mail address is required</span></div></li><li><label for="confirm-email">Confirm e-mail address</label><div class="input-error-wrapper"><input type="email" id="confirm-email" ng-model="confirmEmail" name="confirmEmail" required email same-as="user.email" no-paste> <span class="input-error" ng-show="details.confirmEmail.$error.sameAs && !details.confirmEmail.$pristine">The e-mail addresses does not match</span></div></li></ul><button class="btn btn-green" ng-click="save()" ng-disabled="details.$invalid">OK</button></form>',
scope:{
user:"="
},
controller:function($scope, $location, SessionService) {
return $scope.confirmEmail = $scope.user.email.length > 0 ? $scope.user.email :"", 
$scope.$watch("user.email", function(n, o) {
return n !== o ? $scope.confirmEmail = "" :void 0;
}), $scope.save = function() {
return SessionService.setUser($scope.user), $scope.$emit("Statusbar:SetUser", $scope.user), 
location.reload();
};
}
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("DebugController", function($rootScope, $scope, DebugMessageType, DXFileSystem) {
return $scope.messages = [], $scope.dxrFiles = [], $scope.showMessages = !1, $rootScope.$on("Debug:Critical", function(event, message) {
return $scope.messages.push({
type:DebugMessageType.CRITICAL,
message:message
});
}), $rootScope.$on("Debug:Warning", function(event, message) {
return $scope.messages.push({
type:DebugMessageType.WARNING,
message:message
});
}), $rootScope.$on("Debug:Message", function(event, message, type) {
return null == type && (type = DebugMessageType.NORMAL), $scope.messages.push({
type:type,
message:message
});
}), $rootScope.$on("Debug:Show", function() {
return $scope.showMessages = !0;
}), $scope.clear = function() {
return $scope.messages = [];
}, $scope.toggleDebugMessages = function() {
return $scope.showMessages = !$scope.showMessages;
}, $scope.saveDXR = function(fileEntry) {
return fileEntry.file(function(file) {
var reader;
return reader = new FileReader(), reader.onloadend = function() {
var accepts;
return accepts = [ {
extensions:[ "dxr" ]
} ], DXFileSystem.saveAs(reader.result, fileEntry.name, "text/plain", accepts);
}, reader.onerror = function(ex) {
return console.log(ex);
}, reader.readAsText(file);
});
}, $scope.readDXRFiles = function() {
var fsQuotaPromise;
return fsQuotaPromise = DXFileSystem.requestQuota(104857600), fsQuotaPromise.then(function(quota) {
return DXFileSystem.listDirectory(quota, "exams").then(function(files) {
return $scope.dxrFiles = files;
});
});
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("ExamController", function($rootScope, $scope, $routeParams, $location, $modal, $interval, $q, $filter, $http, Urls, Answer, AnswerQueue, AnswerState, ExamInfo, ExamInfoRepository, SessionService, DXLocalStorage, DXFileSystem, JsObjcBridge, QuestionType, DX_PLATFORM, DXLockdown, GradingTypeEnum) {
var fsQuotaPromise, queue, storageAnswersKey, storageExamKey;
return $scope.QuestionType = QuestionType, $scope.GradingTypeEnum = GradingTypeEnum, 
$scope.isLoading = !0, $scope.showTurnInButton = !0, $scope.exam = new ExamInfo({
id:parseInt($routeParams.id, 10)
}), $scope.answers = [], $scope.$emit("Statusbar:OnExamStart", $scope.exam.id), 
storageExamKey = "u-" + SessionService.user.code + "-exam-" + $scope.exam.id, storageAnswersKey = "u-" + SessionService.user.code + "-exam-" + $scope.exam.id + "-answers", 
queue = null, $scope.fsQuota = 0, $scope.startOffline = "true" === $routeParams.startOffline, 
fsQuotaPromise = DXFileSystem.requestQuota(104857600), fsQuotaPromise.then(function(quota) {
return $scope.fsQuota = quota;
}), $scope.initializeExamView = function() {
return $q.all([ ExamInfo.getFromStorageById($scope.exam.id, SessionService.user.code), Answer.getFromStorageByExamId($scope.exam.id, SessionService.user.code) ]).then($scope.handleFileSystemInitializeSuccess, $scope.handleStorageError);
}, $scope.handleFileSystemInitializeSuccess = function(results) {
var promise, responseFail, responseSuccess, storedAnswers, storedExam;
return storedExam = results[0], storedAnswers = results[1], responseSuccess = function(onlineExam) {
return $scope.initializeExam(onlineExam, storedExam, storedAnswers);
}, responseFail = function(response) {
return $scope.handleOnlineExamInitializeFail(response, storedExam, storedAnswers);
}, $scope.startOffline ? (null != storedExam ? responseSuccess() :responseFail(), 
$scope.isLoading = !1) :(promise = ExamInfoRepository.get($scope.exam.id, SessionService.user.code, SessionService.user.firstname, SessionService.user.lastname, SessionService.user.email).then(responseSuccess, responseFail), 
promise["finally"](function() {
return $scope.isLoading = !1;
}));
}, $scope.initializeExam = function(onlineExam, storedExam, storedAnswers) {
var answers;
return 0 === storedAnswers.length ? (answers = null != storedExam ? $scope.extractAnswers(storedExam) :$scope.extractAnswers(onlineExam), 
$scope.saveAnswersToStorage(answers)) :answers = storedAnswers, $scope.answers = answers, 
null != storedExam ? $scope.startExam(storedExam) :($scope.startExam(onlineExam), 
$scope.saveExamToStorage(onlineExam));
}, $scope.extractAnswers = function(exam) {
var answers, i, len, q, ref;
for (answers = [], ref = exam.questions, i = 0, len = ref.length; len > i; i++) q = ref[i], 
answers.push(new Answer(q.type, q.id, q.answer)), delete q.answer;
return answers;
}, $scope.startExam = function(exam) {
var failedToLockToGuidedAccess, successfullyLockedToGuidedAccess;
return successfullyLockedToGuidedAccess = function() {
var u;
return $scope.exam = new ExamInfo(exam), u = SessionService.user, $scope.startOffline && $scope.startOfflineStartPoll(exam.id, u.code, u.firstname, u.lastname, u.email), 
queue = new AnswerQueue($scope.exam.id, $scope.exam.studentId, u.code, u.firstname, u.lastname, u.email), 
queue.setState(AnswerState.DRAFT), queue.start();
}, failedToLockToGuidedAccess = function() {
return $scope.$emit("Toast:Notification", "Could not lock to guided access and will therefore not start exam"), 
$location.path(Urls.get("overview"));
}, "IOS_WEBVIEW" === DX_PLATFORM ? JsObjcBridge.lockToGuidedAccess(successfullyLockedToGuidedAccess, failedToLockToGuidedAccess) :successfullyLockedToGuidedAccess();
}, $scope.handleOnlineExamInitializeFail = function(response, storedExam, storedAnswers) {
return response && response.data ? $scope.handleOnlineExamStartError(response.data.code, response.data.error) :null != storedExam ? $scope.initializeExam(null, storedExam, storedAnswers) :($scope.$emit("Statusbar:OnExamEnd"), 
$scope.$emit("Toast:Notification", "No local exam and no connection to server"), 
$location.path(Urls.get("overview")));
}, $scope.handleOnlineExamStartError = function(code, message) {
switch (code) {
case 22:
$scope.$emit("Toast:Notification", "Exam has ended");
break;

case 24:
$scope.$emit("Toast:Notification", "Exam already downloaded");
break;

default:
$scope.$emit("Toast:Notification", "Server error: '" + message + "'");
}
return $scope.$emit("Statusbar:OnExamEnd"), $location.path(Urls.get("overview"));
}, $scope.handleStorageError = function() {
return $scope.isLoading = !1, $scope.showTurnInButton = !1, $modal.show({
templateUrl:"partials/modals/error/storage-exception.html",
controller:"ModalErrorStorageExceptionController"
});
}, $scope.onAnswerChange = function(a) {
return $scope.saveAnswersToStorage($scope.answers), queue.add(a);
}, $scope.confirmTurnIn = function() {
var instance;
return queue.send(), queue.stop(), instance = $modal.show({
templateUrl:"partials/modals/exam/confirm-turn-in.html",
controller:"ModalGenericConfirmController"
}), instance.result.then(function() {
return $scope.turnIn();
}, function() {
return queue.start();
}), instance;
}, $scope.turnIn = function() {
var a, i, len, promise, ref;
for (queue.setState(AnswerState.FINAL), ref = $scope.answers, i = 0, len = ref.length; len > i; i++) a = ref[i], 
queue.add(a);
return promise = queue.send(), promise.then(function() {
return $scope.handleSuccessfulTurnIn();
}, function() {
return "IOS_WEBVIEW" !== DX_PLATFORM ? $scope.showOfflineFileTurnInDialog() :(DXLockdown.tearDown(), 
$scope.showUploadLaterDialog());
});
}, $scope.handleSuccessfulTurnIn = function() {
var promise;
return promise = $scope.reassignStoredData(), promise.then(function() {
return DXLockdown.tearDown(), $scope.showSuccessfulTurnInModal();
});
}, $scope.showOfflineFileTurnInDialog = function() {
var modalInstance, modalScope;
return modalScope = $rootScope.$new(), modalScope.exam = $scope.exam, modalScope.answers = $scope.answers, 
modalInstance = $modal.show({
$scope:modalScope,
templateUrl:"partials/modals/exam/offline-turn-in.html",
controller:"ModalOfflineTurnInController"
}), modalInstance.result.then(function() {
return $scope.handleSuccessfulTurnIn();
}), modalInstance;
}, $scope.showSuccessfulTurnInModal = function() {
return $modal.show({
templateUrl:"partials/modals/exam/successful-turn-in.html",
controller:"ModalSuccessfulTurnInController"
});
}, $scope.showUploadLaterDialog = function() {
return $modal.show({
templateUrl:"partials/modals/exam/failed-turn-in.html",
controller:"ModalSuccessfulTurnInController"
});
}, $scope.reassignStoredData = function() {
var date, dxr, newStorageExamKey, promise;
return date = $filter("date")(new Date(), "yyyyMMdd-HHmmss"), newStorageExamKey = storageExamKey + ("-" + date), 
dxr = $scope.getFinalDXR(), queue.clear(), promise = DXFileSystem.writeFile($scope.fsQuota, "exams/", newStorageExamKey, JSON.stringify(dxr), "text/plain"), 
promise.then(function() {
return $q.all([ DXLocalStorage.remove(storageExamKey), DXLocalStorage.remove(storageAnswersKey) ]);
});
}, $scope.getFinalDXR = function() {
var a, i, len, ref;
for (queue.setState(AnswerState.FINAL), ref = $scope.answers, i = 0, len = ref.length; len > i; i++) a = ref[i], 
queue.add(a);
return queue.getDXR();
}, $scope.offlineStartPollInterval = 1e4, $scope.offlineStartPollIntervalPromise = null, 
$scope.offlineStartPoll = function(examId, studentCode, firstname, lastname, email) {
return ExamInfoRepository.offlineGet(examId, studentCode, firstname, lastname, email).then(function(studentId) {
return null != studentId ? ($scope.setExamStudentId(studentId), $scope.stopOfflineStartPoll()) :void 0;
});
}, $scope.startOfflineStartPoll = function(examId, studentCode, firstname, lastname, email) {
return $scope.offlineStartPollIntervalPromise = $interval(function() {
return $scope.offlineStartPoll(examId, studentCode, firstname, lastname, email);
}, $scope.offlineStartPollInterval);
}, $scope.stopOfflineStartPoll = function() {
return $interval.cancel($scope.offlineStartPollIntervalPromise);
}, $scope.getQueue = function() {
return queue;
}, $scope.saveExamToStorage = function(exam) {
return DXLocalStorage.set(storageExamKey, exam);
}, $scope.saveAnswersToStorage = function(answers) {
return DXLocalStorage.set(storageAnswersKey, answers);
}, $scope.setExamStudentId = function(studentId) {
return null != studentId ? ($scope.exam.studentId = studentId, queue.setStudentId(studentId)) :void 0;
}, $scope.initializeExamView();
});
}.call(this), function() {
angular.module("digiexamclient").controller("LoginController", function($scope, $location, $modal, DXClient, DXFileSystem, Urls, SessionService, User, DX_PLATFORM) {
var fsQuotaPromise;
return $scope.user = new User(), $scope.showAuth = !1, $scope.isLoading = !0, "CHROME_APP" !== DX_PLATFORM || DXClient.isKiosk ? ($scope.handleStorageError = function() {
return $modal.show({
templateUrl:"partials/modals/error/storage-exception.html",
controller:"ModalErrorStorageExceptionController"
});
}, $scope.handleUserRestoreSuccess = function(user) {
return $scope.$emit("Statusbar:SetUser", user), $location.path(Urls.get("overview"));
}, $scope.handleUserRestoreFail = function() {
return $scope.isLoading = !1, $scope.showAuth = !0;
}, $scope.initializeUser = function() {
var promise;
return promise = SessionService.restore(), promise.then(function(user) {
return user ? $scope.handleUserRestoreSuccess(user) :$scope.handleUserRestoreFail();
}, function() {
return $scope.handleUserRestoreFail();
});
}, fsQuotaPromise = DXFileSystem.requestQuota(104857600), fsQuotaPromise.then(function(grantedBytes) {
var createDirPromise;
return createDirPromise = DXFileSystem.makeDir(grantedBytes, "", "exams"), createDirPromise.then(function() {
return $scope.initializeUser();
}, function(ex) {
return $scope.handleStorageError(ex);
});
}, function(ex) {
return $scope.handleStorageError(ex);
})) :void 0;
});
}.call(this), function() {
angular.module("digiexamclient").controller("OverviewController", function($rootScope, $scope, $window, $modal, $location, $interval, $log, Urls, SessionService, Answer, ExamInfo, ExamInfoRepository, DXFileSystem, DXLocalStorage, DXLockdown, DX_PLATFORM) {
return $scope.loadingExams = !0, $scope.exams = [], $scope.openExamCode = "", $scope.openExamError = "", 
$scope.openOfflineFileError = "", $scope.demoExamError = "", $scope.DX_PLATFORM = DX_PLATFORM, 
$scope.selectedExam = null, $scope.truncateDescription = !0, $scope.resetErrorMessages = function() {
return $scope.openExamError = "", $scope.openOfflineFileError = "", $scope.demoExamError = "";
}, $scope.refreshExams = function() {
var promise;
return $scope.loadingExams = !0, $scope.exams = [], $scope.resetErrorMessages(), 
promise = ExamInfoRepository.getByStudentCode(SessionService.user.code).then(function(exams) {
return $scope.exams = exams, $scope.selectedExam = exams.length > 0 ? $scope.exams[0] :null;
}, function() {
return $scope.$emit("Toast:Notification", "Could not communicate with DigiExam servers");
}), promise["finally"](function() {
return $scope.loadingExams = !1, $scope.truncateDescription = !0;
});
}, $scope.isValidOpenExamCode = function(code) {
return "number" == typeof code && code > 0;
}, $scope.getOpenExam = function() {
var promise;
if ($scope.isValidOpenExamCode($scope.openExamCode)) return $scope.loadingExams = !0, 
$scope.resetErrorMessages(), promise = ExamInfoRepository.getByOpenExamCode($scope.openExamCode).then(function(exam) {
return $scope.exams = [ exam ], $scope.selectedExam = exam;
}, function(response) {
if (!isObject(response.data) || null == response.data.code || null == response.data.error) return $scope.$emit("Toast:Notification", "Could not communicate with DigiExam servers");
switch (response.data.code) {
case 40:
return $scope.openExamError = "Could not find exam.";

default:
return $scope.openExamError = "Server error: '" + response.data.error + "'";
}
}), promise["finally"](function() {
return $scope.loadingExams = !1, $scope.truncateDescription = !0;
});
}, $scope.getDemoExam = function() {
var promise;
return $scope.resetErrorMessages(), promise = ExamInfoRepository.getByOpenExamCode(0), 
promise.then(function(exam) {
return $scope.exams = [ exam ], $scope.selectedExam = exam;
}, function(response) {
if (!(isObject(response.data) && response.data.code && response.data.error)) return $scope.$emit("Toast:Notification", "Could not communicate with DigiExam servers");
switch (response.data.code) {
case 40:
return $scope.demoExamError = "Could not find demo exam.";

default:
return $scope.demoExamError = "Server error: '" + response.data.error + "'";
}
});
}, $scope.extendAnswers = function(destAnswers, srcAnswers) {
var a, answers, i, j, len;
for (answers = [], i = j = 0, len = destAnswers.length; len > j; i = ++j) a = destAnswers[i], 
null != srcAnswers[i] && (a = angular.extend(a, srcAnswers[i])), answers.push(a);
return answers;
}, $scope.parseDXE = function(dxe) {
var exam, examInfo, j, len, q, ref;
for (examInfo = new ExamInfo(angular.extend(dxe.examList[0], {
_startOffline:!0
})), exam = new ExamInfo(dxe.exams[0]), ref = exam.questions, j = 0, len = ref.length; len > j; j++) q = ref[j], 
q.answer = new Answer(q.type, q.id);
return {
examInfo:examInfo,
exam:exam
};
}, $scope.isValidDXE = function(dxe) {
var hasExamList, hasExams, isObj;
return isObj = isObject(dxe), hasExamList = isObj && isArray(dxe.examList) && dxe.examList.length > 0, 
hasExams = isObj && isArray(dxe.exams) && dxe.exams.length > 0, hasExamList && hasExams;
}, $scope.saveExamToStorage = function(exam) {
return DXLocalStorage.set("u-" + SessionService.user.code + "-exam-" + exam.id, exam);
}, $scope.saveAnswersToStorage = function(examId, answers) {
return DXLocalStorage.set("u-" + SessionService.user.code + "-exam-" + examId + "-answers", answers);
}, $scope.handleGetAnswersFromStorageSuccess = function(dxe, storedAnswers) {
var answers;
return answers = $scope.extendAnswers(dxe.exam.extractAnswers(), storedAnswers), 
$scope.saveExamToStorage(dxe.exam), $scope.saveAnswersToStorage(dxe.exam.id, answers), 
$scope.selectedExam = dxe.examInfo, $scope.exams = [ dxe.examInfo ];
}, $scope.handleOpenOfflineFileSuccess = function(data) {
var dxe;
return dxe = JSON.parse(data), $scope.isValidDXE(dxe) ? (dxe = $scope.parseDXE(dxe), 
Answer.getFromStorageByExamId(dxe.exam.id, SessionService.user.code).then(function(storedAnswers) {
return $scope.handleGetAnswersFromStorageSuccess(dxe, storedAnswers);
})) :$scope.openOfflineFileError = "Couldn't read file.";
}, $scope.openOfflineFile = function() {
var promise;
return $scope.openOfflineFileError = "", $log.log(DXFileSystem), promise = DXFileSystem.openFile([ {
extensions:[ "dxe" ]
} ]), promise.then($scope.handleOpenOfflineFileSuccess);
}, $scope.toggleSelectedExam = function(exam) {
return 1 !== $scope.exams.length ? ($scope.truncateDescription = !0, $scope.selectedExam = null != $scope.selectedExam && $scope.selectedExam.id === exam.id ? null :exam) :void 0;
}, $scope.getDescription = function(exam) {
return exam.about.length > 300 && $scope.truncateDescription ? exam.about.substr(0, 297) + "..." :exam.about;
}, $scope.toggleExamDescription = function() {
return $scope.truncateDescription = !$scope.truncateDescription;
}, $scope.confirmStartExam = function() {
var instance, modalScope;
return modalScope = $rootScope.$new(), modalScope.exam = $scope.selectedExam, instance = $modal.show({
$scope:modalScope,
templateUrl:"partials/modals/overview/confirm-start-exam.html",
controller:"ModalGenericConfirmController"
}), instance.result.then(function() {
return $scope.startExam($scope.selectedExam), instance;
});
}, $scope.startExam = function(exam) {
return DXLockdown.onLockdown(), DXLockdown.executeLockdown(), $location.path(Urls.get("exam", {
id:exam.id,
startOffline:exam._startOffline
}));
}, $scope.refreshExams();
});
}.call(this), angular.module("digiexam-preconditiontest").controller("preconditiontest-controller", function($scope, $window, DX_PLATFORM, ElectronFileSystem, DXPreConditionTest) {
"use strict";
function onAllTestsFinished(warnings, fatals) {
$window.console.log("All tests finished"), self.warningArray = warnings, self.fatalFailArray = fatals, 
self.hasWarnings() || self.hasFatalFails() ? self.state = self.hasFatalFails() ? "fatal" :"warning" :(self.state = "passed", 
self.continue());
}
var self = $scope;
self.warningArray = 0, self.fatalFailArray = 0, self.state = "running";
var ipc = $window.require("ipc");
self.continue = function() {
ipc.sendSync("testsPassed");
}, self.close = function() {
$window.close();
}, self.hasWarnings = function() {
return self.warningArray.length > 0;
}, self.hasFatalFails = function() {
return self.fatalFailArray.length > 0;
}, DXPreConditionTest.init(onAllTestsFinished);
}), function() {
angular.module("digiexamclient").controller("StatusbarController", function($window, $rootScope, $scope, $interval, $location, $modal, DXClient, Urls, User, SessionService, DX_PLATFORM) {
return $scope.DX_PLATFORM = DX_PLATFORM, $scope.user = new User(), $scope.showUser = !0, 
$scope.hasActiveExam = !1, $scope.time = new Date(), $interval(function() {
return $scope.updateClockTime();
}, 1e3), $scope.Urls = Urls, $rootScope.$on("Statusbar:SetUser", function(event, user) {
return $scope.user = user;
}), $rootScope.$on("Statusbar:OnExamStart", function() {
return $scope.showUser = !1, $scope.hasActiveExam = !0;
}), $rootScope.$on("Statusbar:OnExamEnd", function() {
return $scope.showUser = !0, $scope.hasActiveExam = !1;
}), $scope.version = $window.version, $scope.updateClockTime = function() {
return $scope.time = new Date();
}, $scope.hasUser = function() {
return SessionService.isAuthenticated();
}, $scope.confirmClose = function() {
var instance;
if (!$scope.hasActiveExam) return instance = $modal.show({
templateUrl:"partials/modals/system/confirm-close.html",
controller:"ModalGenericConfirmController"
}), instance.result.then(function() {
return DXClient.close();
});
}, "CHROME_APP" !== DX_PLATFORM || DXClient.isKiosk ? void 0 :($scope.showUser = !1, 
$modal.show({
templateUrl:"partials/modals/not-secure/not-secure.html",
controller:"ModalNotSecureController"
}));
});
}.call(this), function() {
angular.module("digiexamclient").controller("ToastController", function($rootScope, $scope, $timeout) {
var maxToasts, uniqueId;
return uniqueId = function() {
return Math.floor(1e4 * Math.random());
}, maxToasts = 5, $scope.toasts = [], $rootScope.$on("Toast:Notification", function(event, message) {
return $scope.addToast(message);
}), $scope.addToast = function(message) {
var t;
return t = {
id:uniqueId(),
message:message
}, $timeout(function() {
return $scope.dismissToast(t.id);
}, 1e4), $scope.toasts.push(t), $scope.toasts.length > maxToasts && $scope.dismissToast($scope.toasts[0].id), 
t.id;
}, $scope.dismissToast = function(tId) {
var i, j, len, ref, results, t;
for (ref = $scope.toasts, results = [], i = j = 0, len = ref.length; len > j; i = ++j) {
if (t = ref[i], t.id === tId) {
$scope.toasts.splice(i, 1);
break;
}
results.push(void 0);
}
return results;
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("UserEditController", function($scope, $location, Urls, SessionService) {
return $scope.user = angular.copy(SessionService.user);
});
}.call(this), function() {
angular.module("digiexamclient.validation", []).service("ValidationService", function() {
return {
isValidEmail:function(email) {
var emailExpression;
return "string" != typeof email || 0 === email.length ? !1 :(emailExpression = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, 
emailExpression.test(email));
}
};
});
}.call(this), function() {
angular.module("digiexamclient.session").service("SessionService", function(Session) {
return new Session();
});
}.call(this), function() {
angular.module("digiexamclient").controller("ModalOfflineTurnInController", function($scope, $modalInstance, DXFileSystem, AnswerQueue, AnswerState, SessionService) {
var queue;
return $scope.error = "", queue = new AnswerQueue($scope.exam.id, $scope.exam.userId, SessionService.user.code, SessionService.user.firstname, SessionService.user.lastname, SessionService.user.email), 
$scope.getQueue = function() {
return queue;
}, $scope.saveFile = function() {
var a, accepts, data, i, len, promise, ref;
for (queue.setState(AnswerState.FINAL), ref = $scope.answers, i = 0, len = ref.length; len > i; i++) a = ref[i], 
queue.add(a);
return data = JSON.stringify(queue.getDXR()), accepts = [ {
extensions:[ "dxr" ]
} ], promise = DXFileSystem.saveAs(data, $scope.exam.id + "-" + SessionService.user.code, "text/plain", accepts), 
promise.then(function() {
return $modalInstance.resolve();
}, function(error) {
return $scope.error = error;
});
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("ModalSuccessfulTurnInController", function($scope, $modalInstance, DXClient, DX_PLATFORM) {
return $scope.DX_PLATFORM = DX_PLATFORM, $scope.close = function() {
return DXClient.close($modalInstance);
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("ModalErrorStorageExceptionController", function($scope, $modalInstance, DXClient) {
return $scope.close = function() {
return DXClient.close();
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("ModalNotSecureController", function($scope, $modalInstance, DXClient) {
return $scope.showDebug = function() {
return $scope.$emit("Debug:Show");
}, $scope.exit = function() {
return DXClient.close();
};
});
}.call(this), function() {
angular.module("digiexamclient").controller("ModalGenericConfirmController", function($scope, $modalInstance) {
return $scope.yes = function() {
return $modalInstance.resolve(!0);
}, $scope.no = function() {
return $modalInstance.reject();
};
});
}.call(this);