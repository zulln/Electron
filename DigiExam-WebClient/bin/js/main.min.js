(function() {
  var client;

  client = angular.module("digiexamclient", ["ngRoute", "ngAnimate", "digiexamclient.platform", "digiexamclient.user", "digiexamclient.storage", "digiexamclient.preconditiontest", "digiexamclient.lockdown", "digiexamclient.session", "digiexamclient.exam", "digiexamclient.validation", "digiexamclient.jsobjcbridge", "dx.webui.blockEditor", "dx.webui.scroll", "dx.webui.sticky", "dx.webui.grading", "angular-minimodal"]);

  client.config([
    "$routeProvider", "$compileProvider", "Urls", function($routeProvider, $compileProvider, Urls) {
      $compileProvider.aHrefSanitizationWhitelist(/^\s*(data|https?|ftp|mailto|file|chrome-extension):/);
      $routeProvider.when(Urls.routes.login, {
        template: "<div id=\"login\" class=\"pv-900\"><div class=\"logo\"><img src=\"images/digiexam-logo.png\" alt=\"DigiExam\"></div><loader ng-show=\"isLoading\"><p class=\"text-center\">Initializing DigiExam</p></loader><div dx-container=\"narrow\" class=\"auth clearfix\" ng-show=\"showAuth\"><user-details user=\"user\"></user-details></div></div>",
        controller: "LoginController"
      });
      $routeProvider.when(Urls.routes.overview, {
        template: "<div layout layout-align=\"start start\" layout-padding id=\"overview\"><div flex=\"33\"><div class=\"sheet\"><h3 class=\"mb-300\">A. Find exams</h3><button class=\"btn btn-raised\" ng-click=\"refreshExams()\">Refresh exams</button></div><div class=\"sheet\"><h3 class=\"mb-300\">B. Open exam</h3><label for=\"overViewOpenExamCode\" class=\"display-block\">Enter exam ID</label><input type=\"number\" min=\"0\" inputmode=\"numeric\" pattern=\"[0-9]*\" ng-model=\"openExamCode\" id=\"overViewOpenExamCode\" ng-enter=\"getOpenExam()\"> <button class=\"btn btn-raised btn-green mt-300\" ng-click=\"getOpenExam()\" ng-disabled=\"!isValidOpenExamCode(openExamCode)\">Get open exam</button> <span class=\"color-text-error ml\" ng-show=\"openExamError.length > 0\">{{openExamError}}</span></div><div class=\"sheet\"><h3 class=\"mb-300\">C. Offline exam</h3><span ng-if=\"DX_PLATFORM !== 'IOS_WEBVIEW'\"><p class=\"mv-300\">Your mentor will provide you with this on a USB-stick.</p><button class=\"btn btn-raised\" ng-click=\"openOfflineFile()\">Load exam from device</button> <span class=\"color-text-error ml\" ng-show=\"openOfflineFileError.length > 0\">{{openOfflineFileError}}</span></span> <span ng-if=\"DX_PLATFORM === 'IOS_WEBVIEW'\"><p>Not supported on iOS devices</p></span></div><div class=\"sheet\"><h3 class=\"mb-300\">D. Start demo exam</h3><p class=\"mv-300\">You can start a demo exam here</p><button class=\"btn btn-raised\" ng-click=\"getDemoExam()\">Get demo exam</button> <span class=\"color-text-error ml\" ng-show=\"demoExamError.length > 0\">{{demoExamError}}</span></div></div><div flex=\"33\"><div class=\"sheet\"><loader ng-show=\"loadingExams\"><p class=\"text-center\">Loading exams...</p></loader><div class=\"alert alert-info\" ng-show=\"exams.length == 0 && !loadingExams\"><p>Could not find exams.</p></div><ul class=\"examlist\" ng-show=\"exams.length > 0 && !loadingExams\"><li ng-repeat=\"exam in exams\" ng-class=\"{selected: selectedExam.id == exam.id}\"><a href=\"\" ng-click=\"toggleSelectedExam(exam)\">{{exam.title}}</a></li></ul></div></div><div flex=\"33\" ng-show=\"exams.length > 0\"><div class=\"sheet\"><div class=\"alert alert-info\" ng-show=\"selectedExam == null && !loadingExams\"><p>No exam selected. Please select an exam.</p></div><div class=\"overview-exam-details\" ng-if=\"selectedExam != null\"><h2 class=\"text-normal\">{{selectedExam.title}}</h2><div class=\"overview-exam-details-description mb mt-300\"><p class=\"pre-wrap\">{{getDescription(selectedExam)}} <a href=\"\" ng-click=\"toggleExamDescription()\" ng-show=\"selectedExam.about.length > 299 && truncateDescription\"><span ng-show=\"truncateDescription\">more</span></a></p></div></div><div><button class=\"btn btn-green btn-raised floatRight\" ng-click=\"confirmStartExam(selectedExam.id)\" ng-show=\"selectedExam != null && !loadingExam\">Start exam</button><div style=\"clear: right\"></div></div></div></div></div>",
        controller: "OverviewController"
      });
      $routeProvider.when(Urls.routes.userEdit, {
        template: "<div dx-container=\"narrow\" class=\"pv-900\" id=\"user-edit\"><h1 class=\"mb-700\">Edit details</h1><user-details user=\"user\"></user-details></div>",
        controller: "UserEditController"
      });
      $routeProvider.when(Urls.routes.exam, {
        template: "<div dx-container=\"medium\" class=\"exam pv-900\" ng-class=\"{'rtl': exam.rightToLeft}\"><loader ng-show=\"isLoading\"><p class=\"text-center\">Loading exam</p></loader><div ng-show=\"!isLoading\"><div class=\"exam-title\"><h1 class=\"text-center\">{{exam.title}}</h1></div><div class=\"exam-about mv-700\"><p class=\"pre-wrap\">{{exam.about}}</p></div><div class=\"question-wrapper\"><div class=\"question sheet\" ng-repeat=\"q in exam.questions\"><h3 class=\"question-title mb\">{{q.title}}</h3><p class=\"pre-wrap mv\">{{q.about}}</p><div class=\"question-images mv\"><dx-image-list images=\"q.images\" track=\"q.id\"></dx-image-list></div><p ng-if=\"exam.gradingType == GradingTypeEnum.SCORE\" class=\"text-bold mv\">Max score: {{q.maxScore}}</p><dx-block-editor-manager ng-if=\"q.type == QuestionType.TEXT_QUESTION\" question=\"q\" answer=\"answers[$index]\" on-change=\"onAnswerChange\"></dx-block-editor-manager><ul class=\"single-choice-question unstyledList spacedList\" ng-if=\"q.type == QuestionType.SINGLE_CHOICE\"><li ng-repeat=\"a in q.alternatives\"><label for=\"a-{{a.$$hashKey}}\" class=\"radio\"><input type=\"radio\" id=\"a-{{a.$$hashKey}}\" ng-checked=\"answers[$parent.$index].hasThisAlternative(a.id)\" ng-click=\"answers[$parent.$index].setCorrectAlternative(a.id); onAnswerChange(answers[$parent.$index])\"> {{a.title}}</label></li></ul><ul class=\"multi-choice-question unstyledList spacedList\" ng-if=\"q.type == QuestionType.MULTIPLE_CHOICE\"><li ng-repeat=\"a in q.alternatives\"><label for=\"a-{{a.$$hashKey}}\" class=\"checkbox\"><input type=\"checkbox\" id=\"a-{{a.$$hashKey}}\" ng-checked=\"answers[$parent.$index].hasThisAlternative(a.id)\" ng-click=\"answers[$parent.$index].toggleCorrectAlternative(a.id); onAnswerChange(answers[$parent.$index])\"> {{a.title}}</label></li></ul></div></div><div class=\"exam-control clearfix\" ng-show=\"showTurnInButton\"><button class=\"btn btn-green btn-raised exam-turn-in-btn floatRight\" ng-click=\"confirmTurnIn()\">Hand in exam and exit</button></div><div class=\"demoExamWatermark\" ng-if=\"exam.isDemo\">demo exam</div></div></div>",
        controller: "ExamController"
      });
      return $routeProvider.otherwise({
        redirectTo: "/"
      });
    }
  ]);

}).call(this);

(function() {
  angular.module("digiexamclient.exam", ["dx.webui.answer", "dx.webui.question", "dx.webui.blockEditor"]);

}).call(this);

angular.module("digiexamclient.jsobjcbridge", [
	"digiexamclient.platform"
]);

angular.module("digiexamclient.platform", []);

(function() {
  angular.module("digiexamclient.session", ["digiexamclient.storage"]);

}).call(this);

angular.module("digiexamclient.storage", [
	"digiexamclient.storage.filesystem",
	"digiexamclient.storage.localstorage"
]);

(function() {
  angular.module("digiexamclient.user", []);

}).call(this);

angular.module("digiexamclient.storage.filesystem", []);

angular.module("digiexamclient.storage.localstorage", []);

angular.module("digiexam-preconditiontest", [
	"digiexamclient.platform",
	"digiexamclient.storage",
	"digiexamclient.jsobjcbridge",		//See if we can solve this with an optional inject
	"digiexamclient.preconditiontest"
]);

angular.module("digiexamclient").factory("DXClient", function($window, $route, $rootScope, $location, DXLocalStorage, JsObjcBridge, DX_PLATFORM) {
	"use strict";

	var DXClient = {};
	// $window.isKiosk is set in background.js
	DXClient.isKiosk = $window.isKiosk;

	// Shorthand for closing the application
	DXClient.close = function(modalInstance) {
		if (DX_PLATFORM === "ELECTRON_APP") {
			$window.close();
		}
		else if (DX_PLATFORM === "CHROME_APP") {
			$window.chrome.app.window.current().close();
		}
		else if (DX_PLATFORM === "BROWSER") {
			$location.path("/");
			modalInstance.resolve();
		}
		else if (DX_PLATFORM === "IOS_WEBVIEW") {
			JsObjcBridge.unlockFromGuidedAcess(
			function() {
				$location.path("/");
				modalInstance.resolve();
			},
			function() {
				$location.path("/");
				$rootScope.$emit("Toast:Notification", "Could not unlock from guided access");
				modalInstance.reject();
			});
		}
		else {
			return angular.noop();
		}
	};

	return DXClient;
});

(function() {
  angular.module("digiexamclient.exam").factory("Alternative", function() {
    var Alternative;
    Alternative = function(data) {
      angular.extend(this, {
        id: 0,
        title: ""
      });
      if (data != null) {
        if ((data.correct != null) && !data.right) {
          data.right = data.correct;
        }
        return angular.extend(this, data);
      }
    };
    return Alternative;
  });

}).call(this);

(function() {
  angular.module("digiexamclient.exam").factory("Answer", function($q, QuestionType, DXLocalStorage, AnswerBlock) {
    var Answer, multiChoiceQuestionTemplate, singleChoiceQuestionTemplate, textualQuestionTemplate;
    textualQuestionTemplate = {
      data: "",
      answerBlocks: []
    };
    singleChoiceQuestionTemplate = {
      data: -1,
      setCorrectAlternative: function(aId) {
        return this.data = aId;
      },
      hasThisAlternative: function(aId) {
        return this.data === aId;
      }
    };
    multiChoiceQuestionTemplate = {
      data: [],
      toggleCorrectAlternative: function(aId) {
        if (!this.hasThisAlternative(aId)) {
          return this.data.push(aId);
        } else {
          return this.data.splice(this.data.indexOf(aId), 1);
        }
      },
      hasThisAlternative: function(aId) {
        return this.data.indexOf(aId) > -1;
      }
    };
    Answer = function(type, questionId, answerData) {
      var blockData, existingBlocks, i, instantiatedBlocks, k, len, unsupported, v;
      if (answerData == null) {
        answerData = {};
      }
      angular.extend(this, {
        _id: Math.uuid(),
        questionId: questionId,
        data: "",
        type: type,
        hasAttachmentsChanged: false,
        attachments: []
      });
      unsupported = true;
      for (k in QuestionType) {
        v = QuestionType[k];
        if (QuestionType[k] === type) {
          unsupported = false;
        }
      }
      if (unsupported) {
        throw Error("Unsupported question type on answer " + type);
      }
      if (type === QuestionType.TEXT_QUESTION) {
        angular.extend(this, angular.copy(textualQuestionTemplate));
      } else if (type === QuestionType.SINGLE_CHOICE) {
        angular.extend(this, angular.copy(singleChoiceQuestionTemplate));
      } else {
        angular.extend(this, angular.copy(multiChoiceQuestionTemplate));
      }
      if (type === QuestionType.TEXT_QUESTION) {
        existingBlocks = answerData.answerBlocks;
        instantiatedBlocks = [];
        if (existingBlocks && existingBlocks.length) {
          for (i = 0, len = existingBlocks.length; i < len; i++) {
            blockData = existingBlocks[i];
            instantiatedBlocks.push(new AnswerBlock(blockData));
          }
        } else {
          instantiatedBlocks.push(new AnswerBlock);
        }
        answerData.answerBlocks = instantiatedBlocks;
        answerData.data = "";
      }
      return angular.extend(this, answerData);
    };
    Answer.getFromStorageByExamId = function(examId, studentCode) {
      var answers, key, promise;
      answers = [];
      key = "u-" + studentCode + "-exam-" + examId + "-answers";
      promise = DXLocalStorage.get(key);
      return promise.then(function(data) {
        var a, i, len, storedAnswers;
        storedAnswers = data[key];
        if ((storedAnswers != null) && storedAnswers.length > 0) {
          for (i = 0, len = storedAnswers.length; i < len; i++) {
            a = storedAnswers[i];
            answers.push(new Answer(a.type, a.questionId, a));
          }
        }
        return answers;
      });
    };
    return Answer;
  });

}).call(this);

(function() {
  angular.module("digiexamclient.exam").factory("AnswerQueue", function($q, $http, $interval) {
    var AnswerQueue;
    AnswerQueue = function(examId, studentId, studentCode, firstName, lastName, email) {
      var intervalPromise;
      intervalPromise = null;
      return angular.extend(this, {
        examId: examId,
        studentId: studentId,
        studentCode: studentCode,
        firstName: firstName,
        lastName: lastName,
        email: email,
        state: 1,
        answers: [],
        _isRunning: false,
        _sendInterval: 1000 * 30,
        add: function(a) {
          var storedA;
          storedA = this.get(a._id);
          if (storedA != null) {
            return angular.extend(storedA, a);
          } else {
            return this.answers.push(angular.copy(a));
          }
        },
        get: function(id) {
          var a, j, len, ref;
          ref = this.answers;
          for (j = 0, len = ref.length; j < len; j++) {
            a = ref[j];
            if (a._id === id) {
              return a;
            }
          }
        },
        getDXR: function() {
          var a, data, j, len, ref;
          data = {
            examId: this.examId,
            studentId: this.studentId,
            studentCode: this.studentCode,
            firstName: this.firstName,
            lastName: this.lastName,
            email: this.email,
            state: this.state,
            answers: angular.copy(this.answers)
          };
          ref = data.answers;
          for (j = 0, len = ref.length; j < len; j++) {
            a = ref[j];
            delete a._id;
          }
          return data;
        },
        send: function() {
          var data;
          if (this.answers.length === 0) {
            return;
          }
          data = JSON.stringify(this.getDXR());
          this.clear();
          return $http({
            method: "post",
            url: _apiBaseUrl + "api_answer.go",
            data: $.param({
              report: data
            }),
            headers: {
              "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
            }
          }).then(function(response) {
            if (!response.data || (response.data.error && response.data.code)) {
              return $q.reject(response);
            }
          });
        },
        clear: function() {
          return this.answers = [];
        },
        setInterval: function(i) {
          this._sendInterval = i;
          this.stop();
          return this.start();
        },
        setState: function(state) {
          return this.state = state;
        },
        setStudentId: function(id) {
          return this.studentId = id;
        },
        start: function() {
          var _self;
          if (this._isRunning) {
            return false;
          }
          _self = this;
          this._isRunning = true;
          intervalPromise = $interval(function() {
            return _self.send();
          }, this._sendInterval);
          return true;
        },
        stop: function() {
          $interval.cancel(intervalPromise);
          return this._isRunning = false;
        }
      });
    };
    return AnswerQueue;
  });

}).call(this);

(function() {
  angular.module("digiexamclient.exam").factory("ExamInfo", function($q, $http, Question, Answer, DXLocalStorage) {
    var ExamInfo;
    ExamInfo = function(data) {
      var i, len, q, questions, ref;
      angular.extend(this, {
        about: "",
        ancestor: 0,
        anonymous: false,
        at: new Date(),
        blank: false,
        courseId: 0,
        defaultFontSize: 0,
        encryptionKey: "",
        examStatus: 0,
        examType: 0,
        gradeId: 0,
        groupId: 0,
        id: 0,
        images: [],
        isArchived: false,
        isDemo: false,
        isPlanned: false,
        isQuestionsLoaded: false,
        lastOfflineDownload: new Date(),
        limit: 0,
        lockedFontSize: false,
        needPassword: false,
        needVersion: 0,
        open: false,
        organizationId: 0,
        parent: 0,
        published: false,
        questions: [],
        start: new Date(),
        stop: new Date(),
        studentId: null,
        subject: "",
        title: "",
        userId: 0,
        rightToLeft: false,
        _startOffline: false,
        extractAnswers: function() {
          var answers, i, len, q, ref;
          answers = [];
          ref = this.questions;
          for (i = 0, len = ref.length; i < len; i++) {
            q = ref[i];
            answers.push(new Answer(q.type, q.id, q.answer));
            delete q.answer;
          }
          return answers;
        }
      });
      if (data != null) {
        data.at = new Date(data.at);
        data.lastOfflineDownload = new Date(data.lastOfflineDownload);
        data.start = new Date(data.start);
        data.stop = new Date(data.stop);
        if (isArray(data.questions) && data.questions.length > 0) {
          questions = [];
          ref = data.questions;
          for (i = 0, len = ref.length; i < len; i++) {
            q = ref[i];
            questions.push(new Question(q.type, q));
          }
          data.questions = questions;
        }
        return angular.extend(this, data);
      }
    };
    ExamInfo.getFromStorageById = function(id, studentCode) {
      var key, promise;
      key = "u-" + studentCode + "-exam-" + id;
      promise = DXLocalStorage.get(key);
      return promise.then(function(data) {
        var exam;
        exam = data[key];
        if (exam != null) {
          return new ExamInfo(exam);
        }
        return null;
      });
    };
    return ExamInfo;
  });

}).call(this);

(function() {
  angular.module("digiexamclient.exam").service("ExamInfoRepository", function($q, $http, ExamInfo) {
    var ExamInfoRepository, encode;
    encode = encodeURIComponent;
    ExamInfoRepository = {};
    ExamInfoRepository.getByStudentCode = function(code) {
      code = encode(code);
      return $http.get(_apiBaseUrl + "api_exams.go?studentId=" + code).then(function(response) {
        var e, exams, i, len, ref;
        if (response.status !== 200 || (response.data == null) || !!response.data.error || !!response.data.code) {
          return $q.reject(response);
        } else {
          exams = [];
          ref = response.data.examList;
          for (i = 0, len = ref.length; i < len; i++) {
            e = ref[i];
            exams.push(new ExamInfo(e));
          }
          return exams;
        }
      });
    };
    ExamInfoRepository.getByOpenExamCode = function(code) {
      code = encode(code);
      return $http.get(_apiBaseUrl + "api_exam_info.go?exam=" + code).then(function(response) {
        if (response.status !== 200 || (response.data == null) || !!response.data.error || !!response.data.code) {
          return $q.reject(response);
        }
        return new ExamInfo(response.data.examInfo);
      });
    };
    ExamInfoRepository.get = function(examId, studentCode, firstname, lastname, email) {
      examId = encode(examId);
      studentCode = encode(studentCode);
      firstname = encode(firstname);
      lastname = encode(lastname);
      email = encode(email);
      return $http.get(_apiBaseUrl + "api_exam.go?exam=" + examId + "&studentCode=" + studentCode + "&firstName=" + firstname + "&lastName=" + lastname + "&email=" + email).then(function(response) {
        if (response.status !== 200 || (response.data == null) || !!response.data.error || !!response.data.code) {
          return $q.reject(response);
        }
        return new ExamInfo(response.data);
      });
    };
    ExamInfoRepository.offlineGet = function(examId, studentCode, firstname, lastname, email) {
      examId = encode(examId);
      studentCode = encode(studentCode);
      firstname = encode(firstname);
      lastname = encode(lastname);
      email = encode(email);
      return $http.get(_apiBaseUrl + "api_offline_start.go?exam=" + examId + "&studentCode=" + studentCode + "&firstName=" + firstname + "&lastName=" + lastname + "&email=" + email).then(function(response) {
        var id;
        if (response.status !== 200 || isObject(response) && isObject(response.data)) {
          return $q.reject(response);
        }
        id = parseInt(response.data, 10);
        if (isNaN(id)) {
          return $q.reject(response);
        }
        return id;
      });
    };
    return ExamInfoRepository;
  });

}).call(this);

(function() {
  angular.module("digiexamclient.exam").factory("Question", function(Answer, QuestionType, CapSettingEnum, Alternative) {
    var Question, choiceQuestionTemplate, textualQuestionTemplate;
    textualQuestionTemplate = {
      capSetting: CapSettingEnum.NONE,
      capValue: null
    };
    choiceQuestionTemplate = {
      alternatives: []
    };
    Question = function(type, data) {
      var a, alternatives, i, k, len, ref, unsupported, v;
      angular.extend(this, {
        id: 0,
        type: type,
        title: "",
        about: "",
        images: [],
        maxScore: null
      });
      unsupported = true;
      for (k in QuestionType) {
        v = QuestionType[k];
        if (QuestionType[k] === type) {
          unsupported = false;
        }
      }
      if (unsupported) {
        throw Error("Unsupported question type on question " + type);
      }
      if (type === QuestionType.TEXT_QUESTION) {
        angular.extend(this, angular.copy(textualQuestionTemplate));
      } else {
        angular.extend(this, angular.copy(choiceQuestionTemplate));
      }
      if (data != null) {
        if (type === QuestionType.SINGLE_CHOICE || type === QuestionType.MULTIPLE_CHOICE) {
          alternatives = [];
          data.alternatives = data.alternatives || [];
          ref = data.alternatives;
          for (i = 0, len = ref.length; i < len; i++) {
            a = ref[i];
            alternatives.push(new Alternative(a));
          }
          data.alternatives = alternatives;
        }
        angular.extend(this, data);
      }
    };
    return Question;
  });

}).call(this);

angular.module("digiexamclient.jsobjcbridge").factory("JsObjcBridge", function(DX_PLATFORM) {
	"use strict";

	var connectWebViewJavascriptBridge = function(callback) {
		if (window.WebViewJavascriptBridge) {
			callback(WebViewJavascriptBridge);
		} else {
			document.addEventListener("WebViewJavascriptBridgeReady", function() {
				callback(WebViewJavascriptBridge);
			}, false);
		}
	};

	var sendToObjc = function(message, callback) {
		// Don't try to send js to obj-c messages if we're not in on iOS
		if (DX_PLATFORM !== "IOS_WEBVIEW") {
			return;
		}

		connectWebViewJavascriptBridge(function(bridge) {
			if (typeof callback === "undefined") {
				bridge.send(message);
			} else {
				bridge.send(message, callback);
			}
		});
	};

	var sendCommand = function(command, data, callback) {
		var message = {
			"command": command
		};
		if (data) {
			message.data = data;
		}
		sendToObjc(message, callback);
	};

	var setGuidedAccessLock = function(lock, successCallback, failCallback) {
		var command = lock ? "lock_to_guided_access" : "unlock_from_guided_access";
		sendCommand(command, null, function(didSucceed) {
			if (didSucceed === "true") {
				if (typeof successCallback === "function") {
					successCallback.call();
				}
			} else {
				if (typeof failCallback === "function") {
					failCallback.call();
				}
			}
		});
	};

	var lockToGuidedAccess = function(successCallback, failCallback) {
		setGuidedAccessLock(true, successCallback, failCallback);
	};

	var unlockFromGuidedAcess = function(successCallback, failCallback) {
		setGuidedAccessLock(false, successCallback, failCallback);
	};

	var init = function() {
		// Init bridge to be listen on messages / callbacks from obj-c
		connectWebViewJavascriptBridge(function(bridge) {
			bridge.init();
		});
	};

	init();

	return {
		sendToObjc: sendToObjc,
		sendCommand: sendCommand,
		lockToGuidedAccess: lockToGuidedAccess,
		unlockFromGuidedAcess: unlockFromGuidedAcess
	};
});

angular.module("digiexamclient.lockdown", [])
.factory("ElectronLockdown", function($q, $window){
	"use strict";

	var modulePath = "./platforms/electron/node/build/Release/dxlockdown";
	var nativeModule = $window.require(modulePath);

	var prepareLockdown = function() {
		$window.console.log("prepareLockdown");
	};

	var executeLockdown = function() {
		$window.console.log("Lockdown message: " + nativeModule.getName());
		nativeModule.executeLockdown();
	};

	var onLockdown = function () {
		$window.console.log("Lockdown onLockdown");
		$window.console.log(nativeModule.onLockdown());
	};

	var tearDown = function() {
		//TO DO
		$window.console.log("Lockdown teardown");
		nativeModule.teardownLockdown();
	};

	return {
		prepareLockdown: prepareLockdown,
		executeLockdown: executeLockdown,
		onLockdown: onLockdown,
		tearDown: tearDown
	};
});

angular.module("digiexamclient.lockdown")
.service("DXLockdown", function($window, ElectronLockdown, DX_PLATFORM) {
//.service("DXLockdown", function($window, BrowserLockdown, ChromeAppLockdown, IOSLockdown, ElectronLockdown, DX_PLATFORM) {
	"use strict";

	$window.console.log("DXLockdown");

	var PLATFORM_LOCKDOWN = {
		"ELECTRON_APP": ElectronLockdown/*,
		"BROWSER": BrowserLockdown,
		"CHROME_APP": ChromeAppLockdown,
		"IOS_WEBVIEW": IOSLockdown*/
	};

	return PLATFORM_LOCKDOWN[DX_PLATFORM];
});

angular.module("digiexamclient.preconditiontest", [])
.factory("ElectronPreconditionTest", function($q, $window, $http, DXFileSystem){
	"use strict";

	var fs = $window.require("fs");
	var modulePath = "./platforms/electron/node/build/Release/dxpreconditiontests";
	var nativeModule = $window.require(modulePath);

	/*
		When AppDataFolder is created, all permissions are set to 16822 on Windows
		including all subfolders (exams & logs)
		Permissions on Mac are set to 16832 for appDataFolder and 16877 on subfolders
	*/

	var appDataFolderPermissionRequired = (function() {
		if($window.navigator.platform === "Win32") { return 16822; }
		else {return 16832; }
	})();

	var subFolderPermissionRequired = (function() {
		if($window.navigator.platform === "Win32") { return 16822; }
		else {return 16877; }
	})();

	var dirs = [];
	var fatalFailArray = [];
	var folderPermissions = [
		appDataFolderPermissionRequired,
		subFolderPermissionRequired,
		subFolderPermissionRequired
	];
	var statsReceived = [];
	var warningArray = [];

	var finishedTests = 0;
	var testCount;
	var onAllTestsDoneCallback = null;

	var onTestDone = function(result) {
		if (!result.isSuccess) {
			if (result.isFailFatal) {
				fatalFailArray.push(result);
			}
			else {
				warningArray.push(result);
			}
		}
		if (finishedTests++ === testCount) // && onAllTestsDoneCallback != null) {
		{
			onAllTestsDoneCallback(warningArray, fatalFailArray);
		}
	};

	var internetAccessTest = function(callback) {
		var apiBaseUrl = "https://digiexam-release.appspot.com/app#/";
		$http.get(apiBaseUrl).then(function(response) {
			var result = {
				failTitle: "Internet access test",
				failMessage: "No internet connection.",
				isFailFatal: false,
				isSuccess: false
			};

			if (response.status === 200) {
				result.isSuccess = true;
			}
			else {
				result.isSuccess = false;
			}
			callback(result);
		});
	};

	var createOnStatDoneCallback = function(dir, callback) {

		var result = {
			failTitle: "Write permission error.",
			failMessage: "DigiExam does not have write permission in the cache directory on the file system.\
							Make sure that you have sufficient privileges to the DigiExam cache directory, \
							otherwise please contact DigiExam for further troubleshooting",
			isFailFatal: true,
			isSuccess: false
		};

		return function(error, stats) {
			statsReceived.push(stats);

			if (statsReceived.length === dirs.length) {
				for (var i = 0; i < statsReceived.length; i++) {
					if (statsReceived[i].mode !== folderPermissions[i]){
						result.isSuccess = false;
						break;
					}
					else {
						result.isSuccess = true;
					}
				}
				callback(result);
			}
		};
	};

	var writePermissionTest = function() {
		if(DXFileSystem.getExamDir() === null) {
			DXFileSystem.makeDir();
		}
		if(DXFileSystem.getLogDir() === null) {
			DXFileSystem.makeLogDir();
		}

		dirs = [
			DXFileSystem.getAppDataDir(),
			DXFileSystem.getExamDir(),
			DXFileSystem.getLogDir()
		];

		for (var i = 0; i < dirs.length; i++) {
			var onStatDoneCallback = createOnStatDoneCallback(dirs[i], onTestDone);
			fs.stat(dirs[i], onStatDoneCallback);
		}
	};

	var init = function(callback) {
		onAllTestsDoneCallback = callback;
		testCount = nativeModule.run(onTestDone) + 1;
		$window.console.log("Testcount: " + testCount);
		internetAccessTest(onTestDone);
		writePermissionTest();
	};

	return {
		"init": init
	};
});

angular.module("digiexamclient.preconditiontest")
.service("DXPreConditionTest", function($window, ElectronPreconditionTest, DX_PLATFORM) {
//.service("DXLockdown", function($window, BrowserLockdown, ChromeAppLockdown, IOSLockdown, ElectronLockdown, DX_PLATFORM) {
	"use strict";

	var PLATFORM_PRECONDITIONTEST = {
		"ELECTRON_APP": ElectronPreconditionTest/*,
		"BROWSER": BrowserLockdown,
		"CHROME_APP": ChromeAppLockdown,
		"IOS_WEBVIEW": IOSLockdown*/
	};

	return PLATFORM_PRECONDITIONTEST[DX_PLATFORM];
});

angular.module("digiexamclient.platform")
.config(function($provide) {
	"use strict";

	var SYSTEMS = [
		{
			"name": "ELECTRON_APP",
			"isCurrentSystem": function() {
				return !window.isElectron;
			}
		},
		{
			"name": "CHROME_APP",
			"isCurrentSystem": function() {
				return !!(window.chrome && window.chrome.runtime && window.chrome.runtime.id);
			}
		},
		{
			"name": "IOS_WEBVIEW",
			"isCurrentSystem": function() {
				// http://stackoverflow.com/a/10170885/327706
				return /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
			}
		},
		{
			"name": "BROWSER",
			"isCurrentSystem": function() {
				return true;
			}
		}
	];

	var getCurrentSystemName = function() {
		var systemName = "UNKNOWN";

		for (var i = 0; i < SYSTEMS.length; i++) {
			var system = SYSTEMS[i];
			if (system.isCurrentSystem.call()) {
				systemName = system.name;
				break;
			}
		}

		return systemName;
	};

	var systemName = getCurrentSystemName();
	$provide.constant("DX_PLATFORM", systemName);
});

angular.module("digiexamclient.platform")
.run(function() {
	"use strict";
});

(function() {
  angular.module("digiexamclient.session").factory("Session", function($rootScope, User, DXLocalStorage) {
    var Session;
    Session = function(data) {
      return angular.extend(this, {
        user: null,
        setUser: function(user) {
          if (user != null) {
            this.user = user;
            DXLocalStorage.set("user", user);
          } else {
            this.user = null;
            DXLocalStorage.remove("user");
          }
          return $rootScope.$broadcast("Session:User", this.user);
        },
        isAuthenticated: function() {
          return this.user !== null;
        },
        restore: function() {
          var _self, promise;
          _self = this;
          promise = DXLocalStorage.get("user");
          return promise.then(function(data) {
            var user;
            user = new User(data.user);
            if (!user.isValid()) {
              return null;
            }
            _self.user = user;
            return user;
          });
        }
      });
    };
    return Session;
  });

}).call(this);

angular.module("digiexamclient.storage")
.factory("ExamStorage", function() {
	"use strict";

	var saveAnswers = function() {
		// TODO
	};

	var loadAnswers = function() {
		// TODO
	};

	return {
		saveAnswers: saveAnswers,
		loadAnswers: loadAnswers
	};
});

(function() {
  angular.module("digiexamclient.user").factory("User", function(ValidationService) {
    var User, blobStoreBaseUrl, gravatarBaseUrl;
    gravatarBaseUrl = "https://www.gravatar.com/avatar/%h?s=64&d=mm";
    blobStoreBaseUrl = "blob/get/%h";
    User = function(data) {
      angular.extend(this, {
        email: "",
        firstname: "",
        lastname: "",
        code: "",
        image: "",
        name: function() {
          return this.firstname + " " + this.lastname;
        },
        isValidFirstname: function() {
          return this.firstname.length > 0;
        },
        isValidLastname: function() {
          return this.lastname.length > 0;
        },
        isValidCode: function() {
          return this.code.length > 0;
        },
        isValidEmail: function() {
          return ValidationService.isValidEmail(this.email);
        },
        isValid: function() {
          return this.isValidEmail() && this.isValidFirstname() && this.isValidLastname() && this.isValidCode();
        },
        getProfileImage: function() {
          var base, h;
          base = gravatarBaseUrl;
          if ((this.image != null) && this.image.length > 0) {
            base = blobStoreBaseUrl;
            h = this.image;
          } else if (this.email.length > 0 && this.email[0].length > 0) {
            h = md5(this.email.toLowerCase());
          } else {
            return null;
          }
          return base.replace("%h", h);
        }
      });
      if (data != null) {
        angular.extend(this, data);
      }
    };
    return User;
  });

}).call(this);

angular.module("digiexamclient.storage.filesystem")
.factory("BrowserFileSystem", function($window, $q, $timeout) {
	"use strict";

	var mockedPromise = function(resolveData) {
		var deferred = $q.defer();
		$timeout(function(){
			deferred.resolve(resolveData);
		}, 0);
		return deferred.promise;
	};

	var requestFileSystem = function(/*quota*/) {
		/*
		 * Requests a sandboxed file system where data should be stored.
		 *
		 * `quota`: The storage space—in bytes
		 */
		return mockedPromise();
	};

	var listDirectory = function(/*quota, path*/) {
		/*
		 * Looks up a directory.
		 *
		 * `quota`: The storage space—in bytes
		 * `path`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked up.
		 */
		return mockedPromise();
	};

	var makeDir = function(/*quota, path, name*/) {
		/*
		 * Creates a directory.
		 *
		 * `quota`: The storage space—in bytes
		 * `path`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked created. It is an
		 *         error to attempt to create a file whose immediate parent does
		 *         not yet exist.
		 * `name`: Name to be appended to path
		 */
		return mockedPromise();
	};

	var openFile = function(/*accepts*/) {
		/*
		 * Ask the user to choose a file or directory.
		 *
		 * `accepts`: The optional list of accept options for this file opener.
		 *            Each option will be presented as a unique group to the
		 *            end-user.
		 */
		$window.alert("Browser file system");
		return mockedPromise();
	};

	var readFile = function(/*quota, path, name*/) {
		/*
		 * Looks up an existing file.
		 *
		 * `quota`: The storage space—in bytes
		 * `path`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked up.
		 * `name`: Name of file to be appended to path
		 */
		return mockedPromise();
	};

	var requestQuota = function(/*bytes*/) {
		/*
		 * Ask for more storage. The browser presents an info bar to prompt user to
		 * grant or deny the app the permission to have more storage.
		 *
		 * `bytes`: The amount of bytes you want in your storage quota.
		 */
		return mockedPromise();
	};

	var saveAs = function(/*data, name, mime, accepts*/) {
		/*
		 * Prompts the user to open an existing file or a new file and returns a
		 * writable FileEntry on success.
		 *
		 * `data`: The blob to write
		 * `name`: The suggested file name that will be presented to the user as
		 *         the default name to read or write. This is optional.
		 * `mime`: The mime type as a string.
		 * `accepts`: The optional list of accept options for this file opener.
		 *            Each option will be presented as a unique group to the
		 *            end-user.
		 */
		return mockedPromise();
	};

	var writeFile = function(/*quota, path, filename, data, mime*/) {
		/*
		 * Creates up a file without prompting the user.
		 *
		 * `quota`: The storage space—in bytes
		 * `path`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked up.
		 * `filename`: Name of file to be appended to path
		 * `data`: The blob to write
		 * `mime`: The mime type as a string.
		 */
		return mockedPromise();
	};

	return {
		"requestFileSystem": requestFileSystem,
		"listDirectory": listDirectory,
		"makeDir": makeDir,
		"openFile": openFile,
		"readFile": readFile,
		"requestQuota": requestQuota,
		"saveAs": saveAs,
		"writeFile": writeFile
	};
});

(function() {
  angular.module("digiexamclient.storage.filesystem").factory("ChromeAppFileSystem", function($rootScope, $q, $window, DX_PLATFORM) {
    var ChromeAppFileSystem, getPath, requestFileSystem;
    requestFileSystem = $window.requestFileSystem ? $window.requestFileSystem : $window.webkitRequestFileSystem;
    ChromeAppFileSystem = {};
    ChromeAppFileSystem.openFile = function(accepts) {
      var deferred;
      deferred = $q.defer();
      $window.chrome.fileSystem.chooseEntry({
        type: "openFile",
        accepts: accepts
      }, function(readOnlyEntry) {
        return readOnlyEntry.file(function(file) {
          var reader;
          reader = new FileReader();
          reader.onerror = function() {
            deferred.reject("Could not open file.");
            return $rootScope.$apply();
          };
          reader.onloadend = function(e) {
            deferred.resolve(e.target.result);
            return $rootScope.$apply();
          };
          return reader.readAsText(file);
        });
      });
      return deferred.promise;
    };
    ChromeAppFileSystem.saveAs = function(data, name, mime, accepts) {
      var deferred;
      deferred = $q.defer();
      $window.chrome.fileSystem.chooseEntry({
        type: "saveFile",
        suggestedName: name,
        accepts: accepts
      }, function(writableFileEntry) {
        return writableFileEntry.createWriter(function(writer) {

          /*
          				 *
          				 *	Seems to be a bug when overwriting files. It seems to prepend the data to the file, this fixes it.
          				 *	http://stackoverflow.com/a/21909322/384868
          				 *
           */
          writer.onwrite = function() {
            writer.onwrite = null;
            return writer.truncate(writer.position);
          };
          writer.onerror = function() {
            return deferred.reject("Could not write to file.");
          };
          writer.onwriteend = function(e) {
            return deferred.resolve(e);
          };
          return writer.write(new Blob([data]), {
            type: mime
          });
        });
      });
      return deferred.promise;
    };
    ChromeAppFileSystem.requestQuota = function(bytes) {
      var deferred, storageInfo;
      deferred = $q.defer();
      storageInfo = $window.storageInfo != null ? $window.storageInfo : $window.webkitStorageInfo;
      storageInfo.requestQuota($window.PERSISTENT, bytes, function(quotaGranted) {
        return deferred.resolve(quotaGranted);
      }, function() {
        return deferred.reject();
      });
      return deferred.promise;
    };
    ChromeAppFileSystem.requestFileSystem = function(quota) {
      var deferred;
      deferred = $q.defer();
      requestFileSystem($window.PERSISTENT, quota, function(fs) {
        return deferred.resolve(fs);
      }, function(ex) {
        return deferred.reject(ex);
      });
      return deferred.promise;
    };
    getPath = function(path) {
      path = path[0] === "/" ? path.substr(1, path.length) : path;
      return path = path[path.length] !== "/" ? path += "/" : path;
    };
    ChromeAppFileSystem.makeDir = function(quota, path, name) {
      var deferred, fsPromise;
      deferred = $q.defer();
      path = getPath(path);
      fsPromise = ChromeAppFileSystem.requestFileSystem();
      fsPromise.then(function(fs) {
        return fs.root.getDirectory("" + path + name, {
          create: true
        }, function() {
          return deferred.resolve();
        }, function(ex) {
          return deferred.reject(ex);
        });
      }, function(ex) {});
      return deferred.promise;
    };
    ChromeAppFileSystem.readFile = function(quota, path, name) {
      var deferred, fsPromise;
      deferred = $q.defer();
      path = getPath(path);
      fsPromise = ChromeAppFileSystem.requestFileSystem();
      fsPromise.then(function(fs) {
        return fs.root.getFile("" + path + name, function(fileEntry) {
          return fileEntry.file(function(file) {
            var reader;
            reader = new FileReader();
            reader.onloadend = function(e) {
              return deferred.resolve(this.result);
            };
            reader.onerror = function(ex) {
              return deferred.reject(ex);
            };
            return reader.readAsText(file);
          }, function(ex) {
            return deferred.reject(ex);
          });
        }, function(ex) {
          return deferred.reject(ex);
        });
      }, function(ex) {
        return deferred.reject(ex);
      });
      return deferred.promise;
    };
    ChromeAppFileSystem.writeFile = function(quota, path, filename, data, mime) {
      var deferred, fsPromise;
      deferred = $q.defer();
      path = getPath(path);
      fsPromise = ChromeAppFileSystem.requestFileSystem();
      fsPromise.then(function(fs) {
        return fs.root.getFile("" + path + filename + ".dxr", {
          create: true,
          exclusive: true
        }, function(fileEntry) {
          return fileEntry.createWriter(function(writer) {
            writer.onwriteend = function() {
              return deferred.resolve();
            };
            writer.onerror = function(ex) {
              return deferred.reject(ex);
            };
            return writer.write(new Blob([data], {
              type: mime
            }));
          }, function(ex) {
            return deferred.reject(ex);
          });
        }, function(ex) {
          return deferred.reject(ex);
        });
      }, function(ex) {
        return deferred.reject(ex);
      });
      return deferred.promise;
    };
    ChromeAppFileSystem.listDirectory = function(quota, path) {
      var deferred, onError, onGetDirectorySuccess, onRequestFileSystemSuccess;
      deferred = $q.defer();
      onError = function(ex) {
        return deferred.reject(ex);
      };
      onRequestFileSystemSuccess = function(fs) {
        return fs.root.getDirectory(path, {
          create: false
        }, onGetDirectorySuccess, onError);
      };
      onGetDirectorySuccess = function(examDir) {
        var files, onFinishedReading, readEntries, reader;
        reader = examDir.createReader();
        files = [];
        onFinishedReading = function() {
          return deferred.resolve(files);
        };
        readEntries = function() {
          return reader.readEntries(function(results) {
            if (!results.length) {
              return onFinishedReading();
            } else {
              files = files.concat(results);
              return readEntries();
            }
          });
        };
        return readEntries();
      };
      ChromeAppFileSystem.requestFileSystem(quota).then(onRequestFileSystemSuccess, onError);
      return deferred.promise;
    };
    return ChromeAppFileSystem;
  });

}).call(this);

angular.module("digiexamclient.storage.filesystem")
.factory("ElectronFileSystem", function($q, $timeout, $window) {
	"use strict";

	var printModuleName = function (){
		$window.console.log("Electron FS");
	};

	var appDataFolder = null;
	var delimiter = (function() {
		if($window.navigator.platform === "Win32") { return "\\"; }
		else {return "/"; }
	})();
	var examDir = null;
	var logDir = null;
	var fs = $window.require("fs");
	var ipc = $window.require("ipc");
	var path = $window.require("path");
	var remote = $window.require("remote");

	var mockedPromise = function(resolveData) {
		var deferred = $q.defer();
		$timeout(function(){
			deferred.resolve(resolveData);
		}, 0);
		return deferred.promise;
	};

	var requestFileSystem = function(/*quota*/) {
		/*
		 * Requests a sandboxed file system where data should be stored.
		 *
		 * `quota`: The storage space—in bytes
		 */
		appDataFolder = remote.require("app").getPath("userData");
		return appDataFolder;
	};

	var getAppDataDir = function() {
		return appDataFolder;
	};

	var getLogDir = function() {
		return logDir;
	};

	var getExamDir = function() {
		return examDir;
	};

	var makeLogDir = function(quota, filepath, name) {
		/*
		 * Creates a directory.
		 *     Create exam dir in rel path to Application Support for OSX, %AppData% for Win
		 * `quota`: The storage space—in bytes
		 * `filepath`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked created. It is an
		 *         error to attempt to create a file whose immediate parent does
		 *         not yet exist.
		 * `name`: Name to be appended to path
		 */
		name = "logs";
		var deferred = $q.defer();
		if(filepath === "" || filepath === undefined)
		{
			filepath = requestFileSystem();
		}
		filepath = path.join(filepath, name);
		fs.mkdir(filepath, function (err) {
			if (err) {
				if(fs.statSync(filepath).isDirectory())
				{ deferred.resolve("Path " + filepath + delimiter + name + " already exists"); }
				else
				{ deferred.reject("Could not create dir: " + filepath);	}
			}
			else {
				deferred.resolve("filepath " + filepath + " created");
			}
		});

		logDir = filepath;

		return deferred.promise;
	};

	var makeDir = function(quota, filepath, name) {
		/*
		 * Creates a directory.
		 *     Create exam dir in rel path to Application Support for OSX, %AppData% for Win
		 * `quota`: The storage space—in bytes
		 * `filepath`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked created. It is an
		 *         error to attempt to create a file whose immediate parent does
		 *         not yet exist.
		 * `name`: Name to be appended to path
		 */
		name = "exams";
		var deferred = $q.defer();
		if(filepath === "" || filepath === undefined)
		{
			filepath = requestFileSystem();
		}
		filepath = path.join(filepath, name);
		fs.mkdir(filepath, function (err) {
			if (err) {
				if(fs.statSync(filepath).isDirectory())
				{ deferred.resolve("Path " + filepath + delimiter + name + " already exists"); }
				else
				{ deferred.reject("Could not create dir: " + filepath);	}
			}
			else {
				deferred.resolve("filepath " + filepath + " created");
			}
		});

		examDir = filepath;

		return deferred.promise;
	};

	var listDirectory = function(quota, filepath) {
		/*
		 * Looks up a directory.
		 *
		 * `quota`: The storage space—in bytes
		 * `path`: Either an absolute path or a relative path from the
		 *         DirectoryE	ntry to the directory to be looked up.
		 *         Return array with all files in selected folder.
		 */
		fs.readdir(filepath, function(err, files) {
			if(!err) { return files; }
			else { return []; }
		});

	};

	var readFile = function(quota, filepath, name) {
		/*
		 * Looks up an existing file.
		 *
		 * `quota`: The storage space—in bytes
		 * `filepath`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked up.
		 * `name`: Name of file to be appended to path
		 */
		var deferred = $q.defer();
		var fileContent = "";

		fs.readFile(filepath + name, "utf8", function(err, data) {
			if(err) {
				deferred.reject(err);
			}
			else
			{
				fileContent = data;
				deferred.resolve(fileContent);
			}
		});
		return deferred.promise;
		//Lägga in reject ifall filen failar
	};


	var openFile = function(accepts) {
		/*
		 * Ask the user to choose a file or directory.
		 *
		 * `accepts`: The optional list of accept options for this file opener.
		 *            Each option will be presented as a unique group to the
		 *            end-user.
		 */

		var fileType = accepts[0].extensions[0];		//Extracting file type from accepts array
		var deferred = $q.defer();
		var fileDescriptor = ipc.sendSync("openFile", fileType);

		if(fileDescriptor === null) {deferred.reject(); }
		else {
			fileDescriptor = fileDescriptor[0];		//Turn array into string
			var filepath = fileDescriptor.substring(0, fileDescriptor.lastIndexOf(delimiter) + 1);
			var filename =	fileDescriptor.substring(fileDescriptor.lastIndexOf(delimiter) + 1, fileDescriptor.length);
			var readFilePromise = readFile(null, filepath, filename);

			readFilePromise.then(function(fileData){
				deferred.resolve(fileData);
			},
				function(reason) {
					deferred.reject(reason);
				}
			);
		}

		return deferred.promise;
	};

	var requestQuota = function(/*bytes*/) {
		/*
		 * Ask for more storage. The browser presents an info bar to prompt user to
		 * grant or deny the app the permission to have more storage.
		 *
		 * `bytes`: The amount of bytes you want in your storage quota.
		 */
		return mockedPromise();
	};

	//var writeFile = function(quota, filepath, filename, data, mime) {
	var writeFile = function(quota, filepath, filename, data) {
		/*
		 * Creates up a file without prompting the user.
		 *
		 * `quota`: The storage space—in bytes
		 * `filepath`: Either an absolute path or a relative filepath from the
		 *         DirectoryEntry to the directory to be looked up.
		 * `filename`: Name of file to be appended to path
		 * `data`: The blob to write
		 * `mime`: The mime type as a string.
		 */

		var deferred = $q.defer();

		if(!path.isAbsolute(filepath))
		{
			filepath = path.join(appDataFolder, filepath);
		}

		//fs.writeFile(filepath + filename, data, function(err, written, buffer)
		fs.writeFile(filepath + filename, data, function(err)
		{
			if(!err) {deferred.resolve(); }
			else {deferred.reject(err); }
		});

		return deferred.promise;
	};

	var saveAs = function(data, name, mime, accepts) {
		/*
		 * Prompts the user to open an existing file or a new file and returns a
		 * writable FileEntry on success.
		 *
		 * `data`: The blob to write
		 * `name`: The suggested file name that will be presented to the user as
		 *         the default name to read or write. This is optional.
		 * `mime`: The mime type as a string.
		 * `accepts`: The optional list of accept options for this file opener.
		 *            Each option will be presented as a unique group to the
		 *            end-user.
		 *
		 */
		var fileType = accepts[0].extensions[0];
		var deferred = $q.defer();

		var fileDescriptor = ipc.sendSync("saveFile", fileType);

		if(fileDescriptor === null) {deferred.reject(); }
		else
		{
			var filepath = fileDescriptor.substring(0, fileDescriptor.lastIndexOf(delimiter) + 1);
			var filename =	fileDescriptor.substring(fileDescriptor.lastIndexOf(delimiter) + 1, fileDescriptor.length);

			var writeFilePromise = writeFile(null, filepath, filename, data, mime);

			writeFilePromise.then(function(){
				deferred.resolve("success");
			},
				function(reason){
					deferred.reject(reason);
				}
			);
		}

		return deferred.promise;
	};



	return {
		"requestFileSystem": requestFileSystem,
		"listDirectory": listDirectory,
		"getAppDataDir": getAppDataDir,
		"getExamDir": getExamDir,
		"getLogDir": getLogDir,
		"makeLogDir": makeLogDir,
		"makeDir": makeDir,
		"openFile": openFile,
		"readFile": readFile,
		"requestQuota": requestQuota,
		"saveAs": saveAs,
		"writeFile": writeFile,
		"printModuleName": printModuleName
	};
});

angular.module("digiexamclient.storage.filesystem")
.service("DXFileSystem", function($window, BrowserFileSystem, ElectronFileSystem, ChromeAppFileSystem, IOSFileSystem, DX_PLATFORM) {
	"use strict";

	var PLATFORM_FILE_SYSTEMS = {
		"ELECTRON_APP": ElectronFileSystem,
		"BROWSER": BrowserFileSystem,
		"CHROME_APP": ChromeAppFileSystem,
		"IOS_WEBVIEW": IOSFileSystem
	};

	return PLATFORM_FILE_SYSTEMS[DX_PLATFORM];
});

angular.module("digiexamclient.storage.filesystem")
.factory("IOSFileSystem", function($q, $timeout, JsObjcBridge) {
	"use strict";

	var COMMAND = {
		"MAKE_DIR": "make_dir",
		"READ_FILE": "read_file",
		"WRITE_FILE": "write_file",
		"LIST_DIRECTORY": "list_directory"
	};

	var mockedPromise = function(resolveData) {
		var deferred = $q.defer();
		$timeout(function(){
			deferred.resolve(resolveData);
		}, 0);
		return deferred.promise;
	};

	var makePromiseAndCallback = function() {
		var deferred = $q.defer();
		var callback = function(data) {
			deferred.resolve(data);
		};
		return {"promise": deferred.promise, "callback": callback};
	};

	var sendToObjc = function(data) {
		var promiseAndCallback = makePromiseAndCallback();
		var promise = promiseAndCallback.promise;
		var callback = promiseAndCallback.callback;
		JsObjcBridge.sendToObjc(data, callback);
		return promise;
	};

	var requestFileSystem = function() {
		/*
		 * Mocked since this is not necessary on iOS
		 */
		return mockedPromise();
	};

	var listDirectory = function(quota, path) {
		/*
		 * Get directory content as a string(NSFileManager
		 * contentsOfDirectoryAtPath description).
		 */
		var data = {
			"command": COMMAND.LIST_DIRECTORY,
			"data": {
				"path": path
			}
		};
		var promise = sendToObjc(data);
		return promise;
	};

	var makeDir = function(quota, path, name) {
		/*
		 * Creates a directory.
		 */
		var data = {
			"command": COMMAND.MAKE_DIR,
			"data": {
				"path": path,
				"name": name
			}
		};
		var promise = sendToObjc(data);
		return promise;
	};

	var openFile = function() {
		/*
		 * Mocked until offline support exists
		 */
		return mockedPromise();
	};

	var readFile = function(quota, path, name) {
		/*
		 * Get contents of an existing file as a string.
		 */
		var data = {
			"command": COMMAND.READ_FILE,
			"data": {
				"path": path,
				"name": name
			}
		};
		var promise = sendToObjc(data);
		return promise;
	};

	var requestQuota = function() {
		/*
		 * Mocked since this is not necessary on iOS
		 */
		return mockedPromise();
	};

	var saveAs = function() {
		/*
		 * Prompts the user to open an existing file or a new file and returns a
		 * writable FileEntry on success.
		 *
		 * `data`: The blob to write
		 * `name`: The suggested file name that will be presented to the user as
		 *         the default name to read or write. This is optional.
		 * `mime`: The mime type as a string.
		 * `accepts`: The optional list of accept options for this file opener.
		 *            Each option will be presented as a unique group to the
		 *            end-user.
		 */
		return mockedPromise();
	};

	var writeFile = function(quota, path, filename, fileData, mime) {
		/*
		 * Creates up a file without prompting the user.
		 *
		 * `quota`: The storage space—in bytes
		 * `path`: Either an absolute path or a relative path from the
		 *         DirectoryEntry to the directory to be looked up.
		 * `filename`: Name of file to be appended to path
		 * `data`: The blob to write
		 * `mime`: The mime type as a string.
		 */
		var data = {
			"command": COMMAND.WRITE_FILE,
			"data": {
				"path": path,
				"filename": filename,
				"data": fileData,
				"mime": mime
			}
		};
		var promise = sendToObjc(data);
		return promise;
	};

	return {
		"requestFileSystem": requestFileSystem, // Mocked, not necessary on iOS
		"listDirectory": listDirectory,         // Implemented
		"makeDir": makeDir,                     // Implemented
		"openFile": openFile,                   // Mocked, will not implement until offline support exists
		"readFile": readFile,                   // Implemented
		"requestQuota": requestQuota,           // Mocked, not necessary on iOS
		"saveAs": saveAs,                       // Mocked, will not implement until offline support exists
		"writeFile": writeFile                  // Implemented
	};
});

angular.module("digiexamclient.storage.localstorage")
.factory("BrowserLocalStorage", function($q, $window){
	"use strict";

	var BadLocalStorageArgumentType = function (message) {
		var defaultMessage = "This implementation of local storage's get, set and remove methods requires key arguments to be of type string";

		Error.call(this);
		Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object
		this.name = "BadLocalStorageArgumentType";
		this.message = (message || defaultMessage);
	};
	BadLocalStorageArgumentType.prototype = Error.prototype;

	var verifyKeyTypeIsString = function(key, deferred) {
		if (typeof key !== "string") {
			var e = new BadLocalStorageArgumentType();
			deferred.reject(e);
			throw e;
		}
	};

	var get = function(key) {
		var deferred = $q.defer();
		var ret = {};
		verifyKeyTypeIsString(key, deferred);
		if (!$window.localStorage.getItem(key) !== undefined) {
			ret[key] = $window.localStorage.getItem(key) ? JSON.parse($window.localStorage[key]) : undefined;
			deferred.resolve(ret);
		}
		return deferred.promise;
	};

	var set = function(key, value) {
		var deferred = $q.defer();
		verifyKeyTypeIsString(key, deferred);
		$window.localStorage.setItem(key, JSON.stringify(value));
		deferred.resolve();
		return deferred.promise;
	};

	var remove = function(key) {
		var deferred = $q.defer();
		verifyKeyTypeIsString(key, deferred);
		try {
			$window.localStorage.removeItem(key);
			deferred.resolve();
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise;
	};

	var clear = function() {
		var deferred = $q.defer();
		try {
			for (var key in $window.localStorage) {
				if ($window.localStorage.hasOwnProperty(key)) {
					$window.localStorage.removeItem(key);
				}
			}
			deferred.resolve();
		}
		catch (e) {
			deferred.reject(e);
		}
		return deferred.promise;
	};

	return {
		get: get,
		set: set,
		remove: remove,
		clear: clear
	};
});

(function() {
  angular.module("digiexamclient.storage.localstorage").factory("ChromeAppLocalStorage", function($rootScope, $window, $q) {
    var ChromeAppLocalStorage;
    ChromeAppLocalStorage = {
      get: function(data) {
        var deferred;
        deferred = $q.defer();
        $window.chrome.storage.local.get(data, function(data) {
          if ($window.chrome.runtime.lastError != null) {
            return deferred.reject($window.chrome.runtime.lastError);
          } else {
            return deferred.resolve(data);
          }
        });
        return deferred.promise;
      },
      set: function(key, value) {
        var copy, deferred, obj;
        deferred = $q.defer();
        obj = {};
        if (typeof key === "string") {
          obj[key] = value;
        }
        if (isObject(key)) {
          obj = key;
        }
        copy = JSON.parse(JSON.stringify(obj));
        $window.chrome.storage.local.set(copy, function() {
          if ($window.chrome.runtime.lastError != null) {
            return deferred.reject($window.chrome.runtime.lastError);
          } else {
            return deferred.resolve();
          }
        });
        return deferred.promise;
      },
      remove: function(data) {
        var deferred;
        deferred = $q.defer();
        $window.chrome.storage.local.remove(data);
        if ($window.chrome.runtime.lastError != null) {
          deferred.reject($window.chrome.runtime.lastError);
        } else {
          deferred.resolve();
        }
        return deferred.promise;
      },
      clear: function() {
        var deferred;
        deferred = $q.defer();
        $window.chrome.storage.local.clear();
        if ($window.chrome.runtime.lastError != null) {
          deferred.reject($window.chrome.runtime.lastError);
        } else {
          deferred.resolve();
        }
        return deferred.promise;
      }
    };
    return ChromeAppLocalStorage;
  });

}).call(this);

angular.module("digiexamclient.storage.localstorage")
.factory("ElectronLocalStorage", function($q, $window){
	"use strict";

	var BadLocalStorageArgumentType = function (message) {
		var defaultMessage = "This implementation of local storage's get, set and remove methods requires key arguments to be of type string";

		Error.call(this);
		Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object
		this.name = "BadLocalStorageArgumentType";
		this.message = (message || defaultMessage);
	};
	BadLocalStorageArgumentType.prototype = Error.prototype;

	var verifyKeyTypeIsString = function(key, deferred) {
		if (typeof key !== "string") {
			var e = new BadLocalStorageArgumentType();
			deferred.reject(e);
			throw e;
		}
	};

	var get = function(key) {
		var deferred = $q.defer();
		var ret = {};
		verifyKeyTypeIsString(key, deferred);
		if (!$window.localStorage.getItem(key) !== undefined) {
			ret[key] = $window.localStorage.getItem(key) ? JSON.parse($window.localStorage[key]) : undefined;
			deferred.resolve(ret);
		}
		return deferred.promise;
	};

	var set = function(key, value) {
		var deferred = $q.defer();
		verifyKeyTypeIsString(key, deferred);
		$window.localStorage.setItem(key, JSON.stringify(value));
		deferred.resolve();
		return deferred.promise;
	};

	var remove = function(key) {
		var deferred = $q.defer();
		verifyKeyTypeIsString(key, deferred);
		try {
			$window.localStorage.removeItem(key);
			deferred.resolve();
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise;
	};

	var clear = function() {
		var deferred = $q.defer();
		try {
			for (var key in $window.localStorage) {
				if ($window.localStorage.hasOwnProperty(key)) {
					$window.localStorage.removeItem(key);
				}
			}
			deferred.resolve();
		}
		catch (e) {
			deferred.reject(e);
		}
		return deferred.promise;
	};

	return {
		get: get,
		set: set,
		remove: remove,
		clear: clear
	};
});

angular.module("digiexamclient.storage.localstorage")
.factory("IOSLocalStorage", function($q, $timeout, $rootScope, JsObjcBridge) {
	"use strict";

	var COMMAND = {
		"GET": "get_local_storage_key",
		"SET": "set_local_storage_key",
		"REMOVE": "remove_local_storage_key",
		"CLEAR": "clear_local_storage"
	};

	var sendToObjc = function(data, dataTranformer) {
		var deferred = $q.defer();
		var callback = function(responseData) {
			try {
				responseData = JSON.parse(responseData);
			} catch(e) {
				angular.noop();
			}
			if (typeof dataTranformer !== "undefined") {
				responseData = dataTranformer.call(this, responseData);
			}
			deferred.resolve(responseData);
			$rootScope.$apply();
		};
		JsObjcBridge.sendToObjc(data, callback);
		return deferred.promise;
	};

	var get = function(key) {
		var data = {
			"command": COMMAND.GET,
			"data": {
				"key": key
			}
		};
		var dataTranformer = function(inData) {
			var retData = {};
			retData[key] = inData || null;
			return retData;
		};
		var promise = sendToObjc(data, dataTranformer);
		return promise;
	};

	var set = function(key, value) {
		var data = {
			"command": COMMAND.SET,
			"data": {
				"key": key,
				"value": JSON.stringify(value)
			}
		};
		var promise = sendToObjc(data);
		return promise;
	};

	var remove = function(key) {
		var data = {
			"command": COMMAND.REMOVE,
			"data": {
				"key": key
			}
		};
		var promise = sendToObjc(data);
		return promise;
	};

	var clear = function() {
		var data = {
			"command": COMMAND.CLEAR
		};
		var promise = sendToObjc(data);
		return promise;
	};

	return {
		"get": get,
		"set": set,
		"remove": remove,
		"clear": clear
	};
});

angular.module("digiexamclient.storage.localstorage")
.service("DXLocalStorage", function($window, BrowserLocalStorage, ChromeAppLocalStorage, ElectronLocalStorage, IOSLocalStorage, DX_PLATFORM) {
	"use strict";

	var PLATFORM_LOCAL_STORAGES = {
		"ELECTRON_APP": ElectronLocalStorage,
		"BROWSER": BrowserLocalStorage,
		"CHROME_APP": ChromeAppLocalStorage,
		"IOS_WEBVIEW": IOSLocalStorage
	};

	return PLATFORM_LOCAL_STORAGES[DX_PLATFORM];
});

(function() {
  angular.module("digiexamclient").constant("AnswerState", {
    NO_DATA: 0,
    DRAFT: 1,
    FINAL: 2,
    BLANK: 3
  });

}).call(this);

(function() {
  angular.module("digiexamclient").constant("DebugMessageType", {
    CRITICAL: 0,
    WARNING: 1,
    NORMAL: 2
  });

}).call(this);

(function() {
  angular.module("digiexamclient").constant("QuestionType", {
    TEXT_QUESTION: 0,
    SINGLE_CHOICE: 1,
    MULTIPLE_CHOICE: 2,
    TEXT_ONLY: 3
  });

}).call(this);

(function() {
  angular.module("digiexamclient").constant("Urls", {
    get: function(route, parameters) {
      var key, url, value;
      if (parameters == null) {
        parameters = {};
      }
      url = this.routes[route];
      if (typeof url !== "string") {
        throw Error("[Urls] Route does not exist: " + route);
      }
      for (key in parameters) {
        value = parameters[key];
        if (value instanceof Array) {
          value = value.join(",");
        }
        url = url.replace(":" + key, value);
      }
      return url;
    },
    routes: {
      login: "/",
      overview: "/overview",
      userEdit: "/user/edit",
      exam: "/exam/:id/:startOffline"
    }
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("dxImageList", function() {
    return {
      restrict: "E",
      scope: {
        images: "=",
        track: "="
      },
      template: "<div class='image-list'></div>",
      replace: true,
      link: function($scope, element, attrs) {
        var generateList, hasGenerated;
        hasGenerated = false;
        generateList = function(track, images) {
          var data, i, image, len, link, results, thumb;
          results = [];
          for (i = 0, len = images.length; i < len; i++) {
            data = images[i];
            thumb = document.createElement("div");
            thumb.setAttribute("class", "thumb");
            link = document.createElement("a");
            link.setAttribute("href", "data:image/png;base64," + data);
            link.setAttribute("data-lightbox", "image-" + track);
            image = new Image();
            image.src = "data:image/png;base64," + data;
            image.setAttribute("alt", "Image attachment");
            image.setAttribute("data-lightbox", "image-" + track);
            link.appendChild(image);
            thumb.appendChild(link);
            results.push(element.append(thumb));
          }
          return results;
        };
        return $scope.$watch("images", function(n, o) {
          if (($scope.images == null) || hasGenerated || $scope.images.length === 0) {
            return;
          }
          generateList($scope.track, $scope.images);
          return hasGenerated = true;
        });
      }
    };
  });

}).call(this);

angular.module("digiexamclient")
.directive("dxSetPlatformClass", function(DX_PLATFORM) {
	"use strict";

	var link = function(scope, element) {
		// set class to be:
		// "dx-" + value of DX_PLATFORM lower cased and _ being -
		element.addClass("dx-" + DX_PLATFORM.toLowerCase().replace("_", "-"));
	};

	return {
		restrict: "A",
		link: link
	};
});

(function() {
  angular.module("digiexamclient").directive("email", function(ValidationService) {
    return {
      require: "ngModel",
      link: function(scope, element, attrs, ngModel) {
        return ngModel.$parsers.unshift(function(viewValue) {
          if (ValidationService.isValidEmail(viewValue)) {
            ngModel.$setValidity("email", true);
            return viewValue;
          } else {
            ngModel.$setValidity("email", false);
            return viewValue;
          }
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("loader", function() {
    return {
      restrict: "E",
      template: "<div class=\"loader\"><div ng-transclude></div><div class=\"loader-indicator\"><svg version=\"1.1\" id=\"loader-1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ng-bind-attrs=\"getSVGAttributes()\" xml:space=\"preserve\"><path opacity=\"0.2\" fill=\"#ce4e41\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"/><path fill=\"#ce4e41\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\"><animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.7s\" repeatCount=\"indefinite\"/></path></svg></div></div>",
      transclude: true,
      replace: true
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("ngEnter", function($parse) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var fn;
        fn = $parse(attrs.ngEnter);
        return element.on("keydown keypress", function(event) {
          if (event.which === 13) {
            scope.$apply(function() {
              return (fn || angular.noop)(scope, {
                $event: event
              });
            });
            return event.preventDefault();
          }
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("noNavigateOnDisabled", function() {
    return {
      restrict: "A",
      link: function(scope, element, attr) {
        return element.on("click", function(event) {
          if (element.attr("disabled") && element.attr("disabled") !== "false" && element.attr("disabled") !== false) {
            return event.preventDefault();
          }
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("noPaste", function() {
    return {
      link: function(scope, element, attrs) {
        return element.on("paste", function(e) {
          return e.preventDefault();
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("noWhitespace", function() {
    return {
      require: "ngModel",
      link: function(scope, element, attrs, ngModel) {
        return ngModel.$parsers.unshift(function(viewValue) {
          if (/\s+/.test(viewValue) === false) {
            ngModel.$setValidity("noWhitespace", true);
            return viewValue;
          } else {
            ngModel.$setValidity("noWhitespace", false);
            return viewValue;
          }
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("sameAs", function($parse) {
    return {
      require: "ngModel",
      link: function(scope, element, attrs, ngModel) {
        return ngModel.$parsers.unshift(function(viewValue) {
          var match;
          match = $parse(attrs.sameAs)(scope);
          if (viewValue === match) {
            ngModel.$setValidity("sameAs", true);
            return viewValue;
          } else {
            ngModel.$setValidity("sameAs", false);
            return viewValue;
          }
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("toLowercase", function() {
    return {
      require: "ngModel",
      link: function(scope, element, attrs, ngModel) {
        return ngModel.$parsers.unshift(function(viewValue) {
          return (viewValue || "").toLowerCase();
        });
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").directive("userDetails", function() {
    return {
      restrict: "E",
      template: "<form name=\"details\"><ul class=\"unstyledList mb\"><li class=\"mb-300\"><label for=\"studentCode\">Student code</label><div class=\"input-error-wrapper\"><input type=\"text\" id=\"studentCode\" ng-model=\"user.code\" name=\"code\" required autocorrect=\"off\" autocapitalize=\"off\" no-whitespace to-lowercase> <span class=\"input-error\" ng-show=\"details.code.$error.noWhitespace && !details.code.$pristine\">Student code can't contain spaces</span> <span class=\"input-error\" ng-show=\"details.code.$error.required && !details.code.$pristine\">Student code is required</span></div></li><li class=\"mb-300\"><label for=\"firstname\">First name</label><div class=\"input-error-wrapper\"><input type=\"text\" id=\"firstname\" ng-model=\"user.firstname\" name=\"firstname\" required autocorrect=\"off\"> <span class=\"input-error\" ng-show=\"details.firstname.$invalid && !details.firstname.$pristine\">First name is required</span></div></li><li class=\"mb-300\"><label for=\"lastname\">Last name</label><div class=\"input-error-wrapper\"><input type=\"text\" id=\"lastname\" ng-model=\"user.lastname\" name=\"lastname\" required autocorrect=\"off\"> <span class=\"input-error\" ng-show=\"details.lastname.$invalid && !details.lastname.$pristine\">Last name is required</span></div></li><li class=\"mb-300\"><label for=\"email\">E-mail address</label><div class=\"input-error-wrapper\"><input type=\"email\" id=\"email\" ng-model=\"user.email\" name=\"email\" required email> <span class=\"input-error\" ng-show=\"details.email.$invalid && !details.email.$pristine\">A valid e-mail address is required</span></div></li><li><label for=\"confirm-email\">Confirm e-mail address</label><div class=\"input-error-wrapper\"><input type=\"email\" id=\"confirm-email\" ng-model=\"confirmEmail\" name=\"confirmEmail\" required email same-as=\"user.email\" no-paste> <span class=\"input-error\" ng-show=\"details.confirmEmail.$error.sameAs && !details.confirmEmail.$pristine\">The e-mail addresses does not match</span></div></li></ul><button class=\"btn btn-green\" ng-click=\"save()\" ng-disabled=\"details.$invalid\">OK</button></form>",
      scope: {
        user: "="
      },
      controller: function($scope, $location, SessionService, Urls, $timeout) {
        $scope.confirmEmail = $scope.user.email.length > 0 ? $scope.user.email : "";
        $scope.$watch("user.email", function(n, o) {
          if (n === o) {
            return;
          }
          return $scope.confirmEmail = "";
        });
        return $scope.save = function() {
          SessionService.setUser($scope.user);
          $scope.$emit("Statusbar:SetUser", $scope.user);
          return location.reload();
        };
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ExamController", function($rootScope, $scope, $routeParams, $location, $modal, $interval, $q, $filter, $http, Urls, Answer, AnswerQueue, AnswerState, ExamInfo, ExamInfoRepository, SessionService, DXLocalStorage, DXFileSystem, JsObjcBridge, QuestionType, DX_PLATFORM, DXLockdown, GradingTypeEnum) {
    var fsQuotaPromise, queue, storageAnswersKey, storageExamKey;
    $scope.QuestionType = QuestionType;
    $scope.GradingTypeEnum = GradingTypeEnum;
    $scope.isLoading = true;
    $scope.showTurnInButton = true;
    $scope.exam = new ExamInfo({
      id: parseInt($routeParams.id, 10)
    });
    $scope.answers = [];
    $scope.$emit("Statusbar:OnExamStart", $scope.exam.id);
    storageExamKey = "u-" + SessionService.user.code + "-exam-" + $scope.exam.id;
    storageAnswersKey = "u-" + SessionService.user.code + "-exam-" + $scope.exam.id + "-answers";
    queue = null;
    $scope.fsQuota = 0;
    $scope.startOffline = $routeParams.startOffline === "true";
    fsQuotaPromise = DXFileSystem.requestQuota(100 * 1024 * 1024);
    fsQuotaPromise.then(function(quota) {
      return $scope.fsQuota = quota;
    });
    $scope.initializeExamView = function() {
      return $q.all([ExamInfo.getFromStorageById($scope.exam.id, SessionService.user.code), Answer.getFromStorageByExamId($scope.exam.id, SessionService.user.code)]).then($scope.handleFileSystemInitializeSuccess, $scope.handleStorageError);
    };
    $scope.handleFileSystemInitializeSuccess = function(results) {
      var promise, responseFail, responseSuccess, storedAnswers, storedExam;
      storedExam = results[0];
      storedAnswers = results[1];
      responseSuccess = function(onlineExam) {
        return $scope.initializeExam(onlineExam, storedExam, storedAnswers);
      };
      responseFail = function(response) {
        return $scope.handleOnlineExamInitializeFail(response, storedExam, storedAnswers);
      };
      if (!$scope.startOffline) {
        promise = ExamInfoRepository.get($scope.exam.id, SessionService.user.code, SessionService.user.firstname, SessionService.user.lastname, SessionService.user.email).then(responseSuccess, responseFail);
        return promise["finally"](function() {
          return $scope.isLoading = false;
        });
      } else {
        if (storedExam != null) {
          responseSuccess();
        } else {
          responseFail();
        }
        return $scope.isLoading = false;
      }
    };
    $scope.initializeExam = function(onlineExam, storedExam, storedAnswers) {
      var answers;
      if (storedAnswers.length === 0) {
        answers = storedExam != null ? $scope.extractAnswers(storedExam) : $scope.extractAnswers(onlineExam);
        $scope.saveAnswersToStorage(answers);
      } else {
        answers = storedAnswers;
      }
      $scope.answers = answers;
      if (storedExam != null) {
        return $scope.startExam(storedExam);
      } else {
        $scope.startExam(onlineExam);
        return $scope.saveExamToStorage(onlineExam);
      }
    };
    $scope.extractAnswers = function(exam) {
      var answers, i, len, q, ref;
      answers = [];
      ref = exam.questions;
      for (i = 0, len = ref.length; i < len; i++) {
        q = ref[i];
        answers.push(new Answer(q.type, q.id, q.answer));
        delete q.answer;
      }
      return answers;
    };
    $scope.startExam = function(exam) {
      var failedToLockToGuidedAccess, successfullyLockedToGuidedAccess;
      successfullyLockedToGuidedAccess = function() {
        var u;
        $scope.exam = new ExamInfo(exam);
        u = SessionService.user;
        if ($scope.startOffline) {
          $scope.startOfflineStartPoll(exam.id, u.code, u.firstname, u.lastname, u.email);
        }
        queue = new AnswerQueue($scope.exam.id, $scope.exam.studentId, u.code, u.firstname, u.lastname, u.email);
        queue.setState(AnswerState.DRAFT);
        return queue.start();
      };
      failedToLockToGuidedAccess = function() {
        $scope.$emit("Toast:Notification", "Could not lock to guided access and will therefore not start exam");
        return $location.path(Urls.get("overview"));
      };
      if (DX_PLATFORM === "IOS_WEBVIEW") {
        return JsObjcBridge.lockToGuidedAccess(successfullyLockedToGuidedAccess, failedToLockToGuidedAccess);
      } else {
        return successfullyLockedToGuidedAccess();
      }
    };
    $scope.handleOnlineExamInitializeFail = function(response, storedExam, storedAnswers) {
      if (!!response && !!response.data) {
        return $scope.handleOnlineExamStartError(response.data.code, response.data.error);
      } else if (storedExam != null) {
        return $scope.initializeExam(null, storedExam, storedAnswers);
      } else {
        $scope.$emit("Statusbar:OnExamEnd");
        $scope.$emit("Toast:Notification", "No local exam and no connection to server");
        return $location.path(Urls.get("overview"));
      }
    };
    $scope.handleOnlineExamStartError = function(code, message) {
      switch (code) {
        case 22:
          $scope.$emit("Toast:Notification", "Exam has ended");
          break;
        case 24:
          $scope.$emit("Toast:Notification", "Exam already downloaded");
          break;
        default:
          $scope.$emit("Toast:Notification", "Server error: '" + message + "'");
      }
      $scope.$emit("Statusbar:OnExamEnd");
      return $location.path(Urls.get("overview"));
    };
    $scope.handleStorageError = function() {
      $scope.isLoading = false;
      $scope.showTurnInButton = false;
      return $modal.show({
        templateUrl: "partials/modals/error/storage-exception.html",
        controller: "ModalErrorStorageExceptionController"
      });
    };
    $scope.onAnswerChange = function(a) {
      $scope.saveAnswersToStorage($scope.answers);
      return queue.add(a);
    };
    $scope.confirmTurnIn = function() {
      var instance;
      queue.send();
      queue.stop();
      instance = $modal.show({
        templateUrl: "partials/modals/exam/confirm-turn-in.html",
        controller: "ModalGenericConfirmController"
      });
      instance.result.then(function() {
        return $scope.turnIn();
      }, function() {
        return queue.start();
      });
      return instance;
    };
    $scope.turnIn = function() {
      var a, i, len, promise, ref;
      queue.setState(AnswerState.FINAL);
      ref = $scope.answers;
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        queue.add(a);
      }
      promise = queue.send();
      return promise.then(function() {
        return $scope.handleSuccessfulTurnIn();
      }, function(response) {
        if (DX_PLATFORM !== "IOS_WEBVIEW") {
          return $scope.showOfflineFileTurnInDialog();
        } else {
          DXLockdown.tearDown();
          return $scope.showUploadLaterDialog();
        }
      });
    };
    $scope.handleSuccessfulTurnIn = function() {
      var promise;
      promise = $scope.reassignStoredData();
      return promise.then(function() {
        DXLockdown.tearDown();
        return $scope.showSuccessfulTurnInModal();
      });
    };
    $scope.showOfflineFileTurnInDialog = function() {
      var modalInstance, modalScope;
      modalScope = $rootScope.$new();
      modalScope.exam = $scope.exam;
      modalScope.answers = $scope.answers;
      modalInstance = $modal.show({
        $scope: modalScope,
        templateUrl: "partials/modals/exam/offline-turn-in.html",
        controller: "ModalOfflineTurnInController"
      });
      modalInstance.result.then(function() {
        return $scope.handleSuccessfulTurnIn();
      });
      return modalInstance;
    };
    $scope.showSuccessfulTurnInModal = function() {
      return $modal.show({
        templateUrl: "partials/modals/exam/successful-turn-in.html",
        controller: "ModalSuccessfulTurnInController"
      });
    };
    $scope.showUploadLaterDialog = function() {
      return $modal.show({
        templateUrl: "partials/modals/exam/failed-turn-in.html",
        controller: "ModalSuccessfulTurnInController"
      });
    };
    $scope.reassignStoredData = function() {
      var date, dxr, newStorageExamKey, promise;
      date = $filter("date")(new Date(), "yyyyMMdd-HHmmss");
      newStorageExamKey = storageExamKey + ("-" + date);
      dxr = $scope.getFinalDXR();
      queue.clear();
      promise = DXFileSystem.writeFile($scope.fsQuota, "exams/", newStorageExamKey, JSON.stringify(dxr), "text/plain");
      return promise.then(function() {
        return $q.all([DXLocalStorage.remove(storageExamKey), DXLocalStorage.remove(storageAnswersKey)]);
      });
    };
    $scope.getFinalDXR = function() {
      var a, i, len, ref;
      queue.setState(AnswerState.FINAL);
      ref = $scope.answers;
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        queue.add(a);
      }
      return queue.getDXR();
    };
    $scope.offlineStartPollInterval = 1000 * 10;
    $scope.offlineStartPollIntervalPromise = null;
    $scope.offlineStartPoll = function(examId, studentCode, firstname, lastname, email) {
      return ExamInfoRepository.offlineGet(examId, studentCode, firstname, lastname, email).then(function(studentId) {
        if (studentId == null) {
          return;
        }
        $scope.setExamStudentId(studentId);
        return $scope.stopOfflineStartPoll();
      });
    };
    $scope.startOfflineStartPoll = function(examId, studentCode, firstname, lastname, email) {
      return $scope.offlineStartPollIntervalPromise = $interval(function() {
        return $scope.offlineStartPoll(examId, studentCode, firstname, lastname, email);
      }, $scope.offlineStartPollInterval);
    };
    $scope.stopOfflineStartPoll = function() {
      return $interval.cancel($scope.offlineStartPollIntervalPromise);
    };
    $scope.getQueue = function() {
      return queue;
    };
    $scope.saveExamToStorage = function(exam) {
      return DXLocalStorage.set(storageExamKey, exam);
    };
    $scope.saveAnswersToStorage = function(answers) {
      return DXLocalStorage.set(storageAnswersKey, answers);
    };
    $scope.setExamStudentId = function(studentId) {
      if (studentId == null) {
        return;
      }
      $scope.exam.studentId = studentId;
      return queue.setStudentId(studentId);
    };
    return $scope.initializeExamView();
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("DebugController", function($rootScope, $scope, DebugMessageType, DXFileSystem) {
    $scope.messages = [];
    $scope.dxrFiles = [];
    $scope.showMessages = false;
    $rootScope.$on("Debug:Critical", function(event, message) {
      return $scope.messages.push({
        type: DebugMessageType.CRITICAL,
        message: message
      });
    });
    $rootScope.$on("Debug:Warning", function(event, message) {
      return $scope.messages.push({
        type: DebugMessageType.WARNING,
        message: message
      });
    });
    $rootScope.$on("Debug:Message", function(event, message, type) {
      if (type == null) {
        type = DebugMessageType.NORMAL;
      }
      return $scope.messages.push({
        type: type,
        message: message
      });
    });
    $rootScope.$on("Debug:Show", function() {
      return $scope.showMessages = true;
    });
    $scope.clear = function() {
      return $scope.messages = [];
    };
    $scope.toggleDebugMessages = function() {
      return $scope.showMessages = !$scope.showMessages;
    };
    $scope.saveDXR = function(fileEntry) {
      return fileEntry.file(function(file) {
        var reader;
        reader = new FileReader();
        reader.onloadend = function(e) {
          var accepts;
          accepts = [
            {
              extensions: ["dxr"]
            }
          ];
          return DXFileSystem.saveAs(reader.result, fileEntry.name, "text/plain", accepts);
        };
        reader.onerror = function(ex) {
          return console.log(ex);
        };
        return reader.readAsText(file);
      });
    };
    return $scope.readDXRFiles = function() {
      var fsQuotaPromise;
      fsQuotaPromise = DXFileSystem.requestQuota(100 * 1024 * 1024);
      return fsQuotaPromise.then(function(quota) {
        return DXFileSystem.listDirectory(quota, "exams").then(function(files) {
          return $scope.dxrFiles = files;
        });
      });
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("LoginController", function($scope, $location, $modal, DXClient, DXFileSystem, Urls, SessionService, User, DX_PLATFORM) {
    var fsQuotaPromise;
    $scope.user = new User();
    $scope.showAuth = false;
    $scope.isLoading = true;
    if (DX_PLATFORM === "CHROME_APP" && !DXClient.isKiosk) {
      return;
    }
    $scope.handleStorageError = function(error) {
      return $modal.show({
        templateUrl: "partials/modals/error/storage-exception.html",
        controller: "ModalErrorStorageExceptionController"
      });
    };
    $scope.handleUserRestoreSuccess = function(user) {
      $scope.$emit("Statusbar:SetUser", user);
      return $location.path(Urls.get("overview"));
    };
    $scope.handleUserRestoreFail = function() {
      $scope.isLoading = false;
      return $scope.showAuth = true;
    };
    $scope.initializeUser = function() {
      var promise;
      promise = SessionService.restore();
      return promise.then(function(user) {
        if (!!user) {
          return $scope.handleUserRestoreSuccess(user);
        } else {
          return $scope.handleUserRestoreFail();
        }
      }, function() {
        return $scope.handleUserRestoreFail();
      });
    };
    fsQuotaPromise = DXFileSystem.requestQuota(100 * 1024 * 1024);
    return fsQuotaPromise.then(function(grantedBytes) {
      var createDirPromise;
      createDirPromise = DXFileSystem.makeDir(grantedBytes, "", "exams");
      return createDirPromise.then(function() {
        return $scope.initializeUser();
      }, function(ex) {
        return $scope.handleStorageError(ex);
      });
    }, function(ex) {
      return $scope.handleStorageError(ex);
    });
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("OverviewController", function($rootScope, $scope, $window, $modal, $location, $interval, $log, Urls, SessionService, Answer, ExamInfo, ExamInfoRepository, DXFileSystem, DXLocalStorage, DXLockdown, DX_PLATFORM) {
    $scope.loadingExams = true;
    $scope.exams = [];
    $scope.openExamCode = "";
    $scope.openExamError = "";
    $scope.openOfflineFileError = "";
    $scope.demoExamError = "";
    $scope.DX_PLATFORM = DX_PLATFORM;
    $scope.selectedExam = null;
    $scope.truncateDescription = true;
    $scope.resetErrorMessages = function() {
      $scope.openExamError = "";
      $scope.openOfflineFileError = "";
      return $scope.demoExamError = "";
    };
    $scope.refreshExams = function() {
      var promise;
      $scope.loadingExams = true;
      $scope.exams = [];
      $scope.resetErrorMessages();
      promise = ExamInfoRepository.getByStudentCode(SessionService.user.code).then(function(exams) {
        $scope.exams = exams;
        return $scope.selectedExam = exams.length > 0 ? $scope.exams[0] : null;
      }, function(response) {
        return $scope.$emit("Toast:Notification", "Could not communicate with DigiExam servers");
      });
      return promise["finally"](function() {
        $scope.loadingExams = false;
        return $scope.truncateDescription = true;
      });
    };
    $scope.isValidOpenExamCode = function(code) {
      return typeof code === "number" && code > 0;
    };
    $scope.getOpenExam = function() {
      var promise;
      if (!$scope.isValidOpenExamCode($scope.openExamCode)) {
        return;
      }
      $scope.loadingExams = true;
      $scope.resetErrorMessages();
      promise = ExamInfoRepository.getByOpenExamCode($scope.openExamCode).then(function(exam) {
        $scope.exams = [exam];
        return $scope.selectedExam = exam;
      }, function(response) {
        if (isObject(response.data) && (response.data.code != null) && (response.data.error != null)) {
          switch (response.data.code) {
            case 40:
              return $scope.openExamError = "Could not find exam.";
            default:
              return $scope.openExamError = "Server error: '" + response.data.error + "'";
          }
        } else {
          return $scope.$emit("Toast:Notification", "Could not communicate with DigiExam servers");
        }
      });
      return promise["finally"](function() {
        $scope.loadingExams = false;
        return $scope.truncateDescription = true;
      });
    };
    $scope.getDemoExam = function() {
      var promise;
      $scope.resetErrorMessages();
      promise = ExamInfoRepository.getByOpenExamCode(0);
      return promise.then(function(exam) {
        $scope.exams = [exam];
        return $scope.selectedExam = exam;
      }, function(response) {
        if (isObject(response.data) && response.data.code && response.data.error) {
          switch (response.data.code) {
            case 40:
              return $scope.demoExamError = "Could not find demo exam.";
            default:
              return $scope.demoExamError = "Server error: '" + response.data.error + "'";
          }
        } else {
          return $scope.$emit("Toast:Notification", "Could not communicate with DigiExam servers");
        }
      });
    };
    $scope.extendAnswers = function(destAnswers, srcAnswers) {
      var a, answers, i, j, len;
      answers = [];
      for (i = j = 0, len = destAnswers.length; j < len; i = ++j) {
        a = destAnswers[i];
        if (srcAnswers[i] != null) {
          a = angular.extend(a, srcAnswers[i]);
        }
        answers.push(a);
      }
      return answers;
    };
    $scope.parseDXE = function(dxe) {
      var exam, examInfo, j, len, q, ref;
      examInfo = new ExamInfo(angular.extend(dxe.examList[0], {
        _startOffline: true
      }));
      exam = new ExamInfo(dxe.exams[0]);
      ref = exam.questions;
      for (j = 0, len = ref.length; j < len; j++) {
        q = ref[j];
        q.answer = new Answer(q.type, q.id);
      }
      return {
        examInfo: examInfo,
        exam: exam
      };
    };
    $scope.isValidDXE = function(dxe) {
      var hasExamList, hasExams, isObj;
      isObj = isObject(dxe);
      hasExamList = isObj && isArray(dxe.examList) && dxe.examList.length > 0;
      hasExams = isObj && isArray(dxe.exams) && dxe.exams.length > 0;
      return hasExamList && hasExams;
    };
    $scope.saveExamToStorage = function(exam) {
      return DXLocalStorage.set("u-" + SessionService.user.code + "-exam-" + exam.id, exam);
    };
    $scope.saveAnswersToStorage = function(examId, answers) {
      return DXLocalStorage.set("u-" + SessionService.user.code + "-exam-" + examId + "-answers", answers);
    };
    $scope.handleGetAnswersFromStorageSuccess = function(dxe, storedAnswers) {
      var answers;
      answers = $scope.extendAnswers(dxe.exam.extractAnswers(), storedAnswers);
      $scope.saveExamToStorage(dxe.exam);
      $scope.saveAnswersToStorage(dxe.exam.id, answers);
      $scope.selectedExam = dxe.examInfo;
      return $scope.exams = [dxe.examInfo];
    };
    $scope.handleOpenOfflineFileSuccess = function(data) {
      var dxe;
      dxe = JSON.parse(data);
      if (!$scope.isValidDXE(dxe)) {
        return $scope.openOfflineFileError = "Couldn't read file.";
      } else {
        dxe = $scope.parseDXE(dxe);
        return Answer.getFromStorageByExamId(dxe.exam.id, SessionService.user.code).then(function(storedAnswers) {
          return $scope.handleGetAnswersFromStorageSuccess(dxe, storedAnswers);
        });
      }
    };
    $scope.openOfflineFile = function() {
      var promise;
      $scope.openOfflineFileError = "";
      $log.log(DXFileSystem);
      promise = DXFileSystem.openFile([
        {
          extensions: ["dxe"]
        }
      ]);
      return promise.then($scope.handleOpenOfflineFileSuccess);
    };
    $scope.toggleSelectedExam = function(exam) {
      if ($scope.exams.length === 1) {
        return;
      }
      $scope.truncateDescription = true;
      return $scope.selectedExam = ($scope.selectedExam != null) && $scope.selectedExam.id === exam.id ? null : exam;
    };
    $scope.getDescription = function(exam) {
      if (exam.about.length > 300 && $scope.truncateDescription) {
        return exam.about.substr(0, 297) + "...";
      }
      return exam.about;
    };
    $scope.toggleExamDescription = function() {
      return $scope.truncateDescription = !$scope.truncateDescription;
    };
    $scope.confirmStartExam = function() {
      var instance, modalScope;
      modalScope = $rootScope.$new();
      modalScope.exam = $scope.selectedExam;
      instance = $modal.show({
        $scope: modalScope,
        templateUrl: "partials/modals/overview/confirm-start-exam.html",
        controller: "ModalGenericConfirmController"
      });
      return instance.result.then(function() {
        $scope.startExam($scope.selectedExam);
        return instance;
      });
    };
    $scope.startExam = function(exam) {
      DXLockdown.executeLockdown();
      DXLockdown.onLockdown();
      return $location.path(Urls.get("exam", {
        id: exam.id,
        startOffline: exam._startOffline
      }));
    };
    return $scope.refreshExams();
  });

}).call(this);

angular.module("digiexam-preconditiontest").controller("preconditiontest-controller", function ($scope, $window, DX_PLATFORM, ElectronFileSystem, DXPreConditionTest) {
	"use strict";

	var self = $scope;
	self.warningArray = 0;
	self.fatalFailArray = 0;
	self.state = "running";
	var ipc = $window.require("ipc");

	self.continue = function() {
		ipc.sendSync("testsPassed");
	};

	self.close = function() {
		$window.close();
	};

	self.hasWarnings = function() {
		return self.warningArray.length > 0;
	};

	self.hasFatalFails = function() {
		return self.fatalFailArray.length > 0;
	};

	function onAllTestsFinished(warnings, fatals) {
		$window.console.log("All tests finished");
		self.warningArray = warnings;
		self.fatalFailArray = fatals;

		if (!(self.hasWarnings() || self.hasFatalFails())) {
			self.state = "passed";
			self.continue();
		}
		else if (self.hasFatalFails()) {
			self.state = "fatal";
		}
		else {
			self.state = "warning";
		}
	}

	DXPreConditionTest.init(onAllTestsFinished);
});

(function() {
  angular.module("digiexamclient").controller("StatusbarController", function($window, $rootScope, $scope, $interval, $location, $modal, DXClient, Urls, User, SessionService, DX_PLATFORM) {
    $scope.DX_PLATFORM = DX_PLATFORM;
    $scope.user = new User();
    $scope.showUser = true;
    $scope.hasActiveExam = false;
    $scope.time = new Date();
    $interval(function() {
      return $scope.updateClockTime();
    }, 1000);
    $scope.Urls = Urls;
    $rootScope.$on("Statusbar:SetUser", function(event, user) {
      return $scope.user = user;
    });
    $rootScope.$on("Statusbar:OnExamStart", function(event, examId) {
      $scope.showUser = false;
      return $scope.hasActiveExam = true;
    });
    $rootScope.$on("Statusbar:OnExamEnd", function(event, examId) {
      $scope.showUser = true;
      return $scope.hasActiveExam = false;
    });
    $scope.version = $window.version;
    $scope.updateClockTime = function() {
      return $scope.time = new Date();
    };
    $scope.hasUser = function() {
      return SessionService.isAuthenticated();
    };
    $scope.confirmClose = function() {
      var instance;
      if ($scope.hasActiveExam) {
        return;
      }
      instance = $modal.show({
        templateUrl: "partials/modals/system/confirm-close.html",
        controller: "ModalGenericConfirmController"
      });
      return instance.result.then(function() {
        return DXClient.close();
      });
    };
    if (DX_PLATFORM === "CHROME_APP" && !DXClient.isKiosk) {
      $scope.showUser = false;
      return $modal.show({
        templateUrl: "partials/modals/not-secure/not-secure.html",
        controller: "ModalNotSecureController"
      });
    }
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ToastController", function($rootScope, $scope, $timeout) {
    var maxToasts, uniqueId;
    uniqueId = function() {
      return Math.floor(Math.random() * 10000);
    };
    maxToasts = 5;
    $scope.toasts = [];
    $rootScope.$on("Toast:Notification", function(event, message) {
      return $scope.addToast(message);
    });
    $scope.addToast = function(message) {
      var t;
      t = {
        id: uniqueId(),
        message: message
      };
      $timeout(function() {
        return $scope.dismissToast(t.id);
      }, 1000 * 10);
      $scope.toasts.push(t);
      if ($scope.toasts.length > maxToasts) {
        $scope.dismissToast($scope.toasts[0].id);
      }
      return t.id;
    };
    return $scope.dismissToast = function(tId) {
      var i, j, len, ref, results, t;
      ref = $scope.toasts;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        t = ref[i];
        if (t.id === tId) {
          $scope.toasts.splice(i, 1);
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("UserEditController", function($scope, $location, Urls, SessionService, User) {
    return $scope.user = angular.copy(SessionService.user);
  });

}).call(this);

(function() {
  angular.module("digiexamclient.session").service("SessionService", function(Session) {
    return new Session();
  });

}).call(this);

(function() {
  angular.module("digiexamclient.validation", []).service("ValidationService", function() {
    return {
      isValidEmail: function(email) {
        var emailExpression;
        if (typeof email !== "string" || email.length === 0) {
          return false;
        }
        emailExpression = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        return emailExpression.test(email);
      }
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ModalGenericConfirmController", function($scope, $modalInstance) {
    $scope.yes = function() {
      return $modalInstance.resolve(true);
    };
    return $scope.no = function() {
      return $modalInstance.reject();
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ModalErrorStorageExceptionController", function($scope, $modalInstance, DXClient) {
    return $scope.close = function() {
      return DXClient.close();
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ModalOfflineTurnInController", function($scope, $modalInstance, DXFileSystem, AnswerQueue, AnswerState, SessionService) {
    var queue;
    $scope.error = "";
    queue = new AnswerQueue($scope.exam.id, $scope.exam.userId, SessionService.user.code, SessionService.user.firstname, SessionService.user.lastname, SessionService.user.email);
    $scope.getQueue = function() {
      return queue;
    };
    return $scope.saveFile = function() {
      var a, accepts, data, i, len, promise, ref;
      queue.setState(AnswerState.FINAL);
      ref = $scope.answers;
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        queue.add(a);
      }
      data = JSON.stringify(queue.getDXR());
      accepts = [
        {
          extensions: ["dxr"]
        }
      ];
      promise = DXFileSystem.saveAs(data, $scope.exam.id + "-" + SessionService.user.code, "text/plain", accepts);
      return promise.then(function() {
        return $modalInstance.resolve();
      }, function(error) {
        return $scope.error = error;
      });
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ModalSuccessfulTurnInController", function($scope, $modalInstance, DXClient, DX_PLATFORM) {
    $scope.DX_PLATFORM = DX_PLATFORM;
    return $scope.close = function() {
      return DXClient.close($modalInstance);
    };
  });

}).call(this);

(function() {
  angular.module("digiexamclient").controller("ModalNotSecureController", function($scope, $modalInstance, DXClient) {
    $scope.showDebug = function() {
      return $scope.$emit("Debug:Show");
    };
    return $scope.exit = function() {
      return DXClient.close();
    };
  });

}).call(this);
