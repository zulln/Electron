function md5cycle(x, k) {
var a = x[0], b = x[1], c = x[2], d = x[3];
a = ff(a, b, c, d, k[0], 7, -680876936), d = ff(d, a, b, c, k[1], 12, -389564586), 
c = ff(c, d, a, b, k[2], 17, 606105819), b = ff(b, c, d, a, k[3], 22, -1044525330), 
a = ff(a, b, c, d, k[4], 7, -176418897), d = ff(d, a, b, c, k[5], 12, 1200080426), 
c = ff(c, d, a, b, k[6], 17, -1473231341), b = ff(b, c, d, a, k[7], 22, -45705983), 
a = ff(a, b, c, d, k[8], 7, 1770035416), d = ff(d, a, b, c, k[9], 12, -1958414417), 
c = ff(c, d, a, b, k[10], 17, -42063), b = ff(b, c, d, a, k[11], 22, -1990404162), 
a = ff(a, b, c, d, k[12], 7, 1804603682), d = ff(d, a, b, c, k[13], 12, -40341101), 
c = ff(c, d, a, b, k[14], 17, -1502002290), b = ff(b, c, d, a, k[15], 22, 1236535329), 
a = gg(a, b, c, d, k[1], 5, -165796510), d = gg(d, a, b, c, k[6], 9, -1069501632), 
c = gg(c, d, a, b, k[11], 14, 643717713), b = gg(b, c, d, a, k[0], 20, -373897302), 
a = gg(a, b, c, d, k[5], 5, -701558691), d = gg(d, a, b, c, k[10], 9, 38016083), 
c = gg(c, d, a, b, k[15], 14, -660478335), b = gg(b, c, d, a, k[4], 20, -405537848), 
a = gg(a, b, c, d, k[9], 5, 568446438), d = gg(d, a, b, c, k[14], 9, -1019803690), 
c = gg(c, d, a, b, k[3], 14, -187363961), b = gg(b, c, d, a, k[8], 20, 1163531501), 
a = gg(a, b, c, d, k[13], 5, -1444681467), d = gg(d, a, b, c, k[2], 9, -51403784), 
c = gg(c, d, a, b, k[7], 14, 1735328473), b = gg(b, c, d, a, k[12], 20, -1926607734), 
a = hh(a, b, c, d, k[5], 4, -378558), d = hh(d, a, b, c, k[8], 11, -2022574463), 
c = hh(c, d, a, b, k[11], 16, 1839030562), b = hh(b, c, d, a, k[14], 23, -35309556), 
a = hh(a, b, c, d, k[1], 4, -1530992060), d = hh(d, a, b, c, k[4], 11, 1272893353), 
c = hh(c, d, a, b, k[7], 16, -155497632), b = hh(b, c, d, a, k[10], 23, -1094730640), 
a = hh(a, b, c, d, k[13], 4, 681279174), d = hh(d, a, b, c, k[0], 11, -358537222), 
c = hh(c, d, a, b, k[3], 16, -722521979), b = hh(b, c, d, a, k[6], 23, 76029189), 
a = hh(a, b, c, d, k[9], 4, -640364487), d = hh(d, a, b, c, k[12], 11, -421815835), 
c = hh(c, d, a, b, k[15], 16, 530742520), b = hh(b, c, d, a, k[2], 23, -995338651), 
a = ii(a, b, c, d, k[0], 6, -198630844), d = ii(d, a, b, c, k[7], 10, 1126891415), 
c = ii(c, d, a, b, k[14], 15, -1416354905), b = ii(b, c, d, a, k[5], 21, -57434055), 
a = ii(a, b, c, d, k[12], 6, 1700485571), d = ii(d, a, b, c, k[3], 10, -1894986606), 
c = ii(c, d, a, b, k[10], 15, -1051523), b = ii(b, c, d, a, k[1], 21, -2054922799), 
a = ii(a, b, c, d, k[8], 6, 1873313359), d = ii(d, a, b, c, k[15], 10, -30611744), 
c = ii(c, d, a, b, k[6], 15, -1560198380), b = ii(b, c, d, a, k[13], 21, 1309151649), 
a = ii(a, b, c, d, k[4], 6, -145523070), d = ii(d, a, b, c, k[11], 10, -1120210379), 
c = ii(c, d, a, b, k[2], 15, 718787259), b = ii(b, c, d, a, k[9], 21, -343485551), 
x[0] = add32(a, x[0]), x[1] = add32(b, x[1]), x[2] = add32(c, x[2]), x[3] = add32(d, x[3]);
}

function cmn(q, a, b, x, s, t) {
return a = add32(add32(a, q), add32(x, t)), add32(a << s | a >>> 32 - s, b);
}

function ff(a, b, c, d, x, s, t) {
return cmn(b & c | ~b & d, a, b, x, s, t);
}

function gg(a, b, c, d, x, s, t) {
return cmn(b & d | c & ~d, a, b, x, s, t);
}

function hh(a, b, c, d, x, s, t) {
return cmn(b ^ c ^ d, a, b, x, s, t);
}

function ii(a, b, c, d, x, s, t) {
return cmn(c ^ (b | ~d), a, b, x, s, t);
}

function md51(s) {
txt = "";
var i, n = s.length, state = [ 1732584193, -271733879, -1732584194, 271733878 ];
for (i = 64; i <= s.length; i += 64) md5cycle(state, md5blk(s.substring(i - 64, i)));
s = s.substring(i - 64);
var tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
if (tail[i >> 2] |= 128 << (i % 4 << 3), i > 55) for (md5cycle(state, tail), i = 0; 16 > i; i++) tail[i] = 0;
return tail[14] = 8 * n, md5cycle(state, tail), state;
}

function md5blk(s) {
var i, md5blks = [];
for (i = 0; 64 > i; i += 4) md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
return md5blks;
}

function rhex(n) {
for (var s = "", j = 0; 4 > j; j++) s += hex_chr[n >> 8 * j + 4 & 15] + hex_chr[n >> 8 * j & 15];
return s;
}

function hex(x) {
for (var i = 0; i < x.length; i++) x[i] = rhex(x[i]);
return x.join("");
}

function md5(s) {
return hex(md51(s));
}

function add32(a, b) {
return a + b & 4294967295;
}

function add32(x, y) {
var lsw = (65535 & x) + (65535 & y), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
return msw << 16 | 65535 & lsw;
}

!function(global, factory) {
"object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) :function(w) {
if (!w.document) throw new Error("jQuery requires a window with a document");
return factory(w);
} :factory(global);
}("undefined" != typeof window ? window :this, function(window, noGlobal) {
function isArraylike(obj) {
var length = "length" in obj && obj.length, type = jQuery.type(obj);
return "function" === type || jQuery.isWindow(obj) ? !1 :1 === obj.nodeType && length ? !0 :"array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
}
function winnow(elements, qualifier, not) {
if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
return !!qualifier.call(elem, i, elem) !== not;
});
if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
return elem === qualifier !== not;
});
if ("string" == typeof qualifier) {
if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
qualifier = jQuery.filter(qualifier, elements);
}
return jQuery.grep(elements, function(elem) {
return indexOf.call(qualifier, elem) >= 0 !== not;
});
}
function sibling(cur, dir) {
for (;(cur = cur[dir]) && 1 !== cur.nodeType; ) ;
return cur;
}
function createOptions(options) {
var object = optionsCache[options] = {};
return jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
object[flag] = !0;
}), object;
}
function completed() {
document.removeEventListener("DOMContentLoaded", completed, !1), window.removeEventListener("load", completed, !1), 
jQuery.ready();
}
function Data() {
Object.defineProperty(this.cache = {}, 0, {
get:function() {
return {};
}
}), this.expando = jQuery.expando + Data.uid++;
}
function dataAttr(elem, key, data) {
var name;
if (void 0 === data && 1 === elem.nodeType) if (name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase(), 
data = elem.getAttribute(name), "string" == typeof data) {
try {
data = "true" === data ? !0 :"false" === data ? !1 :"null" === data ? null :+data + "" === data ? +data :rbrace.test(data) ? jQuery.parseJSON(data) :data;
} catch (e) {}
data_user.set(elem, key, data);
} else data = void 0;
return data;
}
function returnTrue() {
return !0;
}
function returnFalse() {
return !1;
}
function safeActiveElement() {
try {
return document.activeElement;
} catch (err) {}
}
function manipulationTarget(elem, content) {
return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content :content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) :elem;
}
function disableScript(elem) {
return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem;
}
function restoreScript(elem) {
var match = rscriptTypeMasked.exec(elem.type);
return match ? elem.type = match[1] :elem.removeAttribute("type"), elem;
}
function setGlobalEval(elems, refElements) {
for (var i = 0, l = elems.length; l > i; i++) data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
}
function cloneCopyEvent(src, dest) {
var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
if (1 === dest.nodeType) {
if (data_priv.hasData(src) && (pdataOld = data_priv.access(src), pdataCur = data_priv.set(dest, pdataOld), 
events = pdataOld.events)) {
delete pdataCur.handle, pdataCur.events = {};
for (type in events) for (i = 0, l = events[type].length; l > i; i++) jQuery.event.add(dest, type, events[type][i]);
}
data_user.hasData(src) && (udataOld = data_user.access(src), udataCur = jQuery.extend({}, udataOld), 
data_user.set(dest, udataCur));
}
}
function getAll(context, tag) {
var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :context.querySelectorAll ? context.querySelectorAll(tag || "*") :[];
return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) :ret;
}
function fixInput(src, dest) {
var nodeName = dest.nodeName.toLowerCase();
"input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked :("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue);
}
function actualDisplay(name, doc) {
var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display :jQuery.css(elem[0], "display");
return elem.detach(), display;
}
function defaultDisplay(nodeName) {
var doc = document, display = elemdisplay[nodeName];
return display || (display = actualDisplay(nodeName, doc), "none" !== display && display || (iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement), 
doc = iframe[0].contentDocument, doc.write(), doc.close(), display = actualDisplay(nodeName, doc), 
iframe.detach()), elemdisplay[nodeName] = display), display;
}
function curCSS(elem, name, computed) {
var width, minWidth, maxWidth, ret, style = elem.style;
return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name]), 
computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), 
rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, 
maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, 
ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), 
void 0 !== ret ? ret + "" :ret;
}
function addGetHookIf(conditionFn, hookFn) {
return {
get:function() {
return conditionFn() ? (delete this.get, void 0) :(this.get = hookFn).apply(this, arguments);
}
};
}
function vendorPropName(style, name) {
if (name in style) return name;
for (var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--; ) if (name = cssPrefixes[i] + capName, 
name in style) return name;
return origName;
}
function setPositiveNumber(elem, value, subtract) {
var matches = rnumsplit.exec(value);
return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :value;
}
function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
for (var i = extra === (isBorderBox ? "border" :"content") ? 4 :"width" === name ? 1 :0, val = 0; 4 > i; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), 
isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), 
"margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) :(val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), 
"padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
return val;
}
function getWidthOrHeight(elem, name, extra) {
var valueIsBorderBox = !0, val = "width" === name ? elem.offsetWidth :elem.offsetHeight, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
if (0 >= val || null == val) {
if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), 
rnumnonpx.test(val)) return val;
valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), 
val = parseFloat(val) || 0;
}
return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" :"content"), valueIsBorderBox, styles) + "px";
}
function showHide(elements, show) {
for (var display, elem, hidden, values = [], index = 0, length = elements.length; length > index; index++) elem = elements[index], 
elem.style && (values[index] = data_priv.get(elem, "olddisplay"), display = elem.style.display, 
show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName)))) :(hidden = isHidden(elem), 
"none" === display && hidden || data_priv.set(elem, "olddisplay", hidden ? display :jQuery.css(elem, "display"))));
for (index = 0; length > index; index++) elem = elements[index], elem.style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" :"none"));
return elements;
}
function Tween(elem, options, prop, end, easing) {
return new Tween.prototype.init(elem, options, prop, end, easing);
}
function createFxNow() {
return setTimeout(function() {
fxNow = void 0;
}), fxNow = jQuery.now();
}
function genFx(type, includeWidth) {
var which, i = 0, attrs = {
height:type
};
for (includeWidth = includeWidth ? 1 :0; 4 > i; i += 2 - includeWidth) which = cssExpand[i], 
attrs["margin" + which] = attrs["padding" + which] = type;
return includeWidth && (attrs.opacity = attrs.width = type), attrs;
}
function createTween(value, prop, animation) {
for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; length > index; index++) if (tween = collection[index].call(animation, prop, value)) return tween;
}
function defaultPrefilter(elem, props, opts) {
var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, 
oldfire = hooks.empty.fire, hooks.empty.fire = function() {
hooks.unqueued || oldfire();
}), hooks.unqueued++, anim.always(function() {
anim.always(function() {
hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
});
})), 1 === elem.nodeType && ("height" in props || "width" in props) && (opts.overflow = [ style.overflow, style.overflowX, style.overflowY ], 
display = jQuery.css(elem, "display"), checkDisplay = "none" === display ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) :display, 
"inline" === checkDisplay && "none" === jQuery.css(elem, "float") && (style.display = "inline-block")), 
opts.overflow && (style.overflow = "hidden", anim.always(function() {
style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
}));
for (prop in props) if (value = props[prop], rfxtypes.exec(value)) {
if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" :"show")) {
if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
hidden = !0;
}
orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
} else display = void 0;
if (jQuery.isEmptyObject(orig)) "inline" === ("none" === display ? defaultDisplay(elem.nodeName) :display) && (style.display = display); else {
dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) :dataShow = data_priv.access(elem, "fxshow", {}), 
toggle && (dataShow.hidden = !hidden), hidden ? jQuery(elem).show() :anim.done(function() {
jQuery(elem).hide();
}), anim.done(function() {
var prop;
data_priv.remove(elem, "fxshow");
for (prop in orig) jQuery.style(elem, prop, orig[prop]);
});
for (prop in orig) tween = createTween(hidden ? dataShow[prop] :0, prop, anim), 
prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, 
tween.start = "width" === prop || "height" === prop ? 1 :0));
}
}
function propFilter(props, specialEasing) {
var index, name, easing, value, hooks;
for (index in props) if (name = jQuery.camelCase(index), easing = specialEasing[name], 
value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), 
index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], 
hooks && "expand" in hooks) {
value = hooks.expand(value), delete props[name];
for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
} else specialEasing[name] = easing;
}
function Animation(elem, properties, options) {
var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
delete tick.elem;
}), tick = function() {
if (stopped) return !1;
for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++) animation.tweens[index].run(percent);
return deferred.notifyWith(elem, [ animation, percent, remaining ]), 1 > percent && length ? remaining :(deferred.resolveWith(elem, [ animation ]), 
!1);
}, animation = deferred.promise({
elem:elem,
props:jQuery.extend({}, properties),
opts:jQuery.extend(!0, {
specialEasing:{}
}, options),
originalProperties:properties,
originalOptions:options,
startTime:fxNow || createFxNow(),
duration:options.duration,
tweens:[],
createTween:function(prop, end) {
var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
return animation.tweens.push(tween), tween;
},
stop:function(gotoEnd) {
var index = 0, length = gotoEnd ? animation.tweens.length :0;
if (stopped) return this;
for (stopped = !0; length > index; index++) animation.tweens[index].run(1);
return gotoEnd ? deferred.resolveWith(elem, [ animation, gotoEnd ]) :deferred.rejectWith(elem, [ animation, gotoEnd ]), 
this;
}
}), props = animation.props;
for (propFilter(props, animation.opts.specialEasing); length > index; index++) if (result = animationPrefilters[index].call(animation, elem, props, animation.opts)) return result;
return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), 
jQuery.fx.timer(jQuery.extend(tick, {
elem:elem,
anim:animation,
queue:animation.opts.queue
})), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
}
function addToPrefiltersOrTransports(structure) {
return function(dataTypeExpression, func) {
"string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
if (jQuery.isFunction(func)) for (;dataType = dataTypes[i++]; ) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", 
(structure[dataType] = structure[dataType] || []).unshift(func)) :(structure[dataType] = structure[dataType] || []).push(func);
};
}
function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
function inspect(dataType) {
var selected;
return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) :void 0 :(options.dataTypes.unshift(dataTypeOrTransport), 
inspect(dataTypeOrTransport), !1);
}), selected;
}
var inspected = {}, seekingTransport = structure === transports;
return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
}
function ajaxExtend(target, src) {
var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target :deep || (deep = {}))[key] = src[key]);
return deep && jQuery.extend(!0, target, deep), target;
}
function ajaxHandleResponses(s, jqXHR, responses) {
for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(), 
void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
dataTypes.unshift(type);
break;
}
if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
for (type in responses) {
if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
finalDataType = type;
break;
}
firstDataType || (firstDataType = type);
}
finalDataType = finalDataType || firstDataType;
}
return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), 
responses[finalDataType]) :void 0;
}
function ajaxConvert(s, response, jqXHR, isSuccess) {
var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), 
!prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), 
prev = current, current = dataTypes.shift()) if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
if (conv = converters[prev + " " + current] || converters["* " + current], !conv) for (conv2 in converters) if (tmp = conv2.split(" "), 
tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
conv === !0 ? conv = converters[conv2] :converters[conv2] !== !0 && (current = tmp[0], 
dataTypes.unshift(tmp[1]));
break;
}
if (conv !== !0) if (conv && s["throws"]) response = conv(response); else try {
response = conv(response);
} catch (e) {
return {
state:"parsererror",
error:conv ? e :"No conversion from " + prev + " to " + current
};
}
}
return {
state:"success",
data:response
};
}
function buildParams(prefix, obj, traditional, add) {
var name;
if (jQuery.isArray(obj)) jQuery.each(obj, function(i, v) {
traditional || rbracket.test(prefix) ? add(prefix, v) :buildParams(prefix + "[" + ("object" == typeof v ? i :"") + "]", v, traditional, add);
}); else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj); else for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
}
function getWindow(elem) {
return jQuery.isWindow(elem) ? elem :9 === elem.nodeType && elem.defaultView;
}
var arr = [], slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, support = {}, document = window.document, version = "2.1.4", jQuery = function(selector, context) {
return new jQuery.fn.init(selector, context);
}, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
return letter.toUpperCase();
};
jQuery.fn = jQuery.prototype = {
jquery:version,
constructor:jQuery,
selector:"",
length:0,
toArray:function() {
return slice.call(this);
},
get:function(num) {
return null != num ? 0 > num ? this[num + this.length] :this[num] :slice.call(this);
},
pushStack:function(elems) {
var ret = jQuery.merge(this.constructor(), elems);
return ret.prevObject = this, ret.context = this.context, ret;
},
each:function(callback, args) {
return jQuery.each(this, callback, args);
},
map:function(callback) {
return this.pushStack(jQuery.map(this, function(elem, i) {
return callback.call(elem, i, elem);
}));
},
slice:function() {
return this.pushStack(slice.apply(this, arguments));
},
first:function() {
return this.eq(0);
},
last:function() {
return this.eq(-1);
},
eq:function(i) {
var len = this.length, j = +i + (0 > i ? len :0);
return this.pushStack(j >= 0 && len > j ? [ this[j] ] :[]);
},
end:function() {
return this.prevObject || this.constructor(null);
},
push:push,
sort:arr.sort,
splice:arr.splice
}, jQuery.extend = jQuery.fn.extend = function() {
var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, 
i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, 
i--); length > i; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], 
copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
clone = src && jQuery.isArray(src) ? src :[]) :clone = src && jQuery.isPlainObject(src) ? src :{}, 
target[name] = jQuery.extend(deep, clone, copy)) :void 0 !== copy && (target[name] = copy));
return target;
}, jQuery.extend({
expando:"jQuery" + (version + Math.random()).replace(/\D/g, ""),
isReady:!0,
error:function(msg) {
throw new Error(msg);
},
noop:function() {},
isFunction:function(obj) {
return "function" === jQuery.type(obj);
},
isArray:Array.isArray,
isWindow:function(obj) {
return null != obj && obj === obj.window;
},
isNumeric:function(obj) {
return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
},
isPlainObject:function(obj) {
return "object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj) ? !1 :obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ? !1 :!0;
},
isEmptyObject:function(obj) {
var name;
for (name in obj) return !1;
return !0;
},
type:function(obj) {
return null == obj ? obj + "" :"object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" :typeof obj;
},
globalEval:function(code) {
var script, indirect = eval;
code = jQuery.trim(code), code && (1 === code.indexOf("use strict") ? (script = document.createElement("script"), 
script.text = code, document.head.appendChild(script).parentNode.removeChild(script)) :indirect(code));
},
camelCase:function(string) {
return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
},
nodeName:function(elem, name) {
return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
},
each:function(obj, callback, args) {
var value, i = 0, length = obj.length, isArray = isArraylike(obj);
if (args) {
if (isArray) for (;length > i && (value = callback.apply(obj[i], args), value !== !1); i++) ; else for (i in obj) if (value = callback.apply(obj[i], args), 
value === !1) break;
} else if (isArray) for (;length > i && (value = callback.call(obj[i], i, obj[i]), 
value !== !1); i++) ; else for (i in obj) if (value = callback.call(obj[i], i, obj[i]), 
value === !1) break;
return obj;
},
trim:function(text) {
return null == text ? "" :(text + "").replace(rtrim, "");
},
makeArray:function(arr, results) {
var ret = results || [];
return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] :arr) :push.call(ret, arr)), 
ret;
},
inArray:function(elem, arr, i) {
return null == arr ? -1 :indexOf.call(arr, elem, i);
},
merge:function(first, second) {
for (var len = +second.length, j = 0, i = first.length; len > j; j++) first[i++] = second[j];
return first.length = i, first;
},
grep:function(elems, callback, invert) {
for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++) callbackInverse = !callback(elems[i], i), 
callbackInverse !== callbackExpect && matches.push(elems[i]);
return matches;
},
map:function(elems, callback, arg) {
var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
if (isArray) for (;length > i; i++) value = callback(elems[i], i, arg), null != value && ret.push(value); else for (i in elems) value = callback(elems[i], i, arg), 
null != value && ret.push(value);
return concat.apply([], ret);
},
guid:1,
proxy:function(fn, context) {
var tmp, args, proxy;
return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), 
jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function() {
return fn.apply(context || this, args.concat(slice.call(arguments)));
}, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) :void 0;
},
now:Date.now,
support:support
}), jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
class2type["[object " + name + "]"] = name.toLowerCase();
});
var Sizzle = function(window) {
function Sizzle(selector, context, results, seed) {
var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
if ((context ? context.ownerDocument || context :preferredDoc) !== document && setDocument(context), 
context = context || document, results = results || [], nodeType = context.nodeType, 
"string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
if (!seed && documentIsHTML) {
if (11 !== nodeType && (match = rquickExpr.exec(selector))) if (m = match[1]) {
if (9 === nodeType) {
if (elem = context.getElementById(m), !elem || !elem.parentNode) return results;
if (elem.id === m) return results.push(elem), results;
} else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), 
results;
} else {
if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), 
results;
if ((m = match[3]) && support.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), 
results;
}
if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
if (nid = old = expando, newContext = context, newSelector = 1 !== nodeType && selector, 
1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") :context.setAttribute("id", nid), 
nid = "[id='" + nid + "'] ", i = groups.length; i--; ) groups[i] = nid + toSelector(groups[i]);
newContext = rsibling.test(selector) && testContext(context.parentNode) || context, 
newSelector = groups.join(",");
}
if (newSelector) try {
return push.apply(results, newContext.querySelectorAll(newSelector)), results;
} catch (qsaError) {} finally {
old || context.removeAttribute("id");
}
}
}
return select(selector.replace(rtrim, "$1"), context, results, seed);
}
function createCache() {
function cache(key, value) {
return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
}
var keys = [];
return cache;
}
function markFunction(fn) {
return fn[expando] = !0, fn;
}
function assert(fn) {
var div = document.createElement("div");
try {
return !!fn(div);
} catch (e) {
return !1;
} finally {
div.parentNode && div.parentNode.removeChild(div), div = null;
}
}
function addHandle(attrs, handler) {
for (var arr = attrs.split("|"), i = attrs.length; i--; ) Expr.attrHandle[arr[i]] = handler;
}
function siblingCheck(a, b) {
var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
if (diff) return diff;
if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
return a ? 1 :-1;
}
function createInputPseudo(type) {
return function(elem) {
var name = elem.nodeName.toLowerCase();
return "input" === name && elem.type === type;
};
}
function createButtonPseudo(type) {
return function(elem) {
var name = elem.nodeName.toLowerCase();
return ("input" === name || "button" === name) && elem.type === type;
};
}
function createPositionalPseudo(fn) {
return markFunction(function(argument) {
return argument = +argument, markFunction(function(seed, matches) {
for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
});
});
}
function testContext(context) {
return context && "undefined" != typeof context.getElementsByTagName && context;
}
function setFilters() {}
function toSelector(tokens) {
for (var i = 0, len = tokens.length, selector = ""; len > i; i++) selector += tokens[i].value;
return selector;
}
function addCombinator(matcher, combinator, base) {
var dir = combinator.dir, checkNonElements = base && "parentNode" === dir, doneName = done++;
return combinator.first ? function(elem, context, xml) {
for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
} :function(elem, context, xml) {
var oldCache, outerCache, newCache = [ dirruns, doneName ];
if (xml) {
for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
} else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) {
if (outerCache = elem[expando] || (elem[expando] = {}), (oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
if (outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
}
};
}
function elementMatcher(matchers) {
return matchers.length > 1 ? function(elem, context, xml) {
for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
return !0;
} :matchers[0];
}
function multipleContexts(selector, contexts, results) {
for (var i = 0, len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
return results;
}
function condense(unmatched, map, filter, context, xml) {
for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++) (elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), 
mapped && map.push(i));
return newUnmatched;
}
function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), 
postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), 
markFunction(function(seed, results, context, xml) {
var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] :context, []), matcherIn = !preFilter || !seed && selector ? elems :condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter :preexisting || postFilter) ? [] :results :matcherIn;
if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap), 
postFilter(temp, [], context, xml), i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
if (seed) {
if (postFinder || preFilter) {
if (postFinder) {
for (temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
postFinder(null, matcherOut = [], temp, xml);
}
for (i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) :preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
}
} else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) :matcherOut), 
postFinder ? postFinder(null, results, matcherOut, xml) :push.apply(results, matcherOut);
});
}
function matcherFromTokens(tokens) {
for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 :0, matchContext = addCombinator(function(elem) {
return elem === checkContext;
}, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
return indexOf(checkContext, elem) > -1;
}, implicitRelative, !0), matchers = [ function(elem, context, xml) {
var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) :matchAnyContext(elem, context, xml));
return checkContext = null, ret;
} ]; len > i; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++) ;
return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
value:" " === tokens[i - 2].type ? "*" :""
})).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens));
}
matchers.push(matcher);
}
return elementMatcher(matchers);
}
function matcherFromGroupMatchers(elementMatchers, setMatchers) {
var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 :Math.random() || .1, len = elems.length;
for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
if (byElement && elem) {
for (j = 0; matcher = elementMatchers[j++]; ) if (matcher(elem, context, xml)) {
results.push(elem);
break;
}
outermost && (dirruns = dirrunsUnique);
}
bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem));
}
if (matchedCount += i, bySet && i !== matchedCount) {
for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
if (seed) {
if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
setMatched = condense(setMatched);
}
push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
}
return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), 
unmatched;
};
return bySet ? markFunction(superMatcher) :superMatcher;
}
var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
return a === b && (hasDuplicate = !0), 0;
}, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
for (var i = 0, len = list.length; len > i; i++) if (list[i] === elem) return i;
return -1;
}, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
ID:new RegExp("^#(" + characterEncoding + ")"),
CLASS:new RegExp("^\\.(" + characterEncoding + ")"),
TAG:new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
ATTR:new RegExp("^" + attributes),
PSEUDO:new RegExp("^" + pseudos),
CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
bool:new RegExp("^(?:" + booleans + ")$", "i"),
needsContext:new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
}, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
var high = "0x" + escaped - 65536;
return high !== high || escapedWhitespace ? escaped :0 > high ? String.fromCharCode(high + 65536) :String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
}, unloadHandler = function() {
setDocument();
};
try {
push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), 
arr[preferredDoc.childNodes.length].nodeType;
} catch (e) {
push = {
apply:arr.length ? function(target, els) {
push_native.apply(target, slice.call(els));
} :function(target, els) {
for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
target.length = j - 1;
}
};
}
support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
var documentElement = elem && (elem.ownerDocument || elem).documentElement;
return documentElement ? "HTML" !== documentElement.nodeName :!1;
}, setDocument = Sizzle.setDocument = function(node) {
var hasCompare, parent, doc = node ? node.ownerDocument || node :preferredDoc;
return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, 
docElem = doc.documentElement, parent = doc.defaultView, parent && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", unloadHandler, !1) :parent.attachEvent && parent.attachEvent("onunload", unloadHandler)), 
documentIsHTML = !isXML(doc), support.attributes = assert(function(div) {
return div.className = "i", !div.getAttribute("className");
}), support.getElementsByTagName = assert(function(div) {
return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length;
}), support.getElementsByClassName = rnative.test(doc.getElementsByClassName), support.getById = assert(function(div) {
return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length;
}), support.getById ? (Expr.find.ID = function(id, context) {
if ("undefined" != typeof context.getElementById && documentIsHTML) {
var m = context.getElementById(id);
return m && m.parentNode ? [ m ] :[];
}
}, Expr.filter.ID = function(id) {
var attrId = id.replace(runescape, funescape);
return function(elem) {
return elem.getAttribute("id") === attrId;
};
}) :(delete Expr.find.ID, Expr.filter.ID = function(id) {
var attrId = id.replace(runescape, funescape);
return function(elem) {
var node = "undefined" != typeof elem.getAttributeNode && elem.getAttributeNode("id");
return node && node.value === attrId;
};
}), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
return "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag) :support.qsa ? context.querySelectorAll(tag) :void 0;
} :function(tag, context) {
var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
if ("*" === tag) {
for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
return tmp;
}
return results;
}, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
return documentIsHTML ? context.getElementsByClassName(className) :void 0;
}, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function(div) {
docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\f]' msallowcapture=''><option selected=''></option></select>", 
div.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), 
div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), 
div.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), 
div.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]");
}), assert(function(div) {
var input = doc.createElement("input");
input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), 
div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 
div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), 
div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
})), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(div) {
support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), 
rbuggyMatches.push("!=", pseudos);
}), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), 
hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
var adown = 9 === a.nodeType ? a.documentElement :a, bup = b && b.parentNode;
return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) :a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
} :function(a, b) {
if (b) for (;b = b.parentNode; ) if (b === a) return !0;
return !1;
}, sortOrder = hasCompare ? function(a, b) {
if (a === b) return hasDuplicate = !0, 0;
var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
return compare ? compare :(compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :1, 
1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 :b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 :sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) :0 :4 & compare ? -1 :1);
} :function(a, b) {
if (a === b) return hasDuplicate = !0, 0;
var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
if (!aup || !bup) return a === doc ? -1 :b === doc ? 1 :aup ? -1 :bup ? 1 :sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) :0;
if (aup === bup) return siblingCheck(a, b);
for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
for (;ap[i] === bp[i]; ) i++;
return i ? siblingCheck(ap[i], bp[i]) :ap[i] === preferredDoc ? -1 :bp[i] === preferredDoc ? 1 :0;
}, doc) :document;
}, Sizzle.matches = function(expr, elements) {
return Sizzle(expr, null, null, elements);
}, Sizzle.matchesSelector = function(elem, expr) {
if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), 
!(!support.matchesSelector || !documentIsHTML || rbuggyMatches && rbuggyMatches.test(expr) || rbuggyQSA && rbuggyQSA.test(expr))) try {
var ret = matches.call(elem, expr);
if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
} catch (e) {}
return Sizzle(expr, document, null, [ elem ]).length > 0;
}, Sizzle.contains = function(context, elem) {
return (context.ownerDocument || context) !== document && setDocument(context), 
contains(context, elem);
}, Sizzle.attr = function(elem, name) {
(elem.ownerDocument || elem) !== document && setDocument(elem);
var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) :void 0;
return void 0 !== val ? val :support.attributes || !documentIsHTML ? elem.getAttribute(name) :(val = elem.getAttributeNode(name)) && val.specified ? val.value :null;
}, Sizzle.error = function(msg) {
throw new Error("Syntax error, unrecognized expression: " + msg);
}, Sizzle.uniqueSort = function(results) {
var elem, duplicates = [], j = 0, i = 0;
if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), 
results.sort(sortOrder), hasDuplicate) {
for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
for (;j--; ) results.splice(duplicates[j], 1);
}
return sortInput = null, results;
}, getText = Sizzle.getText = function(elem) {
var node, ret = "", i = 0, nodeType = elem.nodeType;
if (nodeType) {
if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
if ("string" == typeof elem.textContent) return elem.textContent;
for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
} else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
} else for (;node = elem[i++]; ) ret += getText(node);
return ret;
}, Expr = Sizzle.selectors = {
cacheLength:50,
createPseudo:markFunction,
match:matchExpr,
attrHandle:{},
find:{},
relative:{
">":{
dir:"parentNode",
first:!0
},
" ":{
dir:"parentNode"
},
"+":{
dir:"previousSibling",
first:!0
},
"~":{
dir:"previousSibling"
}
},
preFilter:{
ATTR:function(match) {
return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), 
"~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
},
CHILD:function(match) {
return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), 
match[4] = +(match[4] ? match[5] + (match[6] || 1) :2 * ("even" === match[3] || "odd" === match[3])), 
match[5] = +(match[7] + match[8] || "odd" === match[3])) :match[3] && Sizzle.error(match[0]), 
match;
},
PSEUDO:function(match) {
var excess, unquoted = !match[6] && match[2];
return matchExpr.CHILD.test(match[0]) ? null :(match[3] ? match[2] = match[4] || match[5] || "" :unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), 
match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
}
},
filter:{
TAG:function(nodeNameSelector) {
var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
return "*" === nodeNameSelector ? function() {
return !0;
} :function(elem) {
return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
};
},
CLASS:function(className) {
var pattern = classCache[className + " "];
return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
return pattern.test("string" == typeof elem.className && elem.className || "undefined" != typeof elem.getAttribute && elem.getAttribute("class") || "");
});
},
ATTR:function(name, operator, check) {
return function(elem) {
var result = Sizzle.attr(elem, name);
return null == result ? "!=" === operator :operator ? (result += "", "=" === operator ? result === check :"!=" === operator ? result !== check :"^=" === operator ? check && 0 === result.indexOf(check) :"*=" === operator ? check && result.indexOf(check) > -1 :"$=" === operator ? check && result.slice(-check.length) === check :"~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :"|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" :!1) :!0;
};
},
CHILD:function(type, what, argument, first, last) {
var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
return 1 === first && 0 === last ? function(elem) {
return !!elem.parentNode;
} :function(elem, context, xml) {
var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" :"previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
if (parent) {
if (simple) {
for (;dir; ) {
for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name :1 === node.nodeType) return !1;
start = dir = "only" === type && !start && "nextSibling";
}
return !0;
}
if (start = [ forward ? parent.firstChild :parent.lastChild ], forward && useCache) {
for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], 
nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], 
node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
outerCache[type] = [ dirruns, nodeIndex, diff ];
break;
}
} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1]; else for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name :1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ]), 
node !== elem)); ) ;
return diff -= last, diff === first || diff % first === 0 && diff / first >= 0;
}
};
},
PSEUDO:function(pseudo, argument) {
var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
return fn[expando] ? fn(argument) :fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ], 
Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf(seed, matched[i]), 
seed[idx] = !(matches[idx] = matched[i]);
}) :function(elem) {
return fn(elem, 0, args);
}) :fn;
}
},
pseudos:{
not:markFunction(function(selector) {
var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
}) :function(elem, context, xml) {
return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop();
};
}),
has:markFunction(function(selector) {
return function(elem) {
return Sizzle(selector, elem).length > 0;
};
}),
contains:markFunction(function(text) {
return text = text.replace(runescape, funescape), function(elem) {
return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
};
}),
lang:markFunction(function(lang) {
return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), 
lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
var elemLang;
do if (elemLang = documentIsHTML ? elem.lang :elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), 
elemLang === lang || 0 === elemLang.indexOf(lang + "-"); while ((elem = elem.parentNode) && 1 === elem.nodeType);
return !1;
};
}),
target:function(elem) {
var hash = window.location && window.location.hash;
return hash && hash.slice(1) === elem.id;
},
root:function(elem) {
return elem === docElem;
},
focus:function(elem) {
return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
},
enabled:function(elem) {
return elem.disabled === !1;
},
disabled:function(elem) {
return elem.disabled === !0;
},
checked:function(elem) {
var nodeName = elem.nodeName.toLowerCase();
return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
},
selected:function(elem) {
return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0;
},
empty:function(elem) {
for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
return !0;
},
parent:function(elem) {
return !Expr.pseudos.empty(elem);
},
header:function(elem) {
return rheader.test(elem.nodeName);
},
input:function(elem) {
return rinputs.test(elem.nodeName);
},
button:function(elem) {
var name = elem.nodeName.toLowerCase();
return "input" === name && "button" === elem.type || "button" === name;
},
text:function(elem) {
var attr;
return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
},
first:createPositionalPseudo(function() {
return [ 0 ];
}),
last:createPositionalPseudo(function(matchIndexes, length) {
return [ length - 1 ];
}),
eq:createPositionalPseudo(function(matchIndexes, length, argument) {
return [ 0 > argument ? argument + length :argument ];
}),
even:createPositionalPseudo(function(matchIndexes, length) {
for (var i = 0; length > i; i += 2) matchIndexes.push(i);
return matchIndexes;
}),
odd:createPositionalPseudo(function(matchIndexes, length) {
for (var i = 1; length > i; i += 2) matchIndexes.push(i);
return matchIndexes;
}),
lt:createPositionalPseudo(function(matchIndexes, length, argument) {
for (var i = 0 > argument ? argument + length :argument; --i >= 0; ) matchIndexes.push(i);
return matchIndexes;
}),
gt:createPositionalPseudo(function(matchIndexes, length, argument) {
for (var i = 0 > argument ? argument + length :argument; ++i < length; ) matchIndexes.push(i);
return matchIndexes;
})
}
}, Expr.pseudos.nth = Expr.pseudos.eq;
for (i in {
radio:!0,
checkbox:!0,
file:!0,
password:!0,
image:!0
}) Expr.pseudos[i] = createInputPseudo(i);
for (i in {
submit:!0,
reset:!0
}) Expr.pseudos[i] = createButtonPseudo(i);
return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(), 
tokenize = Sizzle.tokenize = function(selector, parseOnly) {
var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
if (cached) return parseOnly ? 0 :cached.slice(0);
for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
(!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), 
groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), 
tokens.push({
value:matched,
type:match[0].replace(rtrim, " ")
}), soFar = soFar.slice(matched.length));
for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), 
tokens.push({
value:matched,
type:type,
matches:match
}), soFar = soFar.slice(matched.length));
if (!matched) break;
}
return parseOnly ? soFar.length :soFar ? Sizzle.error(selector) :tokenCache(selector, groups).slice(0);
}, compile = Sizzle.compile = function(selector, match) {
var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
if (!cached) {
for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]), 
cached[expando] ? setMatchers.push(cached) :elementMatchers.push(cached);
cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), 
cached.selector = selector;
}
return cached;
}, select = Sizzle.select = function(selector, context, results, seed) {
var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
if (results = results || [], 1 === match.length) {
if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], 
!context) return results;
compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
}
for (i = matchExpr.needsContext.test(selector) ? 0 :tokens.length; i-- && (token = tokens[i], 
!Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), 
results;
break;
}
}
return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), 
results;
}, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, 
support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(div1) {
return 1 & div1.compareDocumentPosition(document.createElement("div"));
}), assert(function(div) {
return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href");
}) || addHandle("type|href|height|width", function(elem, name, isXML) {
return isXML ? void 0 :elem.getAttribute(name, "type" === name.toLowerCase() ? 1 :2);
}), support.attributes && assert(function(div) {
return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value");
}) || addHandle("value", function(elem, name, isXML) {
return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 :elem.defaultValue;
}), assert(function(div) {
return null == div.getAttribute("disabled");
}) || addHandle(booleans, function(elem, name, isXML) {
var val;
return isXML ? void 0 :elem[name] === !0 ? name.toLowerCase() :(val = elem.getAttributeNode(name)) && val.specified ? val.value :null;
}), Sizzle;
}(window);
jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, 
jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, 
jQuery.contains = Sizzle.contains;
var rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, risSimple = /^.[^:#\[\.,]*$/;
jQuery.filter = function(expr, elems, not) {
var elem = elems[0];
return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] :[] :jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
return 1 === elem.nodeType;
}));
}, jQuery.fn.extend({
find:function(selector) {
var i, len = this.length, ret = [], self = this;
if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
for (i = 0; len > i; i++) if (jQuery.contains(self[i], this)) return !0;
}));
for (i = 0; len > i; i++) jQuery.find(selector, self[i], ret);
return ret = this.pushStack(len > 1 ? jQuery.unique(ret) :ret), ret.selector = this.selector ? this.selector + " " + selector :selector, 
ret;
},
filter:function(selector) {
return this.pushStack(winnow(this, selector || [], !1));
},
not:function(selector) {
return this.pushStack(winnow(this, selector || [], !0));
},
is:function(selector) {
return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) :selector || [], !1).length;
}
});
var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
var match, elem;
if (!selector) return this;
if ("string" == typeof selector) {
if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [ null, selector, null ] :rquickExpr.exec(selector), 
!match || !match[1] && context) return !context || context.jquery ? (context || rootjQuery).find(selector) :this.constructor(context).find(selector);
if (match[1]) {
if (context = context instanceof jQuery ? context[0] :context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context :document, !0)), 
rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) :this.attr(match, context[match]);
return this;
}
return elem = document.getElementById(match[2]), elem && elem.parentNode && (this.length = 1, 
this[0] = elem), this.context = document, this.selector = selector, this;
}
return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, 
this) :jQuery.isFunction(selector) ? "undefined" != typeof rootjQuery.ready ? rootjQuery.ready(selector) :selector(jQuery) :(void 0 !== selector.selector && (this.selector = selector.selector, 
this.context = selector.context), jQuery.makeArray(selector, this));
};
init.prototype = jQuery.fn, rootjQuery = jQuery(document);
var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
children:!0,
contents:!0,
next:!0,
prev:!0
};
jQuery.extend({
dir:function(elem, dir, until) {
for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; ) if (1 === elem.nodeType) {
if (truncate && jQuery(elem).is(until)) break;
matched.push(elem);
}
return matched;
},
sibling:function(n, elem) {
for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
return matched;
}
}), jQuery.fn.extend({
has:function(target) {
var targets = jQuery(target, this), l = targets.length;
return this.filter(function() {
for (var i = 0; l > i; i++) if (jQuery.contains(this, targets[i])) return !0;
});
},
closest:function(selectors, context) {
for (var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) :0; l > i; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
matched.push(cur);
break;
}
return this.pushStack(matched.length > 1 ? jQuery.unique(matched) :matched);
},
index:function(elem) {
return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) :indexOf.call(this, elem.jquery ? elem[0] :elem) :this[0] && this[0].parentNode ? this.first().prevAll().length :-1;
},
add:function(selector, context) {
return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
},
addBack:function(selector) {
return this.add(null == selector ? this.prevObject :this.prevObject.filter(selector));
}
}), jQuery.each({
parent:function(elem) {
var parent = elem.parentNode;
return parent && 11 !== parent.nodeType ? parent :null;
},
parents:function(elem) {
return jQuery.dir(elem, "parentNode");
},
parentsUntil:function(elem, i, until) {
return jQuery.dir(elem, "parentNode", until);
},
next:function(elem) {
return sibling(elem, "nextSibling");
},
prev:function(elem) {
return sibling(elem, "previousSibling");
},
nextAll:function(elem) {
return jQuery.dir(elem, "nextSibling");
},
prevAll:function(elem) {
return jQuery.dir(elem, "previousSibling");
},
nextUntil:function(elem, i, until) {
return jQuery.dir(elem, "nextSibling", until);
},
prevUntil:function(elem, i, until) {
return jQuery.dir(elem, "previousSibling", until);
},
siblings:function(elem) {
return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
},
children:function(elem) {
return jQuery.sibling(elem.firstChild);
},
contents:function(elem) {
return elem.contentDocument || jQuery.merge([], elem.childNodes);
}
}, function(name, fn) {
jQuery.fn[name] = function(until, selector) {
var matched = jQuery.map(this, fn, until);
return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), 
this.length > 1 && (guaranteedUnique[name] || jQuery.unique(matched), rparentsprev.test(name) && matched.reverse()), 
this.pushStack(matched);
};
});
var rnotwhite = /\S+/g, optionsCache = {};
jQuery.Callbacks = function(options) {
options = "string" == typeof options ? optionsCache[options] || createOptions(options) :jQuery.extend({}, options);
var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, 
firingStart = 0, firingLength = list.length, firing = !0; list && firingLength > firingIndex; firingIndex++) if (list[firingIndex].apply(data[0], data[1]) === !1 && options.stopOnFalse) {
memory = !1;
break;
}
firing = !1, list && (stack ? stack.length && fire(stack.shift()) :memory ? list = [] :self.disable());
}, self = {
add:function() {
if (list) {
var start = list.length;
!function add(args) {
jQuery.each(args, function(_, arg) {
var type = jQuery.type(arg);
"function" === type ? options.unique && self.has(arg) || list.push(arg) :arg && arg.length && "string" !== type && add(arg);
});
}(arguments), firing ? firingLength = list.length :memory && (firingStart = start, 
fire(memory));
}
return this;
},
remove:function() {
return list && jQuery.each(arguments, function(_, arg) {
for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1), 
firing && (firingLength >= index && firingLength--, firingIndex >= index && firingIndex--);
}), this;
},
has:function(fn) {
return fn ? jQuery.inArray(fn, list) > -1 :!(!list || !list.length);
},
empty:function() {
return list = [], firingLength = 0, this;
},
disable:function() {
return list = stack = memory = void 0, this;
},
disabled:function() {
return !list;
},
lock:function() {
return stack = void 0, memory || self.disable(), this;
},
locked:function() {
return !stack;
},
fireWith:function(context, args) {
return !list || fired && !stack || (args = args || [], args = [ context, args.slice ? args.slice() :args ], 
firing ? stack.push(args) :fire(args)), this;
},
fire:function() {
return self.fireWith(this, arguments), this;
},
fired:function() {
return !!fired;
}
};
return self;
}, jQuery.extend({
Deferred:function(func) {
var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
state:function() {
return state;
},
always:function() {
return deferred.done(arguments).fail(arguments), this;
},
then:function() {
var fns = arguments;
return jQuery.Deferred(function(newDefer) {
jQuery.each(tuples, function(i, tuple) {
var fn = jQuery.isFunction(fns[i]) && fns[i];
deferred[tuple[1]](function() {
var returned = fn && fn.apply(this, arguments);
returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) :newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() :this, fn ? [ returned ] :arguments);
});
}), fns = null;
}).promise();
},
promise:function(obj) {
return null != obj ? jQuery.extend(obj, promise) :promise;
}
}, deferred = {};
return promise.pipe = promise.then, jQuery.each(tuples, function(i, tuple) {
var list = tuple[2], stateString = tuple[3];
promise[tuple[1]] = list.add, stateString && list.add(function() {
state = stateString;
}, tuples[1 ^ i][2].disable, tuples[2][2].lock), deferred[tuple[0]] = function() {
return deferred[tuple[0] + "With"](this === deferred ? promise :this, arguments), 
this;
}, deferred[tuple[0] + "With"] = list.fireWith;
}), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
},
when:function(subordinate) {
var progressValues, progressContexts, resolveContexts, i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length :0, deferred = 1 === remaining ? subordinate :jQuery.Deferred(), updateFunc = function(i, contexts, values) {
return function(value) {
contexts[i] = this, values[i] = arguments.length > 1 ? slice.call(arguments) :value, 
values === progressValues ? deferred.notifyWith(contexts, values) :--remaining || deferred.resolveWith(contexts, values);
};
};
if (length > 1) for (progressValues = new Array(length), progressContexts = new Array(length), 
resolveContexts = new Array(length); length > i; i++) resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) :--remaining;
return remaining || deferred.resolveWith(resolveContexts, resolveValues), deferred.promise();
}
});
var readyList;
jQuery.fn.ready = function(fn) {
return jQuery.ready.promise().done(fn), this;
}, jQuery.extend({
isReady:!1,
readyWait:1,
holdReady:function(hold) {
hold ? jQuery.readyWait++ :jQuery.ready(!0);
},
ready:function(wait) {
(wait === !0 ? --jQuery.readyWait :jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || (readyList.resolveWith(document, [ jQuery ]), 
jQuery.fn.triggerHandler && (jQuery(document).triggerHandler("ready"), jQuery(document).off("ready"))));
}
}), jQuery.ready.promise = function(obj) {
return readyList || (readyList = jQuery.Deferred(), "complete" === document.readyState ? setTimeout(jQuery.ready) :(document.addEventListener("DOMContentLoaded", completed, !1), 
window.addEventListener("load", completed, !1))), readyList.promise(obj);
}, jQuery.ready.promise();
var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
var i = 0, len = elems.length, bulk = null == key;
if ("object" === jQuery.type(key)) {
chainable = !0;
for (i in key) jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw);
} else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), 
bulk && (raw ? (fn.call(elems, value), fn = null) :(bulk = fn, fn = function(elem, key, value) {
return bulk.call(jQuery(elem), value);
})), fn)) for (;len > i; i++) fn(elems[i], key, raw ? value :value.call(elems[i], i, fn(elems[i], key)));
return chainable ? elems :bulk ? fn.call(elems) :len ? fn(elems[0], key) :emptyGet;
};
jQuery.acceptData = function(owner) {
return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType;
}, Data.uid = 1, Data.accepts = jQuery.acceptData, Data.prototype = {
key:function(owner) {
if (!Data.accepts(owner)) return 0;
var descriptor = {}, unlock = owner[this.expando];
if (!unlock) {
unlock = Data.uid++;
try {
descriptor[this.expando] = {
value:unlock
}, Object.defineProperties(owner, descriptor);
} catch (e) {
descriptor[this.expando] = unlock, jQuery.extend(owner, descriptor);
}
}
return this.cache[unlock] || (this.cache[unlock] = {}), unlock;
},
set:function(owner, data, value) {
var prop, unlock = this.key(owner), cache = this.cache[unlock];
if ("string" == typeof data) cache[data] = value; else if (jQuery.isEmptyObject(cache)) jQuery.extend(this.cache[unlock], data); else for (prop in data) cache[prop] = data[prop];
return cache;
},
get:function(owner, key) {
var cache = this.cache[this.key(owner)];
return void 0 === key ? cache :cache[key];
},
access:function(owner, key, value) {
var stored;
return void 0 === key || key && "string" == typeof key && void 0 === value ? (stored = this.get(owner, key), 
void 0 !== stored ? stored :this.get(owner, jQuery.camelCase(key))) :(this.set(owner, key, value), 
void 0 !== value ? value :key);
},
remove:function(owner, key) {
var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
if (void 0 === key) this.cache[unlock] = {}; else {
jQuery.isArray(key) ? name = key.concat(key.map(jQuery.camelCase)) :(camel = jQuery.camelCase(key), 
key in cache ? name = [ key, camel ] :(name = camel, name = name in cache ? [ name ] :name.match(rnotwhite) || [])), 
i = name.length;
for (;i--; ) delete cache[name[i]];
}
},
hasData:function(owner) {
return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
},
discard:function(owner) {
owner[this.expando] && delete this.cache[owner[this.expando]];
}
};
var data_priv = new Data(), data_user = new Data(), rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
jQuery.extend({
hasData:function(elem) {
return data_user.hasData(elem) || data_priv.hasData(elem);
},
data:function(elem, name, data) {
return data_user.access(elem, name, data);
},
removeData:function(elem, name) {
data_user.remove(elem, name);
},
_data:function(elem, name, data) {
return data_priv.access(elem, name, data);
},
_removeData:function(elem, name) {
data_priv.remove(elem, name);
}
}), jQuery.fn.extend({
data:function(key, value) {
var i, name, data, elem = this[0], attrs = elem && elem.attributes;
if (void 0 === key) {
if (this.length && (data = data_user.get(elem), 1 === elem.nodeType && !data_priv.get(elem, "hasDataAttrs"))) {
for (i = attrs.length; i--; ) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), 
dataAttr(elem, name, data[name])));
data_priv.set(elem, "hasDataAttrs", !0);
}
return data;
}
return "object" == typeof key ? this.each(function() {
data_user.set(this, key);
}) :access(this, function(value) {
var data, camelKey = jQuery.camelCase(key);
if (elem && void 0 === value) {
if (data = data_user.get(elem, key), void 0 !== data) return data;
if (data = data_user.get(elem, camelKey), void 0 !== data) return data;
if (data = dataAttr(elem, camelKey, void 0), void 0 !== data) return data;
} else this.each(function() {
var data = data_user.get(this, camelKey);
data_user.set(this, camelKey, value), -1 !== key.indexOf("-") && void 0 !== data && data_user.set(this, key, value);
});
}, null, value, arguments.length > 1, null, !0);
},
removeData:function(key) {
return this.each(function() {
data_user.remove(this, key);
});
}
}), jQuery.extend({
queue:function(elem, type, data) {
var queue;
return elem ? (type = (type || "fx") + "queue", queue = data_priv.get(elem, type), 
data && (!queue || jQuery.isArray(data) ? queue = data_priv.access(elem, type, jQuery.makeArray(data)) :queue.push(data)), 
queue || []) :void 0;
},
dequeue:function(elem, type) {
type = type || "fx";
var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
jQuery.dequeue(elem, type);
};
"inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), 
delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
},
_queueHooks:function(elem, type) {
var key = type + "queueHooks";
return data_priv.get(elem, key) || data_priv.access(elem, key, {
empty:jQuery.Callbacks("once memory").add(function() {
data_priv.remove(elem, [ type + "queue", key ]);
})
});
}
}), jQuery.fn.extend({
queue:function(type, data) {
var setter = 2;
return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) :void 0 === data ? this :this.each(function() {
var queue = jQuery.queue(this, type, data);
jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
});
},
dequeue:function(type) {
return this.each(function() {
jQuery.dequeue(this, type);
});
},
clearQueue:function(type) {
return this.queue(type || "fx", []);
},
promise:function(type, obj) {
var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
--count || defer.resolveWith(elements, [ elements ]);
};
for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) tmp = data_priv.get(elements[i], type + "queueHooks"), 
tmp && tmp.empty && (count++, tmp.empty.add(resolve));
return resolve(), defer.promise(obj);
}
});
var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, cssExpand = [ "Top", "Right", "Bottom", "Left" ], isHidden = function(elem, el) {
return elem = el || elem, "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem);
}, rcheckableType = /^(?:checkbox|radio)$/i;
!function() {
var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), 
div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, 
div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
}();
var strundefined = "undefined";
support.focusinBubbles = "onfocusin" in window;
var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
jQuery.event = {
global:{},
add:function(elem, types, handler, data, selector) {
var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
if (elemData) for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, 
selector = handleObjIn.selector), handler.guid || (handler.guid = jQuery.guid++), 
(events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) :void 0;
}), types = (types || "").match(rnotwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [], 
type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, 
type = (selector ? special.delegateType :special.bindType) || type, special = jQuery.event.special[type] || {}, 
handleObj = jQuery.extend({
type:type,
origType:origType,
data:data,
handler:handler,
guid:handler.guid,
selector:selector,
needsContext:selector && jQuery.expr.match.needsContext.test(selector),
namespace:namespaces.join(".")
}, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, 
special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle, !1)), 
special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), 
selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) :handlers.push(handleObj), 
jQuery.event.global[type] = !0);
},
remove:function(elem, types, handler, selector, mappedTypes) {
var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
if (elemData && (events = elemData.events)) {
for (types = (types || "").match(rnotwhite) || [ "" ], t = types.length; t--; ) if (tmp = rtypenamespace.exec(types[t]) || [], 
type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType :special.bindType) || type, 
handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), 
handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), 
delete events[type]);
} else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
jQuery.isEmptyObject(events) && (delete elemData.handle, data_priv.remove(elem, "events"));
}
},
trigger:function(event, data, elem, onlyHandlers) {
var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type :event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") :[];
if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (namespaces = type.split("."), 
type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, 
event = event[jQuery.expando] ? event :new jQuery.Event(type, "object" == typeof event && event), 
event.isTrigger = onlyHandlers ? 2 :3, event.namespace = namespaces.join("."), event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :null, 
event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] :jQuery.makeArray(data, [ event ]), 
special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), 
tmp = cur;
tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
}
for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) event.type = i > 1 ? bubbleType :special.bindType || type, 
handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle"), 
handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && jQuery.acceptData(cur) && (event.result = handle.apply(cur, data), 
event.result === !1 && event.preventDefault());
return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !jQuery.acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], 
tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, 
tmp && (elem[ontype] = tmp)), event.result;
}
},
dispatch:function(event) {
event = jQuery.event.fix(event);
var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
if (args[0] = event, event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem, 
j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) && (event.handleObj = handleObj, 
event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), 
void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
return special.postDispatch && special.postDispatch.call(this, event), event.result;
}
},
handlers:function(event, handlers) {
var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type)) for (;cur !== this; cur = cur.parentNode || this) if (cur.disabled !== !0 || "click" !== event.type) {
for (matches = [], i = 0; delegateCount > i; i++) handleObj = handlers[i], sel = handleObj.selector + " ", 
void 0 === matches[sel] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 :jQuery.find(sel, this, null, [ cur ]).length), 
matches[sel] && matches.push(handleObj);
matches.length && handlerQueue.push({
elem:cur,
handlers:matches
});
}
return delegateCount < handlers.length && handlerQueue.push({
elem:this,
handlers:handlers.slice(delegateCount)
}), handlerQueue;
},
props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
fixHooks:{},
keyHooks:{
props:"char charCode key keyCode".split(" "),
filter:function(event, original) {
return null == event.which && (event.which = null != original.charCode ? original.charCode :original.keyCode), 
event;
}
},
mouseHooks:{
props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
filter:function(event, original) {
var eventDoc, doc, body, button = original.button;
return null == event.pageX && null != original.clientX && (eventDoc = event.target.ownerDocument || document, 
doc = eventDoc.documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), 
event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)), 
event.which || void 0 === button || (event.which = 1 & button ? 1 :2 & button ? 3 :4 & button ? 2 :0), 
event;
}
},
fix:function(event) {
if (event[jQuery.expando]) return event;
var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks :rkeyEvent.test(type) ? this.keyHooks :{}), 
copy = fixHook.props ? this.props.concat(fixHook.props) :this.props, event = new jQuery.Event(originalEvent), 
i = copy.length; i--; ) prop = copy[i], event[prop] = originalEvent[prop];
return event.target || (event.target = document), 3 === event.target.nodeType && (event.target = event.target.parentNode), 
fixHook.filter ? fixHook.filter(event, originalEvent) :event;
},
special:{
load:{
noBubble:!0
},
focus:{
trigger:function() {
return this !== safeActiveElement() && this.focus ? (this.focus(), !1) :void 0;
},
delegateType:"focusin"
},
blur:{
trigger:function() {
return this === safeActiveElement() && this.blur ? (this.blur(), !1) :void 0;
},
delegateType:"focusout"
},
click:{
trigger:function() {
return "checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), 
!1) :void 0;
},
_default:function(event) {
return jQuery.nodeName(event.target, "a");
}
},
beforeunload:{
postDispatch:function(event) {
void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
}
}
},
simulate:function(type, elem, event, bubble) {
var e = jQuery.extend(new jQuery.Event(), event, {
type:type,
isSimulated:!0,
originalEvent:{}
});
bubble ? jQuery.event.trigger(e, null, elem) :jQuery.event.dispatch.call(elem, e), 
e.isDefaultPrevented() && event.preventDefault();
}
}, jQuery.removeEvent = function(elem, type, handle) {
elem.removeEventListener && elem.removeEventListener(type, handle, !1);
}, jQuery.Event = function(src, props) {
return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, 
this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue :returnFalse) :this.type = src, 
props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), 
this[jQuery.expando] = !0, void 0) :new jQuery.Event(src, props);
}, jQuery.Event.prototype = {
isDefaultPrevented:returnFalse,
isPropagationStopped:returnFalse,
isImmediatePropagationStopped:returnFalse,
preventDefault:function() {
var e = this.originalEvent;
this.isDefaultPrevented = returnTrue, e && e.preventDefault && e.preventDefault();
},
stopPropagation:function() {
var e = this.originalEvent;
this.isPropagationStopped = returnTrue, e && e.stopPropagation && e.stopPropagation();
},
stopImmediatePropagation:function() {
var e = this.originalEvent;
this.isImmediatePropagationStopped = returnTrue, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), 
this.stopPropagation();
}
}, jQuery.each({
mouseenter:"mouseover",
mouseleave:"mouseout",
pointerenter:"pointerover",
pointerleave:"pointerout"
}, function(orig, fix) {
jQuery.event.special[orig] = {
delegateType:fix,
bindType:fix,
handle:function(event) {
var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, 
ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
}
};
}), support.focusinBubbles || jQuery.each({
focus:"focusin",
blur:"focusout"
}, function(orig, fix) {
var handler = function(event) {
jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0);
};
jQuery.event.special[fix] = {
setup:function() {
var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
attaches || doc.addEventListener(orig, handler, !0), data_priv.access(doc, fix, (attaches || 0) + 1);
},
teardown:function() {
var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
attaches ? data_priv.access(doc, fix, attaches) :(doc.removeEventListener(orig, handler, !0), 
data_priv.remove(doc, fix));
}
};
}), jQuery.fn.extend({
on:function(types, selector, data, fn, one) {
var origFn, type;
if ("object" == typeof types) {
"string" != typeof selector && (data = data || selector, selector = void 0);
for (type in types) this.on(type, selector, data, types[type], one);
return this;
}
if (null == data && null == fn ? (fn = selector, data = selector = void 0) :null == fn && ("string" == typeof selector ? (fn = data, 
data = void 0) :(fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse; else if (!fn) return this;
return 1 === one && (origFn = fn, fn = function(event) {
return jQuery().off(event), origFn.apply(this, arguments);
}, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), this.each(function() {
jQuery.event.add(this, types, fn, data, selector);
});
},
one:function(types, selector, data, fn) {
return this.on(types, selector, data, fn, 1);
},
off:function(types, selector, fn) {
var handleObj, type;
if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, 
jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace :handleObj.origType, handleObj.selector, handleObj.handler), 
this;
if ("object" == typeof types) {
for (type in types) this.off(type, selector, types[type]);
return this;
}
return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), 
fn === !1 && (fn = returnFalse), this.each(function() {
jQuery.event.remove(this, types, fn, selector);
});
},
trigger:function(type, data) {
return this.each(function() {
jQuery.event.trigger(type, data, this);
});
},
triggerHandler:function(type, data) {
var elem = this[0];
return elem ? jQuery.event.trigger(type, data, elem, !0) :void 0;
}
});
var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
option:[ 1, "<select multiple='multiple'>", "</select>" ],
thead:[ 1, "<table>", "</table>" ],
col:[ 2, "<table><colgroup>", "</colgroup></table>" ],
tr:[ 2, "<table><tbody>", "</tbody></table>" ],
td:[ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
_default:[ 0, "", "" ]
};
wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
wrapMap.th = wrapMap.td, jQuery.extend({
clone:function(elem, dataAndEvents, deepDataAndEvents) {
var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) for (destElements = getAll(clone), 
srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++) fixInput(srcElements[i], destElements[i]);
if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem), 
destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++) cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), 
clone;
},
buildFragment:function(elems, context, scripts, selection) {
for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; l > i; i++) if (elem = elems[i], 
elem || 0 === elem) if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] :elem); else if (rhtml.test(elem)) {
for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(), 
wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], 
j = wrap[0]; j--; ) tmp = tmp.lastChild;
jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
} else nodes.push(context.createTextNode(elem));
for (fragment.textContent = "", i = 0; elem = nodes[i++]; ) if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), 
tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), 
scripts)) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
return fragment;
},
cleanData:function(elems) {
for (var data, elem, type, key, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) {
if (jQuery.acceptData(elem) && (key = elem[data_priv.expando], key && (data = data_priv.cache[key]))) {
if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) :jQuery.removeEvent(elem, type, data.handle);
data_priv.cache[key] && delete data_priv.cache[key];
}
delete data_user.cache[elem[data_user.expando]];
}
}
}), jQuery.fn.extend({
text:function(value) {
return access(this, function(value) {
return void 0 === value ? jQuery.text(this) :this.empty().each(function() {
(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = value);
});
}, null, value, arguments.length);
},
append:function() {
return this.domManip(arguments, function(elem) {
if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
var target = manipulationTarget(this, elem);
target.appendChild(elem);
}
});
},
prepend:function() {
return this.domManip(arguments, function(elem) {
if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
var target = manipulationTarget(this, elem);
target.insertBefore(elem, target.firstChild);
}
});
},
before:function() {
return this.domManip(arguments, function(elem) {
this.parentNode && this.parentNode.insertBefore(elem, this);
});
},
after:function() {
return this.domManip(arguments, function(elem) {
this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
});
},
remove:function(selector, keepData) {
for (var elem, elems = selector ? jQuery.filter(selector, this) :this, i = 0; null != (elem = elems[i]); i++) keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)), 
elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), 
elem.parentNode.removeChild(elem));
return this;
},
empty:function() {
for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
elem.textContent = "");
return this;
},
clone:function(dataAndEvents, deepDataAndEvents) {
return dataAndEvents = null == dataAndEvents ? !1 :dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents :deepDataAndEvents, 
this.map(function() {
return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
});
},
html:function(value) {
return access(this, function(value) {
var elem = this[0] || {}, i = 0, l = this.length;
if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
value = value.replace(rxhtmlTag, "<$1></$2>");
try {
for (;l > i; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
elem.innerHTML = value);
elem = 0;
} catch (e) {}
}
elem && this.empty().append(value);
}, null, value, arguments.length);
},
replaceWith:function() {
var arg = arguments[0];
return this.domManip(arguments, function(elem) {
arg = this.parentNode, jQuery.cleanData(getAll(this)), arg && arg.replaceChild(elem, this);
}), arg && (arg.length || arg.nodeType) ? this :this.remove();
},
detach:function(selector) {
return this.remove(selector, !0);
},
domManip:function(args, callback) {
args = concat.apply([], args);
var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return this.each(function(index) {
var self = set.eq(index);
isFunction && (args[0] = value.call(this, index, self.html())), self.domManip(args, callback);
});
if (l && (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, this), 
first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), 
first)) {
for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++) node = fragment, 
i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), 
callback.call(this[i], node, i);
if (hasScripts) for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), 
i = 0; hasScripts > i; i++) node = scripts[i], rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) :jQuery.globalEval(node.textContent.replace(rcleanScript, "")));
}
return this;
}
}), jQuery.each({
appendTo:"append",
prependTo:"prepend",
insertBefore:"before",
insertAfter:"after",
replaceAll:"replaceWith"
}, function(name, original) {
jQuery.fn[name] = function(selector) {
for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++) elems = i === last ? this :this.clone(!0), 
jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
return this.pushStack(ret);
};
});
var iframe, elemdisplay = {}, rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function(elem) {
return elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) :window.getComputedStyle(elem, null);
};
!function() {
function computePixelPositionAndBoxSizingReliable() {
div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
div.innerHTML = "", docElem.appendChild(container);
var divStyle = window.getComputedStyle(div, null);
pixelPositionVal = "1%" !== divStyle.top, boxSizingReliableVal = "4px" === divStyle.width, 
docElem.removeChild(container);
}
var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", 
support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", 
container.appendChild(div), window.getComputedStyle && jQuery.extend(support, {
pixelPosition:function() {
return computePixelPositionAndBoxSizingReliable(), pixelPositionVal;
},
boxSizingReliable:function() {
return null == boxSizingReliableVal && computePixelPositionAndBoxSizingReliable(), 
boxSizingReliableVal;
},
reliableMarginRight:function() {
var ret, marginDiv = div.appendChild(document.createElement("div"));
return marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
marginDiv.style.marginRight = marginDiv.style.width = "0", div.style.width = "1px", 
docElem.appendChild(container), ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight), 
docElem.removeChild(container), div.removeChild(marginDiv), ret;
}
}));
}(), jQuery.swap = function(elem, options, callback, args) {
var ret, name, old = {};
for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
ret = callback.apply(elem, args || []);
for (name in options) elem.style[name] = old[name];
return ret;
};
var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
position:"absolute",
visibility:"hidden",
display:"block"
}, cssNormalTransform = {
letterSpacing:"0",
fontWeight:"400"
}, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
jQuery.extend({
cssHooks:{
opacity:{
get:function(elem, computed) {
if (computed) {
var ret = curCSS(elem, "opacity");
return "" === ret ? "1" :ret;
}
}
}
},
cssNumber:{
columnCount:!0,
fillOpacity:!0,
flexGrow:!0,
flexShrink:!0,
fontWeight:!0,
lineHeight:!0,
opacity:!0,
order:!0,
orphans:!0,
widows:!0,
zIndex:!0,
zoom:!0
},
cssProps:{
"float":"cssFloat"
},
style:function(elem, name, value, extra) {
if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)), 
hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret :style[name] :(type = typeof value, 
"string" === type && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), 
type = "number"), null != value && value === value && ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), 
support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), 
hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), 
void 0);
}
},
css:function(elem, name, extra, styles) {
var val, num, hooks, origName = jQuery.camelCase(name);
return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)), 
hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), 
void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), 
"" === extra || extra ? (num = parseFloat(val), extra === !0 || jQuery.isNumeric(num) ? num || 0 :val) :val;
}
}), jQuery.each([ "height", "width" ], function(i, name) {
jQuery.cssHooks[name] = {
get:function(elem, computed, extra) {
return computed ? rdisplayswap.test(jQuery.css(elem, "display")) && 0 === elem.offsetWidth ? jQuery.swap(elem, cssShow, function() {
return getWidthOrHeight(elem, name, extra);
}) :getWidthOrHeight(elem, name, extra) :void 0;
},
set:function(elem, value, extra) {
var styles = extra && getStyles(elem);
return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) :0);
}
};
}), jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
return computed ? jQuery.swap(elem, {
display:"inline-block"
}, curCSS, [ elem, "marginRight" ]) :void 0;
}), jQuery.each({
margin:"",
padding:"",
border:"Width"
}, function(prefix, suffix) {
jQuery.cssHooks[prefix + suffix] = {
expand:function(value) {
for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") :[ value ]; 4 > i; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
return expanded;
}
}, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
}), jQuery.fn.extend({
css:function(name, value) {
return access(this, function(elem, name, value) {
var styles, len, map = {}, i = 0;
if (jQuery.isArray(name)) {
for (styles = getStyles(elem), len = name.length; len > i; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
return map;
}
return void 0 !== value ? jQuery.style(elem, name, value) :jQuery.css(elem, name);
}, name, value, arguments.length > 1);
},
show:function() {
return showHide(this, !0);
},
hide:function() {
return showHide(this);
},
toggle:function(state) {
return "boolean" == typeof state ? state ? this.show() :this.hide() :this.each(function() {
isHidden(this) ? jQuery(this).show() :jQuery(this).hide();
});
}
}), jQuery.Tween = Tween, Tween.prototype = {
constructor:Tween,
init:function(elem, options, prop, end, easing, unit) {
this.elem = elem, this.prop = prop, this.easing = easing || "swing", this.options = options, 
this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" :"px");
},
cur:function() {
var hooks = Tween.propHooks[this.prop];
return hooks && hooks.get ? hooks.get(this) :Tween.propHooks._default.get(this);
},
run:function(percent) {
var eased, hooks = Tween.propHooks[this.prop];
return this.pos = eased = this.options.duration ? jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) :percent, 
this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
hooks && hooks.set ? hooks.set(this) :Tween.propHooks._default.set(this), this;
}
}, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
_default:{
get:function(tween) {
var result;
return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, ""), 
result && "auto" !== result ? result :0) :tween.elem[tween.prop];
},
set:function(tween) {
jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) :tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) :tween.elem[tween.prop] = tween.now;
}
}
}, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
set:function(tween) {
tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
}
}, jQuery.easing = {
linear:function(p) {
return p;
},
swing:function(p) {
return .5 - Math.cos(p * Math.PI) / 2;
}
}, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
"*":[ function(prop, value) {
var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" :"px"), start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
if (start && start[3] !== unit) {
unit = unit || start[3], parts = parts || [], start = +target || 1;
do scale = scale || ".5", start /= scale, jQuery.style(tween.elem, prop, start + unit); while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations);
}
return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, 
tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] :+parts[2]), tween;
} ]
};
jQuery.Animation = jQuery.extend(Animation, {
tweener:function(props, callback) {
jQuery.isFunction(props) ? (callback = props, props = [ "*" ]) :props = props.split(" ");
for (var prop, index = 0, length = props.length; length > index; index++) prop = props[index], 
tweeners[prop] = tweeners[prop] || [], tweeners[prop].unshift(callback);
},
prefilter:function(callback, prepend) {
prepend ? animationPrefilters.unshift(callback) :animationPrefilters.push(callback);
}
}), jQuery.speed = function(speed, easing, fn) {
var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) :{
complete:fn || !fn && easing || jQuery.isFunction(speed) && speed,
duration:speed,
easing:fn && easing || easing && !jQuery.isFunction(easing) && easing
};
return opt.duration = jQuery.fx.off ? 0 :"number" == typeof opt.duration ? opt.duration :opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] :jQuery.fx.speeds._default, 
(null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, 
opt.complete = function() {
jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
}, opt;
}, jQuery.fn.extend({
fadeTo:function(speed, to, easing, callback) {
return this.filter(isHidden).css("opacity", 0).show().end().animate({
opacity:to
}, speed, easing, callback);
},
animate:function(prop, speed, easing, callback) {
var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
var anim = Animation(this, jQuery.extend({}, prop), optall);
(empty || data_priv.get(this, "finish")) && anim.stop(!0);
};
return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) :this.queue(optall.queue, doAnimation);
},
stop:function(type, clearQueue, gotoEnd) {
var stopQueue = function(hooks) {
var stop = hooks.stop;
delete hooks.stop, stop(gotoEnd);
};
return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), 
clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function() {
var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), 
dequeue = !1, timers.splice(index, 1));
(dequeue || !gotoEnd) && jQuery.dequeue(this, type);
});
},
finish:function(type) {
return type !== !1 && (type = type || "fx"), this.each(function() {
var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length :0;
for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), 
index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), 
timers.splice(index, 1));
for (index = 0; length > index; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
delete data.finish;
});
}
}), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
var cssFn = jQuery.fn[name];
jQuery.fn[name] = function(speed, easing, callback) {
return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) :this.animate(genFx(name, !0), speed, easing, callback);
};
}), jQuery.each({
slideDown:genFx("show"),
slideUp:genFx("hide"),
slideToggle:genFx("toggle"),
fadeIn:{
opacity:"show"
},
fadeOut:{
opacity:"hide"
},
fadeToggle:{
opacity:"toggle"
}
}, function(name, props) {
jQuery.fn[name] = function(speed, easing, callback) {
return this.animate(props, speed, easing, callback);
};
}), jQuery.timers = [], jQuery.fx.tick = function() {
var timer, i = 0, timers = jQuery.timers;
for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
timers.length || jQuery.fx.stop(), fxNow = void 0;
}, jQuery.fx.timer = function(timer) {
jQuery.timers.push(timer), timer() ? jQuery.fx.start() :jQuery.timers.pop();
}, jQuery.fx.interval = 13, jQuery.fx.start = function() {
timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval));
}, jQuery.fx.stop = function() {
clearInterval(timerId), timerId = null;
}, jQuery.fx.speeds = {
slow:600,
fast:200,
_default:400
}, jQuery.fn.delay = function(time, type) {
return time = jQuery.fx ? jQuery.fx.speeds[time] || time :time, type = type || "fx", 
this.queue(type, function(next, hooks) {
var timeout = setTimeout(next, time);
hooks.stop = function() {
clearTimeout(timeout);
};
});
}, function() {
var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, 
select.disabled = !0, support.optDisabled = !opt.disabled, input = document.createElement("input"), 
input.value = "t", input.type = "radio", support.radioValue = "t" === input.value;
}();
var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
jQuery.fn.extend({
attr:function(name, value) {
return access(this, jQuery.attr, name, value, arguments.length > 1);
},
removeAttr:function(name) {
return this.each(function() {
jQuery.removeAttr(this, name);
});
}
}), jQuery.extend({
attr:function(elem, name, value) {
var hooks, ret, nType = elem.nodeType;
if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return typeof elem.getAttribute === strundefined ? jQuery.prop(elem, name, value) :(1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), 
hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook :nodeHook)), 
void 0 === value ? hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret :(ret = jQuery.find.attr(elem, name), 
null == ret ? void 0 :ret) :null !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret :(elem.setAttribute(name, value + ""), 
value) :(jQuery.removeAttr(elem, name), void 0));
},
removeAttr:function(elem, value) {
var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) propName = jQuery.propFix[name] || name, 
jQuery.expr.match.bool.test(name) && (elem[propName] = !1), elem.removeAttribute(name);
},
attrHooks:{
type:{
set:function(elem, value) {
if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
var val = elem.value;
return elem.setAttribute("type", value), val && (elem.value = val), value;
}
}
}
}
}), boolHook = {
set:function(elem, value, name) {
return value === !1 ? jQuery.removeAttr(elem, name) :elem.setAttribute(name, name), 
name;
}
}, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
var getter = attrHandle[name] || jQuery.find.attr;
attrHandle[name] = function(elem, name, isXML) {
var ret, handle;
return isXML || (handle = attrHandle[name], attrHandle[name] = ret, ret = null != getter(elem, name, isXML) ? name.toLowerCase() :null, 
attrHandle[name] = handle), ret;
};
});
var rfocusable = /^(?:input|select|textarea|button)$/i;
jQuery.fn.extend({
prop:function(name, value) {
return access(this, jQuery.prop, name, value, arguments.length > 1);
},
removeProp:function(name) {
return this.each(function() {
delete this[jQuery.propFix[name] || name];
});
}
}), jQuery.extend({
propFix:{
"for":"htmlFor",
"class":"className"
},
prop:function(elem, name, value) {
var ret, hooks, notxml, nType = elem.nodeType;
if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return notxml = 1 !== nType || !jQuery.isXMLDoc(elem), 
notxml && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), 
void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret :elem[name] = value :hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret :elem[name];
},
propHooks:{
tabIndex:{
get:function(elem) {
return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex :-1;
}
}
}
}), support.optSelected || (jQuery.propHooks.selected = {
get:function(elem) {
var parent = elem.parentNode;
return parent && parent.parentNode && parent.parentNode.selectedIndex, null;
}
}), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
jQuery.propFix[this.toLowerCase()] = this;
});
var rclass = /[\t\r\n\f]/g;
jQuery.fn.extend({
addClass:function(value) {
var classes, elem, cur, clazz, j, finalValue, proceed = "string" == typeof value && value, i = 0, len = this.length;
if (jQuery.isFunction(value)) return this.each(function(j) {
jQuery(this).addClass(value.call(this, j, this.className));
});
if (proceed) for (classes = (value || "").match(rnotwhite) || []; len > i; i++) if (elem = this[i], 
cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") :" ")) {
for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
finalValue = jQuery.trim(cur), elem.className !== finalValue && (elem.className = finalValue);
}
return this;
},
removeClass:function(value) {
var classes, elem, cur, clazz, j, finalValue, proceed = 0 === arguments.length || "string" == typeof value && value, i = 0, len = this.length;
if (jQuery.isFunction(value)) return this.each(function(j) {
jQuery(this).removeClass(value.call(this, j, this.className));
});
if (proceed) for (classes = (value || "").match(rnotwhite) || []; len > i; i++) if (elem = this[i], 
cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") :"")) {
for (j = 0; clazz = classes[j++]; ) for (;cur.indexOf(" " + clazz + " ") >= 0; ) cur = cur.replace(" " + clazz + " ", " ");
finalValue = value ? jQuery.trim(cur) :"", elem.className !== finalValue && (elem.className = finalValue);
}
return this;
},
toggleClass:function(value, stateVal) {
var type = typeof value;
return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) :this.removeClass(value) :jQuery.isFunction(value) ? this.each(function(i) {
jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
}) :this.each(function() {
if ("string" === type) for (var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) :self.addClass(className); else (type === strundefined || "boolean" === type) && (this.className && data_priv.set(this, "__className__", this.className), 
this.className = this.className || value === !1 ? "" :data_priv.get(this, "__className__") || "");
});
},
hasClass:function(selector) {
for (var className = " " + selector + " ", i = 0, l = this.length; l > i; i++) if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) return !0;
return !1;
}
});
var rreturn = /\r/g;
jQuery.fn.extend({
val:function(value) {
var hooks, ret, isFunction, elem = this[0];
{
if (arguments.length) return isFunction = jQuery.isFunction(value), this.each(function(i) {
var val;
1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) :value, 
null == val ? val = "" :"number" == typeof val ? val += "" :jQuery.isArray(val) && (val = jQuery.map(val, function(value) {
return null == value ? "" :value + "";
})), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], 
hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
});
if (elem) return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], 
hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret :(ret = elem.value, 
"string" == typeof ret ? ret.replace(rreturn, "") :null == ret ? "" :ret);
}
}
}), jQuery.extend({
valHooks:{
option:{
get:function(elem) {
var val = jQuery.find.attr(elem, "value");
return null != val ? val :jQuery.trim(jQuery.text(elem));
}
},
select:{
get:function(elem) {
for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type || 0 > index, values = one ? null :[], max = one ? index + 1 :options.length, i = 0 > index ? max :one ? index :0; max > i; i++) if (option = options[i], 
!(!option.selected && i !== index || (support.optDisabled ? option.disabled :null !== option.getAttribute("disabled")) || option.parentNode.disabled && jQuery.nodeName(option.parentNode, "optgroup"))) {
if (value = jQuery(option).val(), one) return value;
values.push(value);
}
return values;
},
set:function(elem, value) {
for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) option = options[i], 
(option.selected = jQuery.inArray(option.value, values) >= 0) && (optionSet = !0);
return optionSet || (elem.selectedIndex = -1), values;
}
}
}
}), jQuery.each([ "radio", "checkbox" ], function() {
jQuery.valHooks[this] = {
set:function(elem, value) {
return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 :void 0;
}
}, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
return null === elem.getAttribute("value") ? "on" :elem.value;
});
}), jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(i, name) {
jQuery.fn[name] = function(data, fn) {
return arguments.length > 0 ? this.on(name, null, data, fn) :this.trigger(name);
};
}), jQuery.fn.extend({
hover:function(fnOver, fnOut) {
return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
},
bind:function(types, data, fn) {
return this.on(types, null, data, fn);
},
unbind:function(types, fn) {
return this.off(types, null, fn);
},
delegate:function(selector, types, data, fn) {
return this.on(types, selector, data, fn);
},
undelegate:function(selector, types, fn) {
return 1 === arguments.length ? this.off(selector, "**") :this.off(types, selector || "**", fn);
}
});
var nonce = jQuery.now(), rquery = /\?/;
jQuery.parseJSON = function(data) {
return JSON.parse(data + "");
}, jQuery.parseXML = function(data) {
var xml, tmp;
if (!data || "string" != typeof data) return null;
try {
tmp = new DOMParser(), xml = tmp.parseFromString(data, "text/xml");
} catch (e) {
xml = void 0;
}
return (!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data), 
xml;
};
var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
jQuery.extend({
active:0,
lastModified:{},
etag:{},
ajaxSettings:{
url:ajaxLocation,
type:"GET",
isLocal:rlocalProtocol.test(ajaxLocParts[1]),
global:!0,
processData:!0,
async:!0,
contentType:"application/x-www-form-urlencoded; charset=UTF-8",
accepts:{
"*":allTypes,
text:"text/plain",
html:"text/html",
xml:"application/xml, text/xml",
json:"application/json, text/javascript"
},
contents:{
xml:/xml/,
html:/html/,
json:/json/
},
responseFields:{
xml:"responseXML",
text:"responseText",
json:"responseJSON"
},
converters:{
"* text":String,
"text html":!0,
"text json":jQuery.parseJSON,
"text xml":jQuery.parseXML
},
flatOptions:{
url:!0,
context:!0
}
},
ajaxSetup:function(target, settings) {
return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :ajaxExtend(jQuery.ajaxSettings, target);
},
ajaxPrefilter:addToPrefiltersOrTransports(prefilters),
ajaxTransport:addToPrefiltersOrTransports(transports),
ajax:function(url, options) {
function done(status, nativeStatusText, responses, headers) {
var isSuccess, success, error, response, modified, statusText = nativeStatusText;
2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = void 0, 
responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 :0, isSuccess = status >= 200 && 300 > status || 304 === status, 
responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), 
isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), 
modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), 
modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" :304 === status ? statusText = "notmodified" :(statusText = response.state, 
success = response.data, error = response.error, isSuccess = !error)) :(error = statusText, 
(status || !statusText) && (statusText = "error", 0 > status && (status = 0))), 
jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", 
isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) :deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]), 
jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" :"ajaxError", [ jqXHR, s, isSuccess ? success :error ]), 
completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]), 
--jQuery.active || jQuery.event.trigger("ajaxStop")));
}
"object" == typeof url && (options = url, url = void 0), options = options || {};
var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) :jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
readyState:0,
getResponseHeader:function(key) {
var match;
if (2 === state) {
if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase()] = match[2];
match = responseHeaders[key.toLowerCase()];
}
return null == match ? null :match;
},
getAllResponseHeaders:function() {
return 2 === state ? responseHeadersString :null;
},
setRequestHeader:function(name, value) {
var lname = name.toLowerCase();
return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, 
requestHeaders[name] = value), this;
},
overrideMimeType:function(type) {
return state || (s.mimeType = type), this;
},
statusCode:function(map) {
var code;
if (map) if (2 > state) for (code in map) statusCode[code] = [ statusCode[code], map[code] ]; else jqXHR.always(map[jqXHR.status]);
return this;
},
abort:function(statusText) {
var finalText = statusText || strAbort;
return transport && transport.abort(finalText), done(0, finalText), this;
}
};
if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, 
jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), 
s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ], 
null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" :"443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" :"443")))), 
s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), 
inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state) return jqXHR;
fireGlobals = jQuery.event && s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), 
s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url, 
s.hasContent || (s.data && (cacheURL = s.url += (rquery.test(cacheURL) ? "&" :"?") + s.data, 
delete s.data), s.cache === !1 && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) :cacheURL + (rquery.test(cacheURL) ? "&" :"?") + "_=" + nonce++)), 
s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), 
jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), 
(s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), 
jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" :"") :s.accepts["*"]);
for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || 2 === state)) return jqXHR.abort();
strAbort = "abort";
for (i in {
success:1,
error:1,
complete:1
}) jqXHR[i](s[i]);
if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]), 
s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function() {
jqXHR.abort("timeout");
}, s.timeout));
try {
state = 1, transport.send(requestHeaders, done);
} catch (e) {
if (!(2 > state)) throw e;
done(-1, e);
}
} else done(-1, "No Transport");
return jqXHR;
},
getJSON:function(url, data, callback) {
return jQuery.get(url, data, callback, "json");
},
getScript:function(url, callback) {
return jQuery.get(url, void 0, callback, "script");
}
}), jQuery.each([ "get", "post" ], function(i, method) {
jQuery[method] = function(url, data, callback, type) {
return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), 
jQuery.ajax({
url:url,
type:method,
dataType:type,
data:data,
success:callback
});
};
}), jQuery._evalUrl = function(url) {
return jQuery.ajax({
url:url,
type:"GET",
dataType:"script",
async:!1,
global:!1,
"throws":!0
});
}, jQuery.fn.extend({
wrapAll:function(html) {
var wrap;
return jQuery.isFunction(html) ? this.each(function(i) {
jQuery(this).wrapAll(html.call(this, i));
}) :(this[0] && (wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), 
wrap.map(function() {
for (var elem = this; elem.firstElementChild; ) elem = elem.firstElementChild;
return elem;
}).append(this)), this);
},
wrapInner:function(html) {
return jQuery.isFunction(html) ? this.each(function(i) {
jQuery(this).wrapInner(html.call(this, i));
}) :this.each(function() {
var self = jQuery(this), contents = self.contents();
contents.length ? contents.wrapAll(html) :self.append(html);
});
},
wrap:function(html) {
var isFunction = jQuery.isFunction(html);
return this.each(function(i) {
jQuery(this).wrapAll(isFunction ? html.call(this, i) :html);
});
},
unwrap:function() {
return this.parent().each(function() {
jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes);
}).end();
}
}), jQuery.expr.filters.hidden = function(elem) {
return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
}, jQuery.expr.filters.visible = function(elem) {
return !jQuery.expr.filters.hidden(elem);
};
var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
jQuery.param = function(a, traditional) {
var prefix, s = [], add = function(key, value) {
value = jQuery.isFunction(value) ? value() :null == value ? "" :value, s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
};
if (void 0 === traditional && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), 
jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
add(this.name, this.value);
}); else for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
return s.join("&").replace(r20, "+");
}, jQuery.fn.extend({
serialize:function() {
return jQuery.param(this.serializeArray());
},
serializeArray:function() {
return this.map(function() {
var elements = jQuery.prop(this, "elements");
return elements ? jQuery.makeArray(elements) :this;
}).filter(function() {
var type = this.type;
return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
}).map(function(i, elem) {
var val = jQuery(this).val();
return null == val ? null :jQuery.isArray(val) ? jQuery.map(val, function(val) {
return {
name:elem.name,
value:val.replace(rCRLF, "\r\n")
};
}) :{
name:elem.name,
value:val.replace(rCRLF, "\r\n")
};
}).get();
}
}), jQuery.ajaxSettings.xhr = function() {
try {
return new XMLHttpRequest();
} catch (e) {}
};
var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
0:200,
1223:204
}, xhrSupported = jQuery.ajaxSettings.xhr();
window.attachEvent && window.attachEvent("onunload", function() {
for (var key in xhrCallbacks) xhrCallbacks[key]();
}), support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, 
jQuery.ajaxTransport(function(options) {
var callback;
return support.cors || xhrSupported && !options.crossDomain ? {
send:function(headers, complete) {
var i, xhr = options.xhr(), id = ++xhrId;
if (xhr.open(options.type, options.url, options.async, options.username, options.password), 
options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), 
options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
for (i in headers) xhr.setRequestHeader(i, headers[i]);
callback = function(type) {
return function() {
callback && (delete xhrCallbacks[id], callback = xhr.onload = xhr.onerror = null, 
"abort" === type ? xhr.abort() :"error" === type ? complete(xhr.status, xhr.statusText) :complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "string" == typeof xhr.responseText ? {
text:xhr.responseText
} :void 0, xhr.getAllResponseHeaders()));
};
}, xhr.onload = callback(), xhr.onerror = callback("error"), callback = xhrCallbacks[id] = callback("abort");
try {
xhr.send(options.hasContent && options.data || null);
} catch (e) {
if (callback) throw e;
}
},
abort:function() {
callback && callback();
}
} :void 0;
}), jQuery.ajaxSetup({
accepts:{
script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
},
contents:{
script:/(?:java|ecma)script/
},
converters:{
"text script":function(text) {
return jQuery.globalEval(text), text;
}
}
}), jQuery.ajaxPrefilter("script", function(s) {
void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET");
}), jQuery.ajaxTransport("script", function(s) {
if (s.crossDomain) {
var script, callback;
return {
send:function(_, complete) {
script = jQuery("<script>").prop({
async:!0,
charset:s.scriptCharset,
src:s.url
}).on("load error", callback = function(evt) {
script.remove(), callback = null, evt && complete("error" === evt.type ? 404 :200, evt.type);
}), document.head.appendChild(script[0]);
},
abort:function() {
callback && callback();
}
};
}
});
var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
jQuery.ajaxSetup({
jsonp:"callback",
jsonpCallback:function() {
var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
return this[callback] = !0, callback;
}
}), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" :"string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() :s.jsonpCallback, 
jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) :s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" :"?") + s.jsonp + "=" + callbackName), 
s.converters["script json"] = function() {
return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
}, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
responseContainer = arguments;
}, jqXHR.always(function() {
window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, 
oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), 
responseContainer = overwritten = void 0;
}), "script") :void 0;
}), jQuery.parseHTML = function(data, context, keepScripts) {
if (!data || "string" != typeof data) return null;
"boolean" == typeof context && (keepScripts = context, context = !1), context = context || document;
var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
return parsed ? [ context.createElement(parsed[1]) ] :(parsed = jQuery.buildFragment([ data ], context, scripts), 
scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
};
var _load = jQuery.fn.load;
jQuery.fn.load = function(url, params, callback) {
if ("string" != typeof url && _load) return _load.apply(this, arguments);
var selector, type, response, self = this, off = url.indexOf(" ");
return off >= 0 && (selector = jQuery.trim(url.slice(off)), url = url.slice(0, off)), 
jQuery.isFunction(params) ? (callback = params, params = void 0) :params && "object" == typeof params && (type = "POST"), 
self.length > 0 && jQuery.ajax({
url:url,
type:type,
dataType:"html",
data:params
}).done(function(responseText) {
response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :responseText);
}).complete(callback && function(jqXHR, status) {
self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
}), this;
}, jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
jQuery.fn[type] = function(fn) {
return this.on(type, fn);
};
}), jQuery.expr.filters.animated = function(elem) {
return jQuery.grep(jQuery.timers, function(fn) {
return elem === fn.elem;
}).length;
};
var docElem = window.document.documentElement;
jQuery.offset = {
setOffset:function(elem, options, i) {
var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
"static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), 
curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, 
calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, 
curLeft = curPosition.left) :(curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), 
jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)), null != options.top && (props.top = options.top - curOffset.top + curTop), 
null != options.left && (props.left = options.left - curOffset.left + curLeft), 
"using" in options ? options.using.call(elem, props) :curElem.css(props);
}
}, jQuery.fn.extend({
offset:function(options) {
if (arguments.length) return void 0 === options ? this :this.each(function(i) {
jQuery.offset.setOffset(this, options, i);
});
var docElem, win, elem = this[0], box = {
top:0,
left:0
}, doc = elem && elem.ownerDocument;
if (doc) return docElem = doc.documentElement, jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== strundefined && (box = elem.getBoundingClientRect()), 
win = getWindow(doc), {
top:box.top + win.pageYOffset - docElem.clientTop,
left:box.left + win.pageXOffset - docElem.clientLeft
}) :box;
},
position:function() {
if (this[0]) {
var offsetParent, offset, elem = this[0], parentOffset = {
top:0,
left:0
};
return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() :(offsetParent = this.offsetParent(), 
offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), 
parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), 
{
top:offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
left:offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
};
}
},
offsetParent:function() {
return this.map(function() {
for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
return offsetParent || docElem;
});
}
}), jQuery.each({
scrollLeft:"pageXOffset",
scrollTop:"pageYOffset"
}, function(method, prop) {
var top = "pageYOffset" === prop;
jQuery.fn[method] = function(val) {
return access(this, function(elem, method, val) {
var win = getWindow(elem);
return void 0 === val ? win ? win[prop] :elem[method] :(win ? win.scrollTo(top ? window.pageXOffset :val, top ? val :window.pageYOffset) :elem[method] = val, 
void 0);
}, method, val, arguments.length, null);
};
}), jQuery.each([ "top", "left" ], function(i, prop) {
jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" :computed) :void 0;
});
}), jQuery.each({
Height:"height",
Width:"width"
}, function(name, type) {
jQuery.each({
padding:"inner" + name,
content:type,
"":"outer" + name
}, function(defaultExtra, funcName) {
jQuery.fn[funcName] = function(margin, value) {
var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" :"border");
return access(this, function(elem, type, value) {
var doc;
return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] :9 === elem.nodeType ? (doc = elem.documentElement, 
Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) :void 0 === value ? jQuery.css(elem, type, extra) :jQuery.style(elem, type, value, extra);
}, type, chainable ? margin :void 0, chainable, null);
};
});
}), jQuery.fn.size = function() {
return this.length;
}, jQuery.fn.andSelf = jQuery.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
return jQuery;
});
var _jQuery = window.jQuery, _$ = window.$;
return jQuery.noConflict = function(deep) {
return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), 
jQuery;
}, typeof noGlobal === strundefined && (window.jQuery = window.$ = jQuery), jQuery;
}), function(window, document, undefined) {
"use strict";
function minErr(module) {
return function() {
var message, i, code = arguments[0], prefix = "[" + (module ? module + ":" :"") + code + "] ", template = arguments[1], templateArgs = arguments, stringify = function(obj) {
return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") :"undefined" == typeof obj ? "undefined" :"string" != typeof obj ? JSON.stringify(obj) :obj;
};
for (message = prefix + template.replace(/\{\d+\}/g, function(match) {
var arg, index = +match.slice(1, -1);
return index + 2 < templateArgs.length ? (arg = templateArgs[index + 2], "function" == typeof arg ? arg.toString().replace(/ ?\{[\s\S]*$/, "") :"undefined" == typeof arg ? "undefined" :"string" != typeof arg ? toJson(arg) :arg) :match;
}), message = message + "\nhttp://errors.angularjs.org/1.2.28/" + (module ? module + "/" :"") + code, 
i = 2; i < arguments.length; i++) message = message + (2 == i ? "?" :"&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
return new Error(message);
};
}
function isArrayLike(obj) {
if (null == obj || isWindow(obj)) return !1;
var length = obj.length;
return 1 === obj.nodeType && length ? !0 :isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
}
function forEach(obj, iterator, context) {
var key;
if (obj) if (isFunction(obj)) for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key); else if (isArray(obj) || isArrayLike(obj)) for (key = 0; key < obj.length; key++) iterator.call(context, obj[key], key); else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context); else for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key);
return obj;
}
function sortedKeys(obj) {
var keys = [];
for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
return keys.sort();
}
function forEachSorted(obj, iterator, context) {
for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
return keys;
}
function reverseParams(iteratorFn) {
return function(value, key) {
iteratorFn(key, value);
};
}
function nextUid() {
for (var digit, index = uid.length; index; ) {
if (index--, digit = uid[index].charCodeAt(0), 57 == digit) return uid[index] = "A", 
uid.join("");
if (90 != digit) return uid[index] = String.fromCharCode(digit + 1), uid.join("");
uid[index] = "0";
}
return uid.unshift("0"), uid.join("");
}
function setHashKey(obj, h) {
h ? obj.$$hashKey = h :delete obj.$$hashKey;
}
function extend(dst) {
var h = dst.$$hashKey;
return forEach(arguments, function(obj) {
obj !== dst && forEach(obj, function(value, key) {
dst[key] = value;
});
}), setHashKey(dst, h), dst;
}
function int(str) {
return parseInt(str, 10);
}
function inherit(parent, extra) {
return extend(new (extend(function() {}, {
prototype:parent
}))(), extra);
}
function noop() {}
function identity($) {
return $;
}
function valueFn(value) {
return function() {
return value;
};
}
function isUndefined(value) {
return "undefined" == typeof value;
}
function isDefined(value) {
return "undefined" != typeof value;
}
function isObject(value) {
return null != value && "object" == typeof value;
}
function isString(value) {
return "string" == typeof value;
}
function isNumber(value) {
return "number" == typeof value;
}
function isDate(value) {
return "[object Date]" === toString.call(value);
}
function isFunction(value) {
return "function" == typeof value;
}
function isRegExp(value) {
return "[object RegExp]" === toString.call(value);
}
function isWindow(obj) {
return obj && obj.document && obj.location && obj.alert && obj.setInterval;
}
function isScope(obj) {
return obj && obj.$evalAsync && obj.$watch;
}
function isFile(obj) {
return "[object File]" === toString.call(obj);
}
function isBlob(obj) {
return "[object Blob]" === toString.call(obj);
}
function isPromiseLike(obj) {
return obj && isFunction(obj.then);
}
function isElement(node) {
return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
}
function map(obj, iterator, context) {
var results = [];
return forEach(obj, function(value, index, list) {
results.push(iterator.call(context, value, index, list));
}), results;
}
function includes(array, obj) {
return -1 != indexOf(array, obj);
}
function indexOf(array, obj) {
if (array.indexOf) return array.indexOf(obj);
for (var i = 0; i < array.length; i++) if (obj === array[i]) return i;
return -1;
}
function arrayRemove(array, value) {
var index = indexOf(array, value);
return index >= 0 && array.splice(index, 1), value;
}
function copy(source, destination, stackSource, stackDest) {
if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
if (destination) {
if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
if (stackSource = stackSource || [], stackDest = stackDest || [], isObject(source)) {
var index = indexOf(stackSource, source);
if (-1 !== index) return stackDest[index];
stackSource.push(source), stackDest.push(destination);
}
var result;
if (isArray(source)) {
destination.length = 0;
for (var i = 0; i < source.length; i++) result = copy(source[i], null, stackSource, stackDest), 
isObject(source[i]) && (stackSource.push(source[i]), stackDest.push(result)), destination.push(result);
} else {
var h = destination.$$hashKey;
isArray(destination) ? destination.length = 0 :forEach(destination, function(value, key) {
delete destination[key];
});
for (var key in source) result = copy(source[key], null, stackSource, stackDest), 
isObject(source[key]) && (stackSource.push(source[key]), stackDest.push(result)), 
destination[key] = result;
setHashKey(destination, h);
}
} else destination = source, source && (isArray(source) ? destination = copy(source, [], stackSource, stackDest) :isDate(source) ? destination = new Date(source.getTime()) :isRegExp(source) ? (destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]), 
destination.lastIndex = source.lastIndex) :isObject(source) && (destination = copy(source, {}, stackSource, stackDest)));
return destination;
}
function shallowCopy(src, dst) {
if (isArray(src)) {
dst = dst || [];
for (var i = 0; i < src.length; i++) dst[i] = src[i];
} else if (isObject(src)) {
dst = dst || {};
for (var key in src) !hasOwnProperty.call(src, key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
}
return dst || src;
}
function equals(o1, o2) {
if (o1 === o2) return !0;
if (null === o1 || null === o2) return !1;
if (o1 !== o1 && o2 !== o2) return !0;
var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
if (t1 == t2 && "object" == t1) {
if (!isArray(o1)) {
if (isDate(o1)) return isDate(o2) ? isNaN(o1.getTime()) && isNaN(o2.getTime()) || o1.getTime() === o2.getTime() :!1;
if (isRegExp(o1) && isRegExp(o2)) return o1.toString() == o2.toString();
if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return !1;
keySet = {};
for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
if (!equals(o1[key], o2[key])) return !1;
keySet[key] = !0;
}
for (key in o2) if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key])) return !1;
return !0;
}
if (!isArray(o2)) return !1;
if ((length = o1.length) == o2.length) {
for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
return !0;
}
}
return !1;
}
function concat(array1, array2, index) {
return array1.concat(slice.call(array2, index));
}
function sliceArgs(args, startIndex) {
return slice.call(args, startIndex || 0);
}
function bind(self, fn) {
var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) :[];
return !isFunction(fn) || fn instanceof RegExp ? fn :curryArgs.length ? function() {
return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) :fn.apply(self, curryArgs);
} :function() {
return arguments.length ? fn.apply(self, arguments) :fn.call(self);
};
}
function toJsonReplacer(key, value) {
var val = value;
return "string" == typeof key && "$" === key.charAt(0) ? val = undefined :isWindow(value) ? val = "$WINDOW" :value && document === value ? val = "$DOCUMENT" :isScope(value) && (val = "$SCOPE"), 
val;
}
function toJson(obj, pretty) {
return "undefined" == typeof obj ? undefined :JSON.stringify(obj, toJsonReplacer, pretty ? "  " :null);
}
function fromJson(json) {
return isString(json) ? JSON.parse(json) :json;
}
function toBoolean(value) {
if ("function" == typeof value) value = !0; else if (value && 0 !== value.length) {
var v = lowercase("" + value);
value = !("f" == v || "0" == v || "false" == v || "no" == v || "n" == v || "[]" == v);
} else value = !1;
return value;
}
function startingTag(element) {
element = jqLite(element).clone();
try {
element.empty();
} catch (e) {}
var TEXT_NODE = 3, elemHtml = jqLite("<div>").append(element).html();
try {
return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
return "<" + lowercase(nodeName);
});
} catch (e) {
return lowercase(elemHtml);
}
}
function tryDecodeURIComponent(value) {
try {
return decodeURIComponent(value);
} catch (e) {}
}
function parseKeyValue(keyValue) {
var key_value, key, obj = {};
return forEach((keyValue || "").split("&"), function(keyValue) {
if (keyValue && (key_value = keyValue.replace(/\+/g, "%20").split("="), key = tryDecodeURIComponent(key_value[0]), 
isDefined(key))) {
var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) :!0;
hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) :obj[key] = [ obj[key], val ] :obj[key] = val;
}
}), obj;
}
function toKeyValue(obj) {
var parts = [];
return forEach(obj, function(value, key) {
isArray(value) ? forEach(value, function(arrayValue) {
parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" :"=" + encodeUriQuery(arrayValue, !0)));
}) :parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" :"=" + encodeUriQuery(value, !0)));
}), parts.length ? parts.join("&") :"";
}
function encodeUriSegment(val) {
return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
}
function encodeUriQuery(val, pctEncodeSpaces) {
return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" :"+");
}
function angularInit(element, bootstrap) {
function append(element) {
element && elements.push(element);
}
var appElement, module, elements = [ element ], names = [ "ng:app", "ng-app", "x-ng-app", "data-ng-app" ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
forEach(names, function(name) {
names[name] = !0, append(document.getElementById(name)), name = name.replace(":", "\\:"), 
element.querySelectorAll && (forEach(element.querySelectorAll("." + name), append), 
forEach(element.querySelectorAll("." + name + "\\:"), append), forEach(element.querySelectorAll("[" + name + "]"), append));
}), forEach(elements, function(element) {
if (!appElement) {
var className = " " + element.className + " ", match = NG_APP_CLASS_REGEXP.exec(className);
match ? (appElement = element, module = (match[2] || "").replace(/\s+/g, ",")) :forEach(element.attributes, function(attr) {
!appElement && names[attr.name] && (appElement = element, module = attr.value);
});
}
}), appElement && bootstrap(appElement, module ? [ module ] :[]);
}
function bootstrap(element, modules) {
var doBootstrap = function() {
if (element = jqLite(element), element.injector()) {
var tag = element[0] === document ? "document" :startingTag(element);
throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
}
modules = modules || [], modules.unshift([ "$provide", function($provide) {
$provide.value("$rootElement", element);
} ]), modules.unshift("ng");
var injector = createInjector(modules);
return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", "$animate", function(scope, element, compile, injector) {
scope.$apply(function() {
element.data("$injector", injector), compile(element)(scope);
});
} ]), injector;
}, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
return window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() :(window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
angular.resumeBootstrap = function(extraModules) {
forEach(extraModules, function(module) {
modules.push(module);
}), doBootstrap();
}, void 0);
}
function snake_case(name, separator) {
return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
return (pos ? separator :"") + letter.toLowerCase();
});
}
function bindJQuery() {
jQuery = window.jQuery, jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
scope:JQLitePrototype.scope,
isolateScope:JQLitePrototype.isolateScope,
controller:JQLitePrototype.controller,
injector:JQLitePrototype.injector,
inheritedData:JQLitePrototype.inheritedData
}), jqLitePatchJQueryRemove("remove", !0, !0, !1), jqLitePatchJQueryRemove("empty", !1, !1, !1), 
jqLitePatchJQueryRemove("html", !1, !1, !0)) :jqLite = JQLite, angular.element = jqLite;
}
function assertArg(arg, name, reason) {
if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
return arg;
}
function assertArgFn(arg, name, acceptArrayAnnotation) {
return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" :typeof arg)), 
arg;
}
function assertNotHasOwnProperty(name, context) {
if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
}
function getter(obj, path, bindFnToScope) {
if (!path) return obj;
for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
obj && (obj = (lastInstance = obj)[key]);
return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) :obj;
}
function getBlockElements(nodes) {
var startNode = nodes[0], endNode = nodes[nodes.length - 1];
if (startNode === endNode) return jqLite(startNode);
var element = startNode, elements = [ element ];
do {
if (element = element.nextSibling, !element) break;
elements.push(element);
} while (element !== endNode);
return jqLite(elements);
}
function setupModuleLoader(window) {
function ensure(obj, name, factory) {
return obj[name] || (obj[name] = factory());
}
var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
var modules = {};
return function(name, requires, configFn) {
var assertNotHasOwnProperty = function(name, context) {
if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
};
return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
ensure(modules, name, function() {
function invokeLater(provider, method, insertMethod) {
return function() {
return invokeQueue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
};
}
if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
var invokeQueue = [], runBlocks = [], config = invokeLater("$injector", "invoke"), moduleInstance = {
_invokeQueue:invokeQueue,
_runBlocks:runBlocks,
requires:requires,
name:name,
provider:invokeLater("$provide", "provider"),
factory:invokeLater("$provide", "factory"),
service:invokeLater("$provide", "service"),
value:invokeLater("$provide", "value"),
constant:invokeLater("$provide", "constant", "unshift"),
animation:invokeLater("$animateProvider", "register"),
filter:invokeLater("$filterProvider", "register"),
controller:invokeLater("$controllerProvider", "register"),
directive:invokeLater("$compileProvider", "directive"),
config:config,
run:function(block) {
return runBlocks.push(block), this;
}
};
return configFn && config(configFn), moduleInstance;
});
};
});
}
function publishExternalAPI(angular) {
extend(angular, {
bootstrap:bootstrap,
copy:copy,
extend:extend,
equals:equals,
element:jqLite,
forEach:forEach,
injector:createInjector,
noop:noop,
bind:bind,
toJson:toJson,
fromJson:fromJson,
identity:identity,
isUndefined:isUndefined,
isDefined:isDefined,
isString:isString,
isFunction:isFunction,
isObject:isObject,
isNumber:isNumber,
isElement:isElement,
isArray:isArray,
version:version,
isDate:isDate,
lowercase:lowercase,
uppercase:uppercase,
callbacks:{
counter:0
},
$$minErr:minErr,
$$csp:csp
}), angularModule = setupModuleLoader(window);
try {
angularModule("ngLocale");
} catch (e) {
angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
}
angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
$provide.provider({
$$sanitizeUri:$$SanitizeUriProvider
}), $provide.provider("$compile", $CompileProvider).directive({
a:htmlAnchorDirective,
input:inputDirective,
textarea:inputDirective,
form:formDirective,
script:scriptDirective,
select:selectDirective,
style:styleDirective,
option:optionDirective,
ngBind:ngBindDirective,
ngBindHtml:ngBindHtmlDirective,
ngBindTemplate:ngBindTemplateDirective,
ngClass:ngClassDirective,
ngClassEven:ngClassEvenDirective,
ngClassOdd:ngClassOddDirective,
ngCloak:ngCloakDirective,
ngController:ngControllerDirective,
ngForm:ngFormDirective,
ngHide:ngHideDirective,
ngIf:ngIfDirective,
ngInclude:ngIncludeDirective,
ngInit:ngInitDirective,
ngNonBindable:ngNonBindableDirective,
ngPluralize:ngPluralizeDirective,
ngRepeat:ngRepeatDirective,
ngShow:ngShowDirective,
ngStyle:ngStyleDirective,
ngSwitch:ngSwitchDirective,
ngSwitchWhen:ngSwitchWhenDirective,
ngSwitchDefault:ngSwitchDefaultDirective,
ngOptions:ngOptionsDirective,
ngTransclude:ngTranscludeDirective,
ngModel:ngModelDirective,
ngList:ngListDirective,
ngChange:ngChangeDirective,
required:requiredDirective,
ngRequired:requiredDirective,
ngValue:ngValueDirective
}).directive({
ngInclude:ngIncludeFillContentDirective
}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
$anchorScroll:$AnchorScrollProvider,
$animate:$AnimateProvider,
$browser:$BrowserProvider,
$cacheFactory:$CacheFactoryProvider,
$controller:$ControllerProvider,
$document:$DocumentProvider,
$exceptionHandler:$ExceptionHandlerProvider,
$filter:$FilterProvider,
$interpolate:$InterpolateProvider,
$interval:$IntervalProvider,
$http:$HttpProvider,
$httpBackend:$HttpBackendProvider,
$location:$LocationProvider,
$log:$LogProvider,
$parse:$ParseProvider,
$rootScope:$RootScopeProvider,
$q:$QProvider,
$sce:$SceProvider,
$sceDelegate:$SceDelegateProvider,
$sniffer:$SnifferProvider,
$templateCache:$TemplateCacheProvider,
$timeout:$TimeoutProvider,
$window:$WindowProvider,
$$rAF:$$RAFProvider,
$$asyncCallback:$$AsyncCallbackProvider
});
} ]);
}
function jqNextId() {
return ++jqId;
}
function camelCase(name) {
return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
return offset ? letter.toUpperCase() :letter;
}).replace(MOZ_HACK_REGEXP, "Moz$1");
}
function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
function removePatch(param) {
var set, setIndex, setLength, element, childIndex, childLength, children, list = filterElems && param ? [ this.filter(param) ] :[ this ], fireEvent = dispatchThis;
if (!getterIfNoArguments || null != param) for (;list.length; ) for (set = list.shift(), 
setIndex = 0, setLength = set.length; setLength > setIndex; setIndex++) for (element = jqLite(set[setIndex]), 
fireEvent ? element.triggerHandler("$destroy") :fireEvent = !fireEvent, childIndex = 0, 
childLength = (children = element.children()).length; childLength > childIndex; childIndex++) list.push(jQuery(children[childIndex]));
return originalJqFn.apply(this, arguments);
}
var originalJqFn = jQuery.fn[name];
originalJqFn = originalJqFn.$original || originalJqFn, removePatch.$original = originalJqFn, 
jQuery.fn[name] = removePatch;
}
function jqLiteIsTextNode(html) {
return !HTML_REGEXP.test(html);
}
function jqLiteBuildFragment(html, context) {
var tmp, tag, wrap, i, j, jj, fragment = context.createDocumentFragment(), nodes = [];
if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
tmp.removeChild(tmp.firstChild), i = wrap[0]; i--; ) tmp = tmp.lastChild;
for (j = 0, jj = tmp.childNodes.length; jj > j; ++j) nodes.push(tmp.childNodes[j]);
tmp = fragment.firstChild, tmp.textContent = "";
}
return fragment.textContent = "", fragment.innerHTML = "", nodes;
}
function jqLiteParseHTML(html, context) {
context = context || document;
var parsed;
return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] :jqLiteBuildFragment(html, context);
}
function JQLite(element) {
if (element instanceof JQLite) return element;
if (isString(element) && (element = trim(element)), !(this instanceof JQLite)) {
if (isString(element) && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
return new JQLite(element);
}
if (isString(element)) {
jqLiteAddNodes(this, jqLiteParseHTML(element));
var fragment = jqLite(document.createDocumentFragment());
fragment.append(this);
} else jqLiteAddNodes(this, element);
}
function jqLiteClone(element) {
return element.cloneNode(!0);
}
function jqLiteDealoc(element) {
jqLiteRemoveData(element);
for (var i = 0, children = element.childNodes || []; i < children.length; i++) jqLiteDealoc(children[i]);
}
function jqLiteOff(element, type, fn, unsupported) {
if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
handle && (isUndefined(type) ? forEach(events, function(eventHandler, type) {
removeEventListenerFn(element, type, eventHandler), delete events[type];
}) :forEach(type.split(" "), function(type) {
isUndefined(fn) ? (removeEventListenerFn(element, type, events[type]), delete events[type]) :arrayRemove(events[type] || [], fn);
}));
}
function jqLiteRemoveData(element, name) {
var expandoId = element.ng339, expandoStore = jqCache[expandoId];
if (expandoStore) {
if (name) return delete jqCache[expandoId].data[name], void 0;
expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined;
}
}
function jqLiteExpandoStore(element, key, value) {
var expandoId = element.ng339, expandoStore = jqCache[expandoId || -1];
return isDefined(value) ? (expandoStore || (element.ng339 = expandoId = jqNextId(), 
expandoStore = jqCache[expandoId] = {}), expandoStore[key] = value, void 0) :expandoStore && expandoStore[key];
}
function jqLiteData(element, key, value) {
var data = jqLiteExpandoStore(element, "data"), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
if (data || isSimpleGetter || jqLiteExpandoStore(element, "data", data = {}), isSetter) data[key] = value; else {
if (!keyDefined) return data;
if (isSimpleGetter) return data && data[key];
extend(data, key);
}
}
function jqLiteHasClass(element, selector) {
return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 :!1;
}
function jqLiteRemoveClass(element, cssClasses) {
cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
});
}
function jqLiteAddClass(element, cssClasses) {
if (cssClasses && element.setAttribute) {
var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
forEach(cssClasses.split(" "), function(cssClass) {
cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
}), element.setAttribute("class", trim(existingClasses));
}
}
function jqLiteAddNodes(root, elements) {
if (elements) {
elements = elements.nodeName || !isDefined(elements.length) || isWindow(elements) ? [ elements ] :elements;
for (var i = 0; i < elements.length; i++) root.push(elements[i]);
}
}
function jqLiteController(element, name) {
return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
}
function jqLiteInheritedData(element, name, value) {
9 == element.nodeType && (element = element.documentElement);
for (var names = isArray(name) ? name :[ name ]; element; ) {
for (var i = 0, ii = names.length; ii > i; i++) if ((value = jqLite.data(element, names[i])) !== undefined) return value;
element = element.parentNode || 11 === element.nodeType && element.host;
}
}
function jqLiteEmpty(element) {
for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
for (;element.firstChild; ) element.removeChild(element.firstChild);
}
function getBooleanAttrName(element, name) {
var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
}
function createEventHandler(element, events) {
var eventHandler = function(event, type) {
if (event.preventDefault || (event.preventDefault = function() {
event.returnValue = !1;
}), event.stopPropagation || (event.stopPropagation = function() {
event.cancelBubble = !0;
}), event.target || (event.target = event.srcElement || document), isUndefined(event.defaultPrevented)) {
var prevent = event.preventDefault;
event.preventDefault = function() {
event.defaultPrevented = !0, prevent.call(event);
}, event.defaultPrevented = !1;
}
event.isDefaultPrevented = function() {
return event.defaultPrevented || event.returnValue === !1;
};
var eventHandlersCopy = shallowCopy(events[type || event.type] || []);
forEach(eventHandlersCopy, function(fn) {
fn.call(element, event);
}), 8 >= msie ? (event.preventDefault = null, event.stopPropagation = null, event.isDefaultPrevented = null) :(delete event.preventDefault, 
delete event.stopPropagation, delete event.isDefaultPrevented);
};
return eventHandler.elem = element, eventHandler;
}
function hashKey(obj, nextUidFn) {
var key, objType = typeof obj;
return "function" == objType || "object" == objType && null !== obj ? "function" == typeof (key = obj.$$hashKey) ? key = obj.$$hashKey() :key === undefined && (key = obj.$$hashKey = (nextUidFn || nextUid)()) :key = obj, 
objType + ":" + key;
}
function HashMap(array, isolatedUid) {
if (isolatedUid) {
var uid = 0;
this.nextUid = function() {
return ++uid;
};
}
forEach(array, this.put, this);
}
function annotate(fn) {
var $inject, fnText, argDecl, last;
return "function" == typeof fn ? ($inject = fn.$inject) || ($inject = [], fn.length && (fnText = fn.toString().replace(STRIP_COMMENTS, ""), 
argDecl = fnText.match(FN_ARGS), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
arg.replace(FN_ARG, function(all, underscore, name) {
$inject.push(name);
});
})), fn.$inject = $inject) :isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), 
$inject = fn.slice(0, last)) :assertArgFn(fn, "fn", !0), $inject;
}
function createInjector(modulesToLoad) {
function supportObject(delegate) {
return function(key, value) {
return isObject(key) ? (forEach(key, reverseParams(delegate)), void 0) :delegate(key, value);
};
}
function provider(name, provider_) {
if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
!provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
return providerCache[name + providerSuffix] = provider_;
}
function factory(name, factoryFn) {
return provider(name, {
$get:factoryFn
});
}
function service(name, constructor) {
return factory(name, [ "$injector", function($injector) {
return $injector.instantiate(constructor);
} ]);
}
function value(name, val) {
return factory(name, valueFn(val));
}
function constant(name, value) {
assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
}
function decorator(serviceName, decorFn) {
var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
origProvider.$get = function() {
var origInstance = instanceInjector.invoke(orig$get, origProvider);
return instanceInjector.invoke(decorFn, null, {
$delegate:origInstance
});
};
}
function loadModules(modulesToLoad) {
var moduleFn, invokeQueue, i, ii, runBlocks = [];
return forEach(modulesToLoad, function(module) {
if (!loadedModules.get(module)) {
loadedModules.put(module, !0);
try {
if (isString(module)) for (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; ii > i; i++) {
var invokeArgs = invokeQueue[i], provider = providerInjector.get(invokeArgs[0]);
provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
} else isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) :isArray(module) ? runBlocks.push(providerInjector.invoke(module)) :assertArgFn(module, "module");
} catch (e) {
throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
$injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
}
}
}), runBlocks;
}
function createInternalInjector(cache, factory) {
function getService(serviceName) {
if (cache.hasOwnProperty(serviceName)) {
if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
return cache[serviceName];
}
try {
return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName);
} catch (err) {
throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
} finally {
path.shift();
}
}
function invoke(fn, self, locals) {
var length, i, key, args = [], $inject = annotate(fn);
for (i = 0, length = $inject.length; length > i; i++) {
if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
args.push(locals && locals.hasOwnProperty(key) ? locals[key] :getService(key));
}
return isArray(fn) && (fn = fn[length]), fn.apply(self, args);
}
function instantiate(Type, locals) {
var instance, returnedValue, Constructor = function() {};
return Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] :Type).prototype, 
instance = new Constructor(), returnedValue = invoke(Type, instance, locals), isObject(returnedValue) || isFunction(returnedValue) ? returnedValue :instance;
}
return {
invoke:invoke,
instantiate:instantiate,
get:getService,
annotate:annotate,
has:function(name) {
return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
}
};
}
var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
$provide:{
provider:supportObject(provider),
factory:supportObject(factory),
service:supportObject(service),
value:supportObject(value),
constant:supportObject(constant),
decorator:decorator
}
}, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function() {
throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
}), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(servicename) {
var provider = providerInjector.get(servicename + providerSuffix);
return instanceInjector.invoke(provider.$get, provider);
});
return forEach(loadModules(modulesToLoad), function(fn) {
instanceInjector.invoke(fn || noop);
}), instanceInjector;
}
function $AnchorScrollProvider() {
var autoScrollingEnabled = !0;
this.disableAutoScrolling = function() {
autoScrollingEnabled = !1;
}, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
function getFirstAnchor(list) {
var result = null;
return forEach(list, function(element) {
result || "a" !== lowercase(element.nodeName) || (result = element);
}), result;
}
function scroll() {
var elm, hash = $location.hash();
hash ? (elm = document.getElementById(hash)) ? elm.scrollIntoView() :(elm = getFirstAnchor(document.getElementsByName(hash))) ? elm.scrollIntoView() :"top" === hash && $window.scrollTo(0, 0) :$window.scrollTo(0, 0);
}
var document = $window.document;
return autoScrollingEnabled && $rootScope.$watch(function() {
return $location.hash();
}, function() {
$rootScope.$evalAsync(scroll);
}), scroll;
} ];
}
function $$AsyncCallbackProvider() {
this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
return $$rAF.supported ? function(fn) {
return $$rAF(fn);
} :function(fn) {
return $timeout(fn, 0, !1);
};
} ];
}
function Browser(window, document, $log, $sniffer) {
function completeOutstandingRequest(fn) {
try {
fn.apply(null, sliceArgs(arguments, 1));
} finally {
if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
outstandingRequestCallbacks.pop()();
} catch (e) {
$log.error(e);
}
}
}
function startPoller(interval, setTimeout) {
!function check() {
forEach(pollFns, function(pollFn) {
pollFn();
}), pollTimeout = setTimeout(check, interval);
}();
}
function fireUrlChange() {
lastBrowserUrl != self.url() && (lastBrowserUrl = self.url(), forEach(urlChangeListeners, function(listener) {
listener(self.url());
}));
}
var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
self.isMock = !1;
var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
outstandingRequestCount++;
}, self.notifyWhenNoOutstandingRequests = function(callback) {
forEach(pollFns, function(pollFn) {
pollFn();
}), 0 === outstandingRequestCount ? callback() :outstandingRequestCallbacks.push(callback);
};
var pollTimeout, pollFns = [];
self.addPollFn = function(fn) {
return isUndefined(pollTimeout) && startPoller(100, setTimeout), pollFns.push(fn), 
fn;
};
var lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
self.url = function(url, replace) {
if (location !== window.location && (location = window.location), history !== window.history && (history = window.history), 
url) {
if (lastBrowserUrl == url) return;
var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
return lastBrowserUrl = url, !sameBase && $sniffer.history ? replace ? history.replaceState(null, "", url) :(history.pushState(null, "", url), 
baseElement.attr("href", baseElement.attr("href"))) :(sameBase || (reloadLocation = url), 
replace ? location.replace(url) :location.href = url), self;
}
return reloadLocation || location.href.replace(/%27/g, "'");
};
var urlChangeListeners = [], urlChangeInit = !1;
self.onUrlChange = function(callback) {
return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", fireUrlChange), 
$sniffer.hashchange ? jqLite(window).on("hashchange", fireUrlChange) :self.addPollFn(fireUrlChange), 
urlChangeInit = !0), urlChangeListeners.push(callback), callback;
}, self.$$checkUrlChange = fireUrlChange, self.baseHref = function() {
var href = baseElement.attr("href");
return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") :"";
};
var lastCookies = {}, lastCookieString = "", cookiePath = self.baseHref();
self.cookies = function(name, value) {
var cookieLength, cookieArray, cookie, i, index;
if (!name) {
if (rawDocument.cookie !== lastCookieString) for (lastCookieString = rawDocument.cookie, 
cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
index = cookie.indexOf("="), index > 0 && (name = unescape(cookie.substring(0, index)), 
lastCookies[name] === undefined && (lastCookies[name] = unescape(cookie.substring(index + 1))));
return lastCookies;
}
value === undefined ? rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" :isString(value) && (cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1, 
cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"));
}, self.defer = function(fn, delay) {
var timeoutId;
return outstandingRequestCount++, timeoutId = setTimeout(function() {
delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
}, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
}, self.defer.cancel = function(deferId) {
return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
completeOutstandingRequest(noop), !0) :!1;
};
}
function $BrowserProvider() {
this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
return new Browser($window, $document, $log, $sniffer);
} ];
}
function $CacheFactoryProvider() {
this.$get = function() {
function cacheFactory(cacheId, options) {
function refresh(entry) {
entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) :staleEnd = entry, 
link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
}
function link(nextEntry, prevEntry) {
nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
}
if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
var size = 0, stats = extend({}, options, {
id:cacheId
}), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
return caches[cacheId] = {
put:function(key, value) {
if (capacity < Number.MAX_VALUE) {
var lruEntry = lruHash[key] || (lruHash[key] = {
key:key
});
refresh(lruEntry);
}
if (!isUndefined(value)) return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
value;
},
get:function(key) {
if (capacity < Number.MAX_VALUE) {
var lruEntry = lruHash[key];
if (!lruEntry) return;
refresh(lruEntry);
}
return data[key];
},
remove:function(key) {
if (capacity < Number.MAX_VALUE) {
var lruEntry = lruHash[key];
if (!lruEntry) return;
lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), 
link(lruEntry.n, lruEntry.p), delete lruHash[key];
}
delete data[key], size--;
},
removeAll:function() {
data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null;
},
destroy:function() {
data = null, stats = null, lruHash = null, delete caches[cacheId];
},
info:function() {
return extend({}, stats, {
size:size
});
}
};
}
var caches = {};
return cacheFactory.info = function() {
var info = {};
return forEach(caches, function(cache, cacheId) {
info[cacheId] = cache.info();
}), info;
}, cacheFactory.get = function(cacheId) {
return caches[cacheId];
}, cacheFactory;
};
}
function $TemplateCacheProvider() {
this.$get = [ "$cacheFactory", function($cacheFactory) {
return $cacheFactory("templates");
} ];
}
function $CompileProvider($provide, $$sanitizeUriProvider) {
var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w_\-]+)(?:\:([^;]+))?;?)/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
this.directive = function registerDirective(name, directiveFactory) {
return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertArg(directiveFactory, "directiveFactory"), 
hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
var directives = [];
return forEach(hasDirectives[name], function(directiveFactory, index) {
try {
var directive = $injector.invoke(directiveFactory);
isFunction(directive) ? directive = {
compile:valueFn(directive)
} :!directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
directive.require = directive.require || directive.controller && directive.name, 
directive.restrict = directive.restrict || "A", directives.push(directive);
} catch (e) {
$exceptionHandler(e);
}
}), directives;
} ])), hasDirectives[name].push(directiveFactory)) :forEach(name, reverseParams(registerDirective)), 
this;
}, this.aHrefSanitizationWhitelist = function(regexp) {
return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
this) :$$sanitizeUriProvider.aHrefSanitizationWhitelist();
}, this.imgSrcSanitizationWhitelist = function(regexp) {
return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
this) :$$sanitizeUriProvider.imgSrcSanitizationWhitelist();
}, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
$compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function(node, index) {
3 == node.nodeType && node.nodeValue.match(/\S+/) && ($compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0]);
});
var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
return safeAddClass($compileNodes, "ng-scope"), function(scope, cloneConnectFn, transcludeControllers, parentBoundTranscludeFn) {
assertArg(scope, "scope");
var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) :$compileNodes;
forEach(transcludeControllers, function(instance, name) {
$linkNode.data("$" + name + "Controller", instance);
});
for (var i = 0, ii = $linkNode.length; ii > i; i++) {
var node = $linkNode[i], nodeType = node.nodeType;
(1 === nodeType || 9 === nodeType) && $linkNode.eq(i).data("$scope", scope);
}
return cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
$linkNode;
};
}
function safeAddClass($element, className) {
try {
$element.addClass(className);
} catch (e) {}
}
function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
var nodeLinkFn, childLinkFn, node, childScope, i, ii, n, childBoundTranscludeFn, nodeListLength = nodeList.length, stableNodeList = new Array(nodeListLength);
for (i = 0; nodeListLength > i; i++) stableNodeList[i] = nodeList[i];
for (i = 0, n = 0, ii = linkFns.length; ii > i; n++) node = stableNodeList[n], nodeLinkFn = linkFns[i++], 
childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
jqLite.data(node, "$scope", childScope)) :childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) :!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn :!parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) :null, 
nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) :childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
}
for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority :undefined, ignoreDirective), 
nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) :null, 
nodeLinkFn && nodeLinkFn.scope && safeAddClass(attrs.$$element, "ng-scope"), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null :compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude :transcludeFn), 
linkFns.push(nodeLinkFn, childLinkFn), linkFnFound = linkFnFound || nodeLinkFn || childLinkFn, 
previousCompileContext = null;
return linkFnFound ? compositeLinkFn :null;
}
function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
var boundTranscludeFn = function(transcludedScope, cloneFn, controllers) {
var scopeCreated = !1;
transcludedScope || (transcludedScope = scope.$new(), transcludedScope.$$transcluded = !0, 
scopeCreated = !0);
var clone = transcludeFn(transcludedScope, cloneFn, controllers, previousBoundTranscludeFn);
return scopeCreated && clone.on("$destroy", function() {
transcludedScope.$destroy();
}), clone;
};
return boundTranscludeFn;
}
function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
switch (nodeType) {
case 1:
addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
var attrStartName = !1, attrEndName = !1;
if (attr = nAttrs[j], !msie || msie >= 8 || attr.specified) {
name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), 
(isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = snake_case(ngAttrName.substr(6), "-"));
var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
ngAttrName === directiveNName + "Start" && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", 
name = name.substr(0, name.length - 6)), nName = directiveNormalize(name.toLowerCase()), 
attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName), 
addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
}
}
if (className = node.className, isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
className = className.substr(match.index + match[0].length);
break;

case 3:
addTextInterpolateDirective(directives, node.nodeValue);
break;

case 8:
try {
match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), 
addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
} catch (e) {}
}
return directives.sort(byPriority), directives;
}
function groupScan(node, attrStart, attrEnd) {
var nodes = [], depth = 0;
if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
do {
if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
1 == node.nodeType && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), 
nodes.push(node), node = node.nextSibling;
} while (depth > 0);
} else nodes.push(node);
return jqLite(nodes);
}
function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
return function(scope, element, attrs, controllers, transcludeFn) {
return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
};
}
function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
function addLinkFns(pre, post, attrStart, attrEnd) {
pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
isolateScope:!0
})), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
isolateScope:!0
})), postLinkFns.push(post));
}
function getControllers(directiveName, require, $element, elementControllers) {
var value, retrievalMethod = "data", optional = !1;
if (isString(require)) {
for (;"^" == (value = require.charAt(0)) || "?" == value; ) require = require.substr(1), 
"^" == value && (retrievalMethod = "inheritedData"), optional = optional || "?" == value;
if (value = null, elementControllers && "data" === retrievalMethod && (value = elementControllers[require]), 
value = value || $element[retrievalMethod]("$" + require + "Controller"), !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
return value;
}
return isArray(require) && (value = [], forEach(require, function(require) {
value.push(getControllers(directiveName, require, $element, elementControllers));
})), value;
}
function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
function controllersBoundTransclude(scope, cloneAttachFn) {
var transcludeControllers;
return arguments.length < 2 && (cloneAttachFn = scope, scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
}
var attrs, $element, i, ii, linkFn, controller, isolateScope, transcludeFn, elementControllers = {};
if (attrs = compileNode === linkNode ? templateAttrs :shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr)), 
$element = attrs.$$element, newIsolateScopeDirective) {
var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
isolateScope = scope.$new(!0), !templateDirective || templateDirective !== newIsolateScopeDirective && templateDirective !== newIsolateScopeDirective.$$originalDirective ? $element.data("$isolateScopeNoTemplate", isolateScope) :$element.data("$isolateScope", isolateScope), 
safeAddClass($element, "ng-isolate-scope"), forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
var lastValue, parentGet, parentSet, compare, match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, optional = "?" == match[2], mode = match[1];
switch (isolateScope.$$isolateBindings[scopeName] = mode + attrName, mode) {
case "@":
attrs.$observe(attrName, function(value) {
isolateScope[scopeName] = value;
}), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (isolateScope[scopeName] = $interpolate(attrs[attrName])(scope));
break;

case "=":
if (optional && !attrs[attrName]) return;
parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals :function(a, b) {
return a === b || a !== a && b !== b;
}, parentSet = parentGet.assign || function() {
throw lastValue = isolateScope[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
}, lastValue = isolateScope[scopeName] = parentGet(scope), isolateScope.$watch(function() {
var parentValue = parentGet(scope);
return compare(parentValue, isolateScope[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateScope[scopeName]) :isolateScope[scopeName] = parentValue), 
lastValue = parentValue;
}, null, parentGet.literal);
break;

case "&":
parentGet = $parse(attrs[attrName]), isolateScope[scopeName] = function(locals) {
return parentGet(scope, locals);
};
break;

default:
throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition);
}
});
}
for (transcludeFn = boundTranscludeFn && controllersBoundTransclude, controllerDirectives && forEach(controllerDirectives, function(directive) {
var controllerInstance, locals = {
$scope:directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope :scope,
$element:$element,
$attrs:attrs,
$transclude:transcludeFn
};
controller = directive.controller, "@" == controller && (controller = attrs[directive.name]), 
controllerInstance = $controller(controller, locals), elementControllers[directive.name] = controllerInstance, 
hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance), 
directive.controllerAs && (locals.$scope[directive.controllerAs] = controllerInstance);
}), i = 0, ii = preLinkFns.length; ii > i; i++) try {
linkFn = preLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope :scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
} catch (e) {
$exceptionHandler(e, startingTag($element));
}
var scopeToChild = scope;
for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), 
i = postLinkFns.length - 1; i >= 0; i--) try {
linkFn = postLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope :scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
} catch (e) {
$exceptionHandler(e, startingTag($element));
}
}
previousCompileContext = previousCompileContext || {};
for (var newScopeDirective, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
directive = directives[i];
var attrStart = directive.$$start, attrEnd = directive.$$end;
if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, 
terminalPriority > directive.priority) break;
if ((directiveValue = directive.scope) && (newScopeDirective = newScopeDirective || directive, 
directive.templateUrl || (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode), 
isObject(directiveValue) && (newIsolateScopeDirective = directive))), directiveName = directive.name, 
!directive.templateUrl && directive.controller && (directiveValue = directive.controller, 
controllerDirectives = controllerDirectives || {}, assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, 
directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, 
terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), 
compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
nonTlbTranscludeDirective:nonTlbTranscludeDirective
})) :($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), 
childTranscludeFn = compile($template, transcludeFn))), directive.template) if (hasTemplate = !0, 
assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, 
directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) :directive.template, 
directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] :jqLite(trim(directiveValue)), 
compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
replaceWith(jqCollection, $compileNode, compileNode);
var newTemplateAttrs = {
$attr:{}
}, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
} else $compileNode.html(directiveValue);
if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
templateDirective = directive, directive.replace && (replaceDirective = directive), 
nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
controllerDirectives:controllerDirectives,
newIsolateScopeDirective:newIsolateScopeDirective,
templateDirective:templateDirective,
nonTlbTranscludeDirective:nonTlbTranscludeDirective
}), ii = directives.length; else if (directive.compile) try {
linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) :linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
} catch (e) {
$exceptionHandler(e, startingTag($compileNode));
}
directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
}
return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
nodeLinkFn;
}
function markDirectivesAsIsolate(directives) {
for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
$$isolateScope:!0
});
}
function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
if (name === ignoreDirective) return null;
var match = null;
if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
$$start:startAttrName,
$$end:endAttrName
})), tDirectives.push(directive), match = directive);
} catch (e) {
$exceptionHandler(e);
}
return match;
}
function mergeTemplateAttributes(dst, src) {
var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
forEach(dst, function(value, key) {
"$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" :" ") + src[key]), 
dst.$set(key, value, !0, srcAttr[key]));
}), forEach(src, function(value, key) {
"class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " :"") + value) :"style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), 
dst.style = (dst.style ? dst.style + ";" :"") + value) :"$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, 
dstAttr[key] = srcAttr[key]);
});
}
function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
templateUrl:null,
transclude:null,
replace:null,
$$originalDirective:origAsyncDirective
}), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) :origAsyncDirective.templateUrl;
return $compileNode.empty(), $http.get($sce.getTrustedResourceUrl(templateUrl), {
cache:$templateCache
}).success(function(content) {
var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
if ($template = jqLiteIsTextNode(content) ? [] :jqLite(trim(content)), compileNode = $template[0], 
1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
tempTemplateAttrs = {
$attr:{}
}, replaceWith($rootElement, $compileNode, compileNode);
var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), 
directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
} else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
forEach($rootElement, function(node, i) {
node == compileNode && ($rootElement[i] = $compileNode[0]);
}), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
var oldClasses = beforeTemplateLinkNode.className;
previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
}
childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) :boundTranscludeFn, 
afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
}
linkQueue = null;
}).error(function(response, code, headers, config) {
throw $compileMinErr("tpload", "Failed to load template: {0}", config.url);
}), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
var childBoundTranscludeFn = boundTranscludeFn;
linkQueue ? (linkQueue.push(scope), linkQueue.push(node), linkQueue.push(rootElement), 
linkQueue.push(childBoundTranscludeFn)) :(afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn));
};
}
function byPriority(a, b) {
var diff = b.priority - a.priority;
return 0 !== diff ? diff :a.name !== b.name ? a.name < b.name ? -1 :1 :a.index - b.index;
}
function assertNoDuplicate(what, previousDirective, directive, element) {
if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
}
function addTextInterpolateDirective(directives, text) {
var interpolateFn = $interpolate(text, !0);
interpolateFn && directives.push({
priority:0,
compile:function(templateNode) {
var parent = templateNode.parent(), hasCompileParent = parent.length;
return hasCompileParent && safeAddClass(templateNode.parent(), "ng-binding"), function(scope, node) {
var parent = node.parent(), bindings = parent.data("$binding") || [];
bindings.push(interpolateFn), parent.data("$binding", bindings), hasCompileParent || safeAddClass(parent, "ng-binding"), 
scope.$watch(interpolateFn, function(value) {
node[0].nodeValue = value;
});
};
}
});
}
function getTrustedContext(node, attrNormalizedName) {
if ("srcdoc" == attrNormalizedName) return $sce.HTML;
var tag = nodeName_(node);
return "xlinkHref" == attrNormalizedName || "FORM" == tag && "action" == attrNormalizedName || "IMG" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL :void 0;
}
function addAttrInterpolateDirective(node, directives, value, name) {
var interpolateFn = $interpolate(value, !0);
if (interpolateFn) {
if ("multiple" === name && "SELECT" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
directives.push({
priority:100,
compile:function() {
return {
pre:function(scope, element, attr) {
var $$observers = attr.$$observers || (attr.$$observers = {});
if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
interpolateFn = $interpolate(attr[name], !0, getTrustedContext(node, name)), interpolateFn && (attr[name] = interpolateFn(scope), 
($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
"class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) :attr.$set(name, newValue);
}));
}
};
}
});
}
}
function replaceWith($rootElement, elementsToRemove, newNode) {
var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] == firstElementToRemove) {
$rootElement[i++] = newNode;
for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] :delete $rootElement[j];
$rootElement.length -= removeCount - 1;
break;
}
parent && parent.replaceChild(newNode, firstElementToRemove);
var fragment = document.createDocumentFragment();
fragment.appendChild(firstElementToRemove), newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
var element = elementsToRemove[k];
jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k];
}
elementsToRemove[0] = newNode, elementsToRemove.length = 1;
}
function cloneAndAnnotateFn(fn, annotation) {
return extend(function() {
return fn.apply(null, arguments);
}, fn, annotation);
}
var Attributes = function(element, attr) {
this.$$element = element, this.$attr = attr || {};
};
Attributes.prototype = {
$normalize:directiveNormalize,
$addClass:function(classVal) {
classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
},
$removeClass:function(classVal) {
classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
},
$updateClass:function(newClasses, oldClasses) {
var toAdd = tokenDifference(newClasses, oldClasses), toRemove = tokenDifference(oldClasses, newClasses);
0 === toAdd.length ? $animate.removeClass(this.$$element, toRemove) :0 === toRemove.length ? $animate.addClass(this.$$element, toAdd) :$animate.setClass(this.$$element, toAdd, toRemove);
},
$set:function(key, value, writeAttr, attrName) {
var nodeName, booleanKey = getBooleanAttrName(this.$$element[0], key);
booleanKey && (this.$$element.prop(key, value), attrName = booleanKey), this[key] = value, 
attrName ? this.$attr[key] = attrName :(attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), 
nodeName = nodeName_(this.$$element), ("A" === nodeName && "href" === key || "IMG" === nodeName && "src" === key) && (this[key] = value = $$sanitizeUri(value, "src" === key)), 
writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) :this.$$element.attr(attrName, value));
var $$observers = this.$$observers;
$$observers && forEach($$observers[key], function(fn) {
try {
fn(value);
} catch (e) {
$exceptionHandler(e);
}
});
},
$observe:function(key, fn) {
var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
return listeners.push(fn), $rootScope.$evalAsync(function() {
listeners.$$inter || fn(attrs[key]);
}), fn;
}
};
var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity :function(template) {
return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
}, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
return compile;
} ];
}
function directiveNormalize(name) {
return camelCase(name.replace(PREFIX_REGEXP, ""));
}
function tokenDifference(str1, str2) {
var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
outer:for (var i = 0; i < tokens1.length; i++) {
for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
values += (values.length > 0 ? " " :"") + token;
}
return values;
}
function $ControllerProvider() {
var controllers = {}, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
this.register = function(name, constructor) {
assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) :controllers[name] = constructor;
}, this.$get = [ "$injector", "$window", function($injector, $window) {
return function(expression, locals) {
var instance, match, constructor, identifier;
if (isString(expression) && (match = expression.match(CNTRL_REG), constructor = match[1], 
identifier = match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] :getter(locals.$scope, constructor, !0) || getter($window, constructor, !0), 
assertArgFn(expression, constructor, !0)), instance = $injector.instantiate(expression, locals), 
identifier) {
if (!locals || "object" != typeof locals.$scope) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
locals.$scope[identifier] = instance;
}
return instance;
};
} ];
}
function $DocumentProvider() {
this.$get = [ "$window", function(window) {
return jqLite(window.document);
} ];
}
function $ExceptionHandlerProvider() {
this.$get = [ "$log", function($log) {
return function() {
$log.error.apply($log, arguments);
};
} ];
}
function parseHeaders(headers) {
var key, val, i, parsed = {};
return headers ? (forEach(headers.split("\n"), function(line) {
i = line.indexOf(":"), key = lowercase(trim(line.substr(0, i))), val = trim(line.substr(i + 1)), 
key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val :val);
}), parsed) :parsed;
}
function headersGetter(headers) {
var headersObj = isObject(headers) ? headers :undefined;
return function(name) {
return headersObj || (headersObj = parseHeaders(headers)), name ? headersObj[lowercase(name)] || null :headersObj;
};
}
function transformData(data, headers, fns) {
return isFunction(fns) ? fns(data, headers) :(forEach(fns, function(fn) {
data = fn(data, headers);
}), data);
}
function isSuccess(status) {
return status >= 200 && 300 > status;
}
function $HttpProvider() {
var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/, CONTENT_TYPE_APPLICATION_JSON = {
"Content-Type":"application/json;charset=utf-8"
}, defaults = this.defaults = {
transformResponse:[ function(data) {
return isString(data) && (data = data.replace(PROTECTION_PREFIX, ""), JSON_START.test(data) && JSON_END.test(data) && (data = fromJson(data))), 
data;
} ],
transformRequest:[ function(d) {
return !isObject(d) || isFile(d) || isBlob(d) ? d :toJson(d);
} ],
headers:{
common:{
Accept:"application/json, text/plain, */*"
},
post:shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
put:shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
patch:shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
},
xsrfCookieName:"XSRF-TOKEN",
xsrfHeaderName:"X-XSRF-TOKEN"
}, interceptorFactories = this.interceptors = [], responseInterceptorFactories = this.responseInterceptors = [];
this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
function $http(requestConfig) {
function transformResponse(response) {
var resp = extend({}, response, {
data:transformData(response.data, response.headers, config.transformResponse)
});
return isSuccess(response.status) ? resp :$q.reject(resp);
}
function mergeHeaders(config) {
function execHeaders(headers) {
var headerContent;
forEach(headers, function(headerFn, header) {
isFunction(headerFn) && (headerContent = headerFn(), null != headerContent ? headers[header] = headerContent :delete headers[header]);
});
}
var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
defaultHeadersIteration:for (defHeaderName in defHeaders) {
lowercaseDefHeaderName = lowercase(defHeaderName);
for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
reqHeaders[defHeaderName] = defHeaders[defHeaderName];
}
return execHeaders(reqHeaders), reqHeaders;
}
var config = {
method:"get",
transformRequest:defaults.transformRequest,
transformResponse:defaults.transformResponse
}, headers = mergeHeaders(requestConfig);
extend(config, requestConfig), config.headers = headers, config.method = uppercase(config.method);
var serverRequest = function(config) {
headers = config.headers;
var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
return isUndefined(reqData) && forEach(headers, function(value, header) {
"content-type" === lowercase(header) && delete headers[header];
}), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
sendReq(config, reqData, headers).then(transformResponse, transformResponse);
}, chain = [ serverRequest, undefined ], promise = $q.when(config);
for (forEach(reversedInterceptors, function(interceptor) {
(interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), 
(interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError);
}); chain.length; ) {
var thenFn = chain.shift(), rejectFn = chain.shift();
promise = promise.then(thenFn, rejectFn);
}
return promise.success = function(fn) {
return promise.then(function(response) {
fn(response.data, response.status, response.headers, config);
}), promise;
}, promise.error = function(fn) {
return promise.then(null, function(response) {
fn(response.data, response.status, response.headers, config);
}), promise;
}, promise;
}
function createShortMethods() {
forEach(arguments, function(name) {
$http[name] = function(url, config) {
return $http(extend(config || {}, {
method:name,
url:url
}));
};
});
}
function createShortMethodsWithData() {
forEach(arguments, function(name) {
$http[name] = function(url, data, config) {
return $http(extend(config || {}, {
method:name,
url:url,
data:data
}));
};
});
}
function sendReq(config, reqData, reqHeaders) {
function done(status, response, headersString, statusText) {
cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) :cache.remove(url)), 
resolvePromise(response, status, headersString, statusText), $rootScope.$$phase || $rootScope.$apply();
}
function resolvePromise(response, status, headers, statusText) {
status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve :deferred.reject)({
data:response,
status:status,
headers:headersGetter(headers),
config:config,
statusText:statusText
});
}
function removePendingReq() {
var idx = indexOf($http.pendingRequests, config);
-1 !== idx && $http.pendingRequests.splice(idx, 1);
}
var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, url = buildUrl(config.url, config.params);
if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
!config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache :isObject(defaults.cache) ? defaults.cache :defaultCache), 
cache) if (cachedResp = cache.get(url), isDefined(cachedResp)) {
if (isPromiseLike(cachedResp)) return cachedResp.then(removePendingReq, removePendingReq), 
cachedResp;
isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) :resolvePromise(cachedResp, 200, {}, "OK");
} else cache.put(url, promise);
if (isUndefined(cachedResp)) {
var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] :undefined;
xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
$httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
}
return promise;
}
function buildUrl(url, params) {
if (!params) return url;
var parts = [];
return forEachSorted(params, function(value, key) {
null === value || isUndefined(value) || (isArray(value) || (value = [ value ]), 
forEach(value, function(v) {
isObject(v) && (v = isDate(v) ? v.toISOString() :toJson(v)), parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
}));
}), parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" :"&") + parts.join("&")), 
url;
}
var defaultCache = $cacheFactory("$http"), reversedInterceptors = [];
return forEach(interceptorFactories, function(interceptorFactory) {
reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) :$injector.invoke(interceptorFactory));
}), forEach(responseInterceptorFactories, function(interceptorFactory, index) {
var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) :$injector.invoke(interceptorFactory);
reversedInterceptors.splice(index, 0, {
response:function(response) {
return responseFn($q.when(response));
},
responseError:function(response) {
return responseFn($q.reject(response));
}
});
}), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http;
} ];
}
function createXhr(method) {
if (8 >= msie && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) return new window.ActiveXObject("Microsoft.XMLHTTP");
if (window.XMLHttpRequest) return new window.XMLHttpRequest();
throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.");
}
function $HttpBackendProvider() {
this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
} ];
}
function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
function jsonpReq(url, callbackId, done) {
var script = rawDocument.createElement("script"), callback = null;
return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), 
rawDocument.body.removeChild(script), script = null;
var status = -1, text = "unknown";
event && ("load" !== event.type || callbacks[callbackId].called || (event = {
type:"error"
}), text = event.type, status = "error" === event.type ? 404 :200), done && done(status, text);
}, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), 
8 >= msie && (script.onreadystatechange = function() {
isString(script.readyState) && /loaded|complete/.test(script.readyState) && (script.onreadystatechange = null, 
callback({
type:"load"
}));
}), rawDocument.body.appendChild(script), callback;
}
var ABORTED = -1;
return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
function timeoutRequest() {
status = ABORTED, jsonpDone && jsonpDone(), xhr && xhr.abort();
}
function completeRequest(callback, status, response, headersString, statusText) {
timeoutId && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 0 === status && (status = response ? 200 :"file" == urlResolve(url).protocol ? 404 :0), 
status = 1223 === status ? 204 :status, statusText = statusText || "", callback(status, response, headersString, statusText), 
$browser.$$completeOutstandingRequest(noop);
}
var status;
if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
var callbackId = "_" + (callbacks.counter++).toString(36);
callbacks[callbackId] = function(data) {
callbacks[callbackId].data = data, callbacks[callbackId].called = !0;
};
var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop;
});
} else {
var xhr = createXhr(method);
if (xhr.open(method, url, !0), forEach(headers, function(value, key) {
isDefined(value) && xhr.setRequestHeader(key, value);
}), xhr.onreadystatechange = function() {
if (xhr && 4 == xhr.readyState) {
var responseHeaders = null, response = null, statusText = "";
status !== ABORTED && (responseHeaders = xhr.getAllResponseHeaders(), response = "response" in xhr ? xhr.response :xhr.responseText), 
status === ABORTED && 10 > msie || (statusText = xhr.statusText), completeRequest(callback, status || xhr.status, response, responseHeaders, statusText);
}
}, withCredentials && (xhr.withCredentials = !0), responseType) try {
xhr.responseType = responseType;
} catch (e) {
if ("json" !== responseType) throw e;
}
xhr.send(post || null);
}
if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
};
}
function $InterpolateProvider() {
var startSymbol = "{{", endSymbol = "}}";
this.startSymbol = function(value) {
return value ? (startSymbol = value, this) :startSymbol;
}, this.endSymbol = function(value) {
return value ? (endSymbol = value, this) :endSymbol;
}, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
function $interpolate(text, mustHaveExpression, trustedContext) {
for (var startIndex, endIndex, fn, exp, index = 0, parts = [], length = text.length, hasInterpolation = !1, concat = []; length > index; ) -1 != (startIndex = text.indexOf(startSymbol, index)) && -1 != (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) ? (index != startIndex && parts.push(text.substring(index, startIndex)), 
parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex))), 
fn.exp = exp, index = endIndex + endSymbolLength, hasInterpolation = !0) :(index != length && parts.push(text.substring(index)), 
index = length);
if ((length = parts.length) || (parts.push(""), length = 1), trustedContext && parts.length > 1) throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
return !mustHaveExpression || hasInterpolation ? (concat.length = length, fn = function(context) {
try {
for (var part, i = 0, ii = length; ii > i; i++) {
if ("function" == typeof (part = parts[i])) if (part = part(context), part = trustedContext ? $sce.getTrusted(trustedContext, part) :$sce.valueOf(part), 
null == part) part = ""; else switch (typeof part) {
case "string":
break;

case "number":
part = "" + part;
break;

default:
part = toJson(part);
}
concat[i] = part;
}
return concat.join("");
} catch (err) {
var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
$exceptionHandler(newErr);
}
}, fn.exp = text, fn.parts = parts, fn) :void 0;
}
var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
return $interpolate.startSymbol = function() {
return startSymbol;
}, $interpolate.endSymbol = function() {
return endSymbol;
}, $interpolate;
} ];
}
function $IntervalProvider() {
this.$get = [ "$rootScope", "$window", "$q", function($rootScope, $window, $q) {
function interval(fn, delay, count, invokeApply) {
var setInterval = $window.setInterval, clearInterval = $window.clearInterval, deferred = $q.defer(), promise = deferred.promise, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply;
return count = isDefined(count) ? count :0, promise.then(null, null, fn), promise.$$intervalId = setInterval(function() {
deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), 
clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
}, delay), intervals[promise.$$intervalId] = deferred, promise;
}
var intervals = {};
return interval.cancel = function(promise) {
return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), 
$window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], 
!0) :!1;
}, interval;
} ];
}
function $LocaleProvider() {
this.$get = function() {
return {
id:"en-us",
NUMBER_FORMATS:{
DECIMAL_SEP:".",
GROUP_SEP:",",
PATTERNS:[ {
minInt:1,
minFrac:0,
maxFrac:3,
posPre:"",
posSuf:"",
negPre:"-",
negSuf:"",
gSize:3,
lgSize:3
}, {
minInt:1,
minFrac:2,
maxFrac:2,
posPre:"\xa4",
posSuf:"",
negPre:"(\xa4",
negSuf:")",
gSize:3,
lgSize:3
} ],
CURRENCY_SYM:"$"
},
DATETIME_FORMATS:{
MONTH:"January,February,March,April,May,June,July,August,September,October,November,December".split(","),
SHORTMONTH:"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
DAY:"Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
SHORTDAY:"Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
AMPMS:[ "AM", "PM" ],
medium:"MMM d, y h:mm:ss a",
"short":"M/d/yy h:mm a",
fullDate:"EEEE, MMMM d, y",
longDate:"MMMM d, y",
mediumDate:"MMM d, y",
shortDate:"M/d/yy",
mediumTime:"h:mm:ss a",
shortTime:"h:mm a"
},
pluralCat:function(num) {
return 1 === num ? "one" :"other";
}
};
};
}
function encodePath(path) {
for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
return segments.join("/");
}
function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
var parsedUrl = urlResolve(absoluteUrl, appBase);
locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
}
function parseAppUrl(relativeUrl, locationObj, appBase) {
var prefixed = "/" !== relativeUrl.charAt(0);
prefixed && (relativeUrl = "/" + relativeUrl);
var match = urlResolve(relativeUrl, appBase);
locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) :match.pathname), 
locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
}
function beginsWith(begin, whole) {
return 0 === whole.indexOf(begin) ? whole.substr(begin.length) :void 0;
}
function stripHash(url) {
var index = url.indexOf("#");
return -1 == index ? url :url.substr(0, index);
}
function stripFile(url) {
return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
}
function serverBase(url) {
return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
}
function LocationHtml5Url(appBase, basePrefix) {
this.$$html5 = !0, basePrefix = basePrefix || "";
var appBaseNoFile = stripFile(appBase);
parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function(url) {
var pathUrl = beginsWith(appBaseNoFile, url);
if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
parseAppUrl(pathUrl, this, appBase), this.$$path || (this.$$path = "/"), this.$$compose();
}, this.$$compose = function() {
var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) :"";
this.$$url = encodePath(this.$$path) + (search ? "?" + search :"") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
}, this.$$parseLinkUrl = function(url) {
var appUrl, prevAppUrl, rewrittenUrl;
return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, 
rewrittenUrl = (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) :appBase + prevAppUrl) :(appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? rewrittenUrl = appBaseNoFile + appUrl :appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile), 
rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
};
}
function LocationHashbangUrl(appBase, hashPrefix) {
var appBaseNoFile = stripFile(appBase);
parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function(url) {
function removeWindowsDriveName(path, url, base) {
var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path :(firstPathSegmentMatch = windowsFilePathExp.exec(path), 
firstPathSegmentMatch ? firstPathSegmentMatch[1] :path);
}
var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url), withoutHashUrl = "#" == withoutBaseUrl.charAt(0) ? beginsWith(hashPrefix, withoutBaseUrl) :this.$$html5 ? withoutBaseUrl :"";
if (!isString(withoutHashUrl)) throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
parseAppUrl(withoutHashUrl, this, appBase), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), 
this.$$compose();
}, this.$$compose = function() {
var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) :"";
this.$$url = encodePath(this.$$path) + (search ? "?" + search :"") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url :"");
}, this.$$parseLinkUrl = function(url) {
return stripHash(appBase) == stripHash(url) ? (this.$$parse(url), !0) :!1;
};
}
function LocationHashbangInHtml5Url(appBase, hashPrefix) {
this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
var appBaseNoFile = stripFile(appBase);
this.$$parseLinkUrl = function(url) {
var rewrittenUrl, appUrl;
return appBase == stripHash(url) ? rewrittenUrl = url :(appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl :appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
}, this.$$compose = function() {
var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) :"";
this.$$url = encodePath(this.$$path) + (search ? "?" + search :"") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
};
}
function locationGetter(property) {
return function() {
return this[property];
};
}
function locationGetterSetter(property, preprocess) {
return function(value) {
return isUndefined(value) ? this[property] :(this[property] = preprocess(value), 
this.$$compose(), this);
};
}
function $LocationProvider() {
var hashPrefix = "", html5Mode = !1;
this.hashPrefix = function(prefix) {
return isDefined(prefix) ? (hashPrefix = prefix, this) :hashPrefix;
}, this.html5Mode = function(mode) {
return isDefined(mode) ? (html5Mode = mode, this) :html5Mode;
}, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", function($rootScope, $browser, $sniffer, $rootElement) {
function afterLocationChange(oldUrl) {
$rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl);
}
var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
html5Mode ? (appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url :LocationHashbangInHtml5Url) :(appBase = stripHash(initialUrl), 
LocationMode = LocationHashbangUrl), $location = new LocationMode(appBase, "#" + hashPrefix), 
$location.$$parseLinkUrl(initialUrl, initialUrl);
var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
$rootElement.on("click", function(event) {
if (!event.ctrlKey && !event.metaKey && 2 != event.which) {
for (var elm = jqLite(event.target); "a" !== lowercase(elm[0].nodeName); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
$location.absUrl() != $browser.url() && ($rootScope.$apply(), window.angular["ff-684208-preventDefault"] = !0));
}
}), $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0), $browser.onUrlChange(function(newUrl) {
$location.absUrl() != newUrl && ($rootScope.$evalAsync(function() {
var oldUrl = $location.absUrl();
$location.$$parse(newUrl), $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented ? ($location.$$parse(oldUrl), 
$browser.url(oldUrl)) :afterLocationChange(oldUrl);
}), $rootScope.$$phase || $rootScope.$digest());
});
var changeCounter = 0;
return $rootScope.$watch(function() {
var oldUrl = $browser.url(), currentReplace = $location.$$replace;
return changeCounter && oldUrl == $location.absUrl() || (changeCounter++, $rootScope.$evalAsync(function() {
$rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented ? $location.$$parse(oldUrl) :($browser.url($location.absUrl(), currentReplace), 
afterLocationChange(oldUrl));
})), $location.$$replace = !1, changeCounter;
}), $location;
} ];
}
function $LogProvider() {
var debug = !0, self = this;
this.debugEnabled = function(flag) {
return isDefined(flag) ? (debug = flag, this) :debug;
}, this.$get = [ "$window", function($window) {
function formatError(arg) {
return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack :arg.stack :arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
arg;
}
function consoleLog(type) {
var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
try {
hasApply = !!logFn.apply;
} catch (e) {}
return hasApply ? function() {
var args = [];
return forEach(arguments, function(arg) {
args.push(formatError(arg));
}), logFn.apply(console, args);
} :function(arg1, arg2) {
logFn(arg1, null == arg2 ? "" :arg2);
};
}
return {
log:consoleLog("log"),
info:consoleLog("info"),
warn:consoleLog("warn"),
error:consoleLog("error"),
debug:function() {
var fn = consoleLog("debug");
return function() {
debug && fn.apply(self, arguments);
};
}()
};
} ];
}
function ensureSafeMemberName(name, fullExpression) {
if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name) throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
return name;
}
function ensureSafeObject(obj, fullExpression) {
if (obj) {
if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
if (obj.document && obj.location && obj.alert && obj.setInterval) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
if (obj === Object) throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
}
return obj;
}
function ensureSafeFunction(obj, fullExpression) {
if (obj) {
if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
if (obj === CALL || obj === APPLY || BIND && obj === BIND) throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
}
}
function setter(obj, path, setValue, fullExp, options) {
ensureSafeObject(obj, fullExp), options = options || {};
for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
key = ensureSafeMemberName(element.shift(), fullExp);
var propertyObj = ensureSafeObject(obj[key], fullExp);
propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = propertyObj, obj.then && options.unwrapPromises && (promiseWarning(fullExp), 
"$$v" in obj || !function(promise) {
promise.then(function(val) {
promise.$$v = val;
});
}(obj), obj.$$v === undefined && (obj.$$v = {}), obj = obj.$$v);
}
return key = ensureSafeMemberName(element.shift(), fullExp), ensureSafeObject(obj[key], fullExp), 
obj[key] = setValue, setValue;
}
function isPossiblyDangerousMemberName(name) {
return "constructor" == name;
}
function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp), ensureSafeMemberName(key2, fullExp), 
ensureSafeMemberName(key3, fullExp), ensureSafeMemberName(key4, fullExp);
var eso = function(o) {
return ensureSafeObject(o, fullExp);
}, expensiveChecks = options.expensiveChecks, eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso :identity, eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso :identity, eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso :identity, eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso :identity, eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso :identity;
return options.unwrapPromises ? function(scope, locals) {
var promise, pathVal = locals && locals.hasOwnProperty(key0) ? locals :scope;
return null == pathVal ? pathVal :(pathVal = eso0(pathVal[key0]), pathVal && pathVal.then && (promiseWarning(fullExp), 
"$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function(val) {
promise.$$v = eso0(val);
})), pathVal = eso0(pathVal.$$v)), key1 ? null == pathVal ? undefined :(pathVal = eso1(pathVal[key1]), 
pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
promise.$$v = undefined, promise.then(function(val) {
promise.$$v = eso1(val);
})), pathVal = eso1(pathVal.$$v)), key2 ? null == pathVal ? undefined :(pathVal = eso2(pathVal[key2]), 
pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
promise.$$v = undefined, promise.then(function(val) {
promise.$$v = eso2(val);
})), pathVal = eso2(pathVal.$$v)), key3 ? null == pathVal ? undefined :(pathVal = eso3(pathVal[key3]), 
pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
promise.$$v = undefined, promise.then(function(val) {
promise.$$v = eso3(val);
})), pathVal = eso3(pathVal.$$v)), key4 ? null == pathVal ? undefined :(pathVal = eso4(pathVal[key4]), 
pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
promise.$$v = undefined, promise.then(function(val) {
promise.$$v = eso4(val);
})), pathVal = eso4(pathVal.$$v)), pathVal) :pathVal) :pathVal) :pathVal) :pathVal);
} :function(scope, locals) {
var pathVal = locals && locals.hasOwnProperty(key0) ? locals :scope;
return null == pathVal ? pathVal :(pathVal = eso0(pathVal[key0]), key1 ? null == pathVal ? undefined :(pathVal = eso1(pathVal[key1]), 
key2 ? null == pathVal ? undefined :(pathVal = eso2(pathVal[key2]), key3 ? null == pathVal ? undefined :(pathVal = eso3(pathVal[key3]), 
key4 ? null == pathVal ? undefined :pathVal = eso4(pathVal[key4]) :pathVal) :pathVal) :pathVal) :pathVal);
};
}
function getterFnWithExtraArgs(fn, fullExpression) {
return function(s, l) {
return fn(s, l, promiseWarning, ensureSafeObject, fullExpression);
};
}
function getterFn(path, options, fullExp) {
var expensiveChecks = options.expensiveChecks, getterFnCache = expensiveChecks ? getterFnCacheExpensive :getterFnCacheDefault;
if (getterFnCache.hasOwnProperty(path)) return getterFnCache[path];
var fn, pathKeys = path.split("."), pathKeysLength = pathKeys.length;
if (options.csp) fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options) :function(scope, locals) {
var val, i = 0;
do val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals), 
locals = undefined, scope = val; while (pathKeysLength > i);
return val;
}; else {
var code = "var p;\n";
expensiveChecks && (code += "s = eso(s, fe);\nl = eso(l, fe);\n");
var needsEnsureSafeObject = expensiveChecks;
forEach(pathKeys, function(key, index) {
ensureSafeMemberName(key, fullExp);
var lookupJs = (index ? "s" :'((l&&l.hasOwnProperty("' + key + '"))?l:s)') + '["' + key + '"]', wrapWithEso = expensiveChecks || isPossiblyDangerousMemberName(key);
wrapWithEso && (lookupJs = "eso(" + lookupJs + ", fe)", needsEnsureSafeObject = !0), 
code += "if(s == null) return undefined;\ns=" + lookupJs + ";\n", options.unwrapPromises && (code += 'if (s && s.then) {\n pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=' + (wrapWithEso ? "eso(v)" :"v") + ";});\n}\n s=" + (wrapWithEso ? "eso(s.$$v)" :"s.$$v") + "\n}\n");
}), code += "return s;";
var evaledFnGetter = new Function("s", "l", "pw", "eso", "fe", code);
evaledFnGetter.toString = valueFn(code), (needsEnsureSafeObject || options.unwrapPromises) && (evaledFnGetter = getterFnWithExtraArgs(evaledFnGetter, fullExp)), 
fn = evaledFnGetter;
}
return "hasOwnProperty" !== path && (getterFnCache[path] = fn), fn;
}
function $ParseProvider() {
var cacheDefault = {}, cacheExpensive = {}, $parseOptions = {
csp:!1,
unwrapPromises:!1,
logPromiseWarnings:!0,
expensiveChecks:!1
};
this.unwrapPromises = function(value) {
return isDefined(value) ? ($parseOptions.unwrapPromises = !!value, this) :$parseOptions.unwrapPromises;
}, this.logPromiseWarnings = function(value) {
return isDefined(value) ? ($parseOptions.logPromiseWarnings = value, this) :$parseOptions.logPromiseWarnings;
}, this.$get = [ "$filter", "$sniffer", "$log", function($filter, $sniffer, $log) {
$parseOptions.csp = $sniffer.csp;
var $parseOptionsExpensive = {
csp:$parseOptions.csp,
unwrapPromises:$parseOptions.unwrapPromises,
logPromiseWarnings:$parseOptions.logPromiseWarnings,
expensiveChecks:!0
};
return promiseWarning = function(fullExp) {
$parseOptions.logPromiseWarnings && !promiseWarningCache.hasOwnProperty(fullExp) && (promiseWarningCache[fullExp] = !0, 
$log.warn("[$parse] Promise found in the expression `" + fullExp + "`. Automatic unwrapping of promises in Angular expressions is deprecated."));
}, function(exp, expensiveChecks) {
var parsedExpression;
switch (typeof exp) {
case "string":
var cache = expensiveChecks ? cacheExpensive :cacheDefault;
if (cache.hasOwnProperty(exp)) return cache[exp];
var parseOptions = expensiveChecks ? $parseOptionsExpensive :$parseOptions, lexer = new Lexer(parseOptions), parser = new Parser(lexer, $filter, parseOptions);
return parsedExpression = parser.parse(exp), "hasOwnProperty" !== exp && (cache[exp] = parsedExpression), 
parsedExpression;

case "function":
return exp;

default:
return noop;
}
};
} ];
}
function $QProvider() {
this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
return qFactory(function(callback) {
$rootScope.$evalAsync(callback);
}, $exceptionHandler);
} ];
}
function qFactory(nextTick, exceptionHandler) {
function defaultCallback(value) {
return value;
}
function defaultErrback(reason) {
return reject(reason);
}
function all(promises) {
var deferred = defer(), counter = 0, results = isArray(promises) ? [] :{};
return forEach(promises, function(promise, key) {
counter++, ref(promise).then(function(value) {
results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results));
}, function(reason) {
results.hasOwnProperty(key) || deferred.reject(reason);
});
}), 0 === counter && deferred.resolve(results), deferred.promise;
}
var defer = function() {
var value, deferred, pending = [];
return deferred = {
resolve:function(val) {
if (pending) {
var callbacks = pending;
pending = undefined, value = ref(val), callbacks.length && nextTick(function() {
for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], 
value.then(callback[0], callback[1], callback[2]);
});
}
},
reject:function(reason) {
deferred.resolve(createInternalRejectedPromise(reason));
},
notify:function(progress) {
if (pending) {
var callbacks = pending;
pending.length && nextTick(function() {
for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], 
callback[2](progress);
});
}
},
promise:{
then:function(callback, errback, progressback) {
var result = defer(), wrappedCallback = function(value) {
try {
result.resolve((isFunction(callback) ? callback :defaultCallback)(value));
} catch (e) {
result.reject(e), exceptionHandler(e);
}
}, wrappedErrback = function(reason) {
try {
result.resolve((isFunction(errback) ? errback :defaultErrback)(reason));
} catch (e) {
result.reject(e), exceptionHandler(e);
}
}, wrappedProgressback = function(progress) {
try {
result.notify((isFunction(progressback) ? progressback :defaultCallback)(progress));
} catch (e) {
exceptionHandler(e);
}
};
return pending ? pending.push([ wrappedCallback, wrappedErrback, wrappedProgressback ]) :value.then(wrappedCallback, wrappedErrback, wrappedProgressback), 
result.promise;
},
"catch":function(callback) {
return this.then(null, callback);
},
"finally":function(callback) {
function makePromise(value, resolved) {
var result = defer();
return resolved ? result.resolve(value) :result.reject(value), result.promise;
}
function handleCallback(value, isResolved) {
var callbackOutput = null;
try {
callbackOutput = (callback || defaultCallback)();
} catch (e) {
return makePromise(e, !1);
}
return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
return makePromise(value, isResolved);
}, function(error) {
return makePromise(error, !1);
}) :makePromise(value, isResolved);
}
return this.then(function(value) {
return handleCallback(value, !0);
}, function(error) {
return handleCallback(error, !1);
});
}
}
};
}, ref = function(value) {
return isPromiseLike(value) ? value :{
then:function(callback) {
var result = defer();
return nextTick(function() {
result.resolve(callback(value));
}), result.promise;
}
};
}, reject = function(reason) {
var result = defer();
return result.reject(reason), result.promise;
}, createInternalRejectedPromise = function(reason) {
return {
then:function(callback, errback) {
var result = defer();
return nextTick(function() {
try {
result.resolve((isFunction(errback) ? errback :defaultErrback)(reason));
} catch (e) {
result.reject(e), exceptionHandler(e);
}
}), result.promise;
}
};
}, when = function(value, callback, errback, progressback) {
var done, result = defer(), wrappedCallback = function(value) {
try {
return (isFunction(callback) ? callback :defaultCallback)(value);
} catch (e) {
return exceptionHandler(e), reject(e);
}
}, wrappedErrback = function(reason) {
try {
return (isFunction(errback) ? errback :defaultErrback)(reason);
} catch (e) {
return exceptionHandler(e), reject(e);
}
}, wrappedProgressback = function(progress) {
try {
return (isFunction(progressback) ? progressback :defaultCallback)(progress);
} catch (e) {
exceptionHandler(e);
}
};
return nextTick(function() {
ref(value).then(function(value) {
done || (done = !0, result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback)));
}, function(reason) {
done || (done = !0, result.resolve(wrappedErrback(reason)));
}, function(progress) {
done || result.notify(wrappedProgressback(progress));
});
}), result.promise;
};
return {
defer:defer,
reject:reject,
when:when,
all:all
};
}
function $$RAFProvider() {
this.$get = [ "$window", "$timeout", function($window, $timeout) {
var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
var id = requestAnimationFrame(fn);
return function() {
cancelAnimationFrame(id);
};
} :function(fn) {
var timer = $timeout(fn, 16.66, !1);
return function() {
$timeout.cancel(timer);
};
};
return raf.supported = rafSupported, raf;
} ];
}
function $RootScopeProvider() {
var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null;
this.digestTtl = function(value) {
return arguments.length && (TTL = value), TTL;
}, this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
function Scope() {
this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
this["this"] = this.$root = this, this.$$destroyed = !1, this.$$asyncQueue = [], 
this.$$postDigestQueue = [], this.$$listeners = {}, this.$$listenerCount = {}, this.$$isolateBindings = {};
}
function beginPhase(phase) {
if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
$rootScope.$$phase = phase;
}
function clearPhase() {
$rootScope.$$phase = null;
}
function compileToFn(exp, name) {
var fn = $parse(exp);
return assertArgFn(fn, name), fn;
}
function decrementListenerCount(current, count, name) {
do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
}
function initWatchVal() {}
Scope.prototype = {
constructor:Scope,
$new:function(isolate) {
var child;
return isolate ? (child = new Scope(), child.$root = this.$root, child.$$asyncQueue = this.$$asyncQueue, 
child.$$postDigestQueue = this.$$postDigestQueue) :(this.$$childScopeClass || (this.$$childScopeClass = function() {
this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
this.$$listeners = {}, this.$$listenerCount = {}, this.$id = nextUid(), this.$$childScopeClass = null;
}, this.$$childScopeClass.prototype = this), child = new this.$$childScopeClass()), 
child["this"] = child, child.$parent = this, child.$$prevSibling = this.$$childTail, 
this.$$childHead ? (this.$$childTail.$$nextSibling = child, this.$$childTail = child) :this.$$childHead = this.$$childTail = child, 
child;
},
$watch:function(watchExp, listener, objectEquality) {
var scope = this, get = compileToFn(watchExp, "watch"), array = scope.$$watchers, watcher = {
fn:listener,
last:initWatchVal,
get:get,
exp:watchExp,
eq:!!objectEquality
};
if (lastDirtyWatch = null, !isFunction(listener)) {
var listenFn = compileToFn(listener || noop, "listener");
watcher.fn = function(newVal, oldVal, scope) {
listenFn(scope);
};
}
if ("string" == typeof watchExp && get.constant) {
var originalFn = watcher.fn;
watcher.fn = function(newVal, oldVal, scope) {
originalFn.call(this, newVal, oldVal, scope), arrayRemove(array, watcher);
};
}
return array || (array = scope.$$watchers = []), array.unshift(watcher), function() {
arrayRemove(array, watcher), lastDirtyWatch = null;
};
},
$watchCollection:function(obj, listener) {
function $watchCollectionWatch() {
newValue = objGetter(self);
var newLength, key, bothNaN;
if (isObject(newValue)) if (isArrayLike(newValue)) {
oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
oldValue.length = oldLength = newLength);
for (var i = 0; newLength > i; i++) bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i], 
bothNaN || oldValue[i] === newValue[i] || (changeDetected++, oldValue[i] = newValue[i]);
} else {
oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
newLength = 0;
for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, oldValue.hasOwnProperty(key) ? (bothNaN = oldValue[key] !== oldValue[key] && newValue[key] !== newValue[key], 
bothNaN || oldValue[key] === newValue[key] || (changeDetected++, oldValue[key] = newValue[key])) :(oldLength++, 
oldValue[key] = newValue[key], changeDetected++));
if (oldLength > newLength) {
changeDetected++;
for (key in oldValue) oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key) && (oldLength--, 
delete oldValue[key]);
}
} else oldValue !== newValue && (oldValue = newValue, changeDetected++);
return changeDetected;
}
function $watchCollectionAction() {
if (initRun ? (initRun = !1, listener(newValue, newValue, self)) :listener(newValue, veryOldValue, self), 
trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
veryOldValue = new Array(newValue.length);
for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
} else {
veryOldValue = {};
for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
} else veryOldValue = newValue;
}
var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, objGetter = $parse(obj), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
return this.$watch($watchCollectionWatch, $watchCollectionAction);
},
$digest:function() {
var watch, value, last, watchers, length, dirty, next, current, logIdx, logMsg, asyncTask, asyncQueue = this.$$asyncQueue, postDigestQueue = this.$$postDigestQueue, ttl = TTL, target = this, watchLog = [];
beginPhase("$digest"), $browser.$$checkUrlChange(), lastDirtyWatch = null;
do {
for (dirty = !1, current = target; asyncQueue.length; ) {
try {
asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression);
} catch (e) {
clearPhase(), $exceptionHandler(e);
}
lastDirtyWatch = null;
}
traverseScopesLoop:do {
if (watchers = current.$$watchers) for (length = watchers.length; length--; ) try {
if (watch = watchers[length]) if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) :"number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
if (watch === lastDirtyWatch) {
dirty = !1;
break traverseScopesLoop;
}
} else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) :value, 
watch.fn(value, last === initWatchVal ? value :last, current), 5 > ttl && (logIdx = 4 - ttl, 
watchLog[logIdx] || (watchLog[logIdx] = []), logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) :watch.exp, 
logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last), watchLog[logIdx].push(logMsg));
} catch (e) {
clearPhase(), $exceptionHandler(e);
}
if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
} while (current = next);
if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog));
} while (dirty || asyncQueue.length);
for (clearPhase(); postDigestQueue.length; ) try {
postDigestQueue.shift()();
} catch (e) {
$exceptionHandler(e);
}
},
$destroy:function() {
if (!this.$$destroyed) {
var parent = this.$parent;
this.$broadcast("$destroy"), this.$$destroyed = !0, this !== $rootScope && (forEach(this.$$listenerCount, bind(null, decrementListenerCount, this)), 
parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), 
this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null, 
this.$$listeners = {}, this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [], 
this.$destroy = this.$digest = this.$apply = noop, this.$on = this.$watch = function() {
return noop;
});
}
},
$eval:function(expr, locals) {
return $parse(expr)(this, locals);
},
$evalAsync:function(expr) {
$rootScope.$$phase || $rootScope.$$asyncQueue.length || $browser.defer(function() {
$rootScope.$$asyncQueue.length && $rootScope.$digest();
}), this.$$asyncQueue.push({
scope:this,
expression:expr
});
},
$$postDigest:function(fn) {
this.$$postDigestQueue.push(fn);
},
$apply:function(expr) {
try {
return beginPhase("$apply"), this.$eval(expr);
} catch (e) {
$exceptionHandler(e);
} finally {
clearPhase();
try {
$rootScope.$digest();
} catch (e) {
throw $exceptionHandler(e), e;
}
}
},
$on:function(name, listener) {
var namedListeners = this.$$listeners[name];
namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
var current = this;
do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
var self = this;
return function() {
var indexOfListener = indexOf(namedListeners, listener);
-1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name));
};
},
$emit:function(name) {
var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
name:name,
targetScope:scope,
stopPropagation:function() {
stopPropagation = !0;
},
preventDefault:function() {
event.defaultPrevented = !0;
},
defaultPrevented:!1
}, listenerArgs = concat([ event ], arguments, 1);
do {
for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
namedListeners[i].apply(null, listenerArgs);
} catch (e) {
$exceptionHandler(e);
} else namedListeners.splice(i, 1), i--, length--;
if (stopPropagation) return event;
scope = scope.$parent;
} while (scope);
return event;
},
$broadcast:function(name) {
for (var listeners, i, length, target = this, current = target, next = target, event = {
name:name,
targetScope:target,
preventDefault:function() {
event.defaultPrevented = !0;
},
defaultPrevented:!1
}, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
listeners[i].apply(null, listenerArgs);
} catch (e) {
$exceptionHandler(e);
} else listeners.splice(i, 1), i--, length--;
if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
}
return event;
}
};
var $rootScope = new Scope();
return $rootScope;
} ];
}
function $$SanitizeUriProvider() {
var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file):|data:image\/)/;
this.aHrefSanitizationWhitelist = function(regexp) {
return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) :aHrefSanitizationWhitelist;
}, this.imgSrcSanitizationWhitelist = function(regexp) {
return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) :imgSrcSanitizationWhitelist;
}, this.$get = function() {
return function(uri, isImage) {
var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist :aHrefSanitizationWhitelist;
return msie && !(msie >= 8) || (normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex)) ? uri :"unsafe:" + normalizedVal;
};
};
}
function escapeForRegexp(s) {
return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
}
function adjustMatcher(matcher) {
if ("self" === matcher) return matcher;
if (isString(matcher)) {
if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), 
new RegExp("^" + matcher + "$");
}
if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
}
function adjustMatchers(matchers) {
var adjustedMatchers = [];
return isDefined(matchers) && forEach(matchers, function(matcher) {
adjustedMatchers.push(adjustMatcher(matcher));
}), adjustedMatchers;
}
function $SceDelegateProvider() {
this.SCE_CONTEXTS = SCE_CONTEXTS;
var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
this.resourceUrlWhitelist = function(value) {
return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
}, this.resourceUrlBlacklist = function(value) {
return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
}, this.$get = [ "$injector", function($injector) {
function matchUrl(matcher, parsedUrl) {
return "self" === matcher ? urlIsSameOrigin(parsedUrl) :!!matcher.exec(parsedUrl.href);
}
function isResourceUrlAllowedByPolicy(url) {
var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
allowed = !0;
break;
}
if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
allowed = !1;
break;
}
return allowed;
}
function generateHolderType(Base) {
var holderType = function(trustedValue) {
this.$$unwrapTrustedValue = function() {
return trustedValue;
};
};
return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
return this.$$unwrapTrustedValue();
}, holderType.prototype.toString = function() {
return this.$$unwrapTrustedValue().toString();
}, holderType;
}
function trustAs(type, trustedValue) {
var Constructor = byType.hasOwnProperty(type) ? byType[type] :null;
if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
return new Constructor(trustedValue);
}
function valueOf(maybeTrusted) {
return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() :maybeTrusted;
}
function getTrusted(type, maybeTrusted) {
if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
var constructor = byType.hasOwnProperty(type) ? byType[type] :null;
if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
if (type === SCE_CONTEXTS.RESOURCE_URL) {
if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
}
if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
}
var htmlSanitizer = function() {
throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
};
$injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
var trustedValueHolderBase = generateHolderType(), byType = {};
return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
{
trustAs:trustAs,
getTrusted:getTrusted,
valueOf:valueOf
};
} ];
}
function $SceProvider() {
var enabled = !0;
this.enabled = function(value) {
return arguments.length && (enabled = !!value), enabled;
}, this.$get = [ "$parse", "$sniffer", "$sceDelegate", function($parse, $sniffer, $sceDelegate) {
if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
var sce = shallowCopy(SCE_CONTEXTS);
sce.isEnabled = function() {
return enabled;
}, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
return value;
}, sce.valueOf = identity), sce.parseAs = function(type, expr) {
var parsed = $parse(expr);
return parsed.literal && parsed.constant ? parsed :function(self, locals) {
return sce.getTrusted(type, parsed(self, locals));
};
};
var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
return forEach(SCE_CONTEXTS, function(enumValue, name) {
var lName = lowercase(name);
sce[camelCase("parse_as_" + lName)] = function(expr) {
return parse(enumValue, expr);
}, sce[camelCase("get_trusted_" + lName)] = function(value) {
return getTrusted(enumValue, value);
}, sce[camelCase("trust_as_" + lName)] = function(value) {
return trustAs(enumValue, value);
};
}), sce;
} ];
}
function $SnifferProvider() {
this.$get = [ "$window", "$document", function($window, $document) {
var vendorPrefix, match, eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, documentMode = document.documentMode, vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
if (bodyStyle) {
for (var prop in bodyStyle) if (match = vendorRegex.exec(prop)) {
vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
break;
}
vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), 
animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), 
!android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), 
animations = isString(document.body.style.webkitAnimation));
}
return {
history:!(!$window.history || !$window.history.pushState || 4 > android || boxee),
hashchange:"onhashchange" in $window && (!documentMode || documentMode > 7),
hasEvent:function(event) {
if ("input" == event && 9 == msie) return !1;
if (isUndefined(eventSupport[event])) {
var divElm = document.createElement("div");
eventSupport[event] = "on" + event in divElm;
}
return eventSupport[event];
},
csp:csp(),
vendorPrefix:vendorPrefix,
transitions:transitions,
animations:animations,
android:android,
msie:msie,
msieDocumentMode:documentMode
};
} ];
}
function $TimeoutProvider() {
this.$get = [ "$rootScope", "$browser", "$q", "$exceptionHandler", function($rootScope, $browser, $q, $exceptionHandler) {
function timeout(fn, delay, invokeApply) {
var timeoutId, deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply;
return timeoutId = $browser.defer(function() {
try {
deferred.resolve(fn());
} catch (e) {
deferred.reject(e), $exceptionHandler(e);
} finally {
delete deferreds[promise.$$timeoutId];
}
skipApply || $rootScope.$apply();
}, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
}
var deferreds = {};
return timeout.cancel = function(promise) {
return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), 
delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) :!1;
}, timeout;
} ];
}
function urlResolve(url) {
var href = url;
return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
urlParsingNode.setAttribute("href", href), {
href:urlParsingNode.href,
protocol:urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") :"",
host:urlParsingNode.host,
search:urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") :"",
hash:urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") :"",
hostname:urlParsingNode.hostname,
port:urlParsingNode.port,
pathname:"/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname :"/" + urlParsingNode.pathname
};
}
function urlIsSameOrigin(requestUrl) {
var parsed = isString(requestUrl) ? urlResolve(requestUrl) :requestUrl;
return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
}
function $WindowProvider() {
this.$get = valueFn(window);
}
function $FilterProvider($provide) {
function register(name, factory) {
if (isObject(name)) {
var filters = {};
return forEach(name, function(filter, key) {
filters[key] = register(key, filter);
}), filters;
}
return $provide.factory(name + suffix, factory);
}
var suffix = "Filter";
this.register = register, this.$get = [ "$injector", function($injector) {
return function(name) {
return $injector.get(name + suffix);
};
} ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
}
function filterFilter() {
return function(array, expression, comparator) {
if (!isArray(array)) return array;
var comparatorType = typeof comparator, predicates = [];
predicates.check = function(value) {
for (var j = 0; j < predicates.length; j++) if (!predicates[j](value)) return !1;
return !0;
}, "function" !== comparatorType && (comparator = "boolean" === comparatorType && comparator ? function(obj, text) {
return angular.equals(obj, text);
} :function(obj, text) {
if (obj && text && "object" == typeof obj && "object" == typeof text) {
for (var objKey in obj) if ("$" !== objKey.charAt(0) && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) return !0;
return !1;
}
return text = ("" + text).toLowerCase(), ("" + obj).toLowerCase().indexOf(text) > -1;
});
var search = function(obj, text) {
if ("string" == typeof text && "!" === text.charAt(0)) return !search(obj, text.substr(1));
switch (typeof obj) {
case "boolean":
case "number":
case "string":
return comparator(obj, text);

case "object":
switch (typeof text) {
case "object":
return comparator(obj, text);

default:
for (var objKey in obj) if ("$" !== objKey.charAt(0) && search(obj[objKey], text)) return !0;
}
return !1;

case "array":
for (var i = 0; i < obj.length; i++) if (search(obj[i], text)) return !0;
return !1;

default:
return !1;
}
};
switch (typeof expression) {
case "boolean":
case "number":
case "string":
expression = {
$:expression
};

case "object":
for (var key in expression) !function(path) {
"undefined" != typeof expression[path] && predicates.push(function(value) {
return search("$" == path ? value :value && value[path], expression[path]);
});
}(key);
break;

case "function":
predicates.push(expression);
break;

default:
return array;
}
for (var filtered = [], j = 0; j < array.length; j++) {
var value = array[j];
predicates.check(value) && filtered.push(value);
}
return filtered;
};
}
function currencyFilter($locale) {
var formats = $locale.NUMBER_FORMATS;
return function(amount, currencySymbol) {
return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
};
}
function numberFilter($locale) {
var formats = $locale.NUMBER_FORMATS;
return function(number, fractionSize) {
return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
};
}
function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
if (null == number || !isFinite(number) || isObject(number)) return "";
var isNegative = 0 > number;
number = Math.abs(number);
var numStr = number + "", formatedText = "", parts = [], hasExponent = !1;
if (-1 !== numStr.indexOf("e")) {
var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
match && "-" == match[2] && match[3] > fractionSize + 1 ? (numStr = "0", number = 0) :(formatedText = numStr, 
hasExponent = !0);
}
if (hasExponent) fractionSize > 0 && number > -1 && 1 > number && (formatedText = number.toFixed(fractionSize)); else {
var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), 
number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize), 
0 === number && (isNegative = !1);
var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
fraction = fraction[1] || "";
var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
if (whole.length >= lgroup + group) for (pos = whole.length - lgroup, i = 0; pos > i; i++) (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), 
formatedText += whole.charAt(i);
for (i = pos; i < whole.length; i++) (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), 
formatedText += whole.charAt(i);
for (;fraction.length < fractionSize; ) fraction += "0";
fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize));
}
return parts.push(isNegative ? pattern.negPre :pattern.posPre), parts.push(formatedText), 
parts.push(isNegative ? pattern.negSuf :pattern.posSuf), parts.join("");
}
function padNumber(num, digits, trim) {
var neg = "";
for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits; ) num = "0" + num;
return trim && (num = num.substr(num.length - digits)), neg + num;
}
function dateGetter(name, size, offset, trim) {
return offset = offset || 0, function(date) {
var value = date["get" + name]();
return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), 
padNumber(value, size, trim);
};
}
function dateStrGetter(name, shortForm) {
return function(date, formats) {
var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name :name);
return formats[get][value];
};
}
function timeZoneGetter(date) {
var zone = -1 * date.getTimezoneOffset(), paddedZone = zone >= 0 ? "+" :"";
return paddedZone += padNumber(Math[zone > 0 ? "floor" :"ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
}
function ampmGetter(date, formats) {
return date.getHours() < 12 ? formats.AMPMS[0] :formats.AMPMS[1];
}
function dateFilter($locale) {
function jsonStringToDate(string) {
var match;
if (match = string.match(R_ISO8601_STR)) {
var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear :date.setFullYear, timeSetter = match[8] ? date.setUTCHours :date.setHours;
match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])), 
dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
var h = int(match[4] || 0) - tzHour, m = int(match[5] || 0) - tzMin, s = int(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
return timeSetter.call(date, h, m, s, ms), date;
}
return string;
}
var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
return function(date, format) {
var fn, match, text = "", parts = [];
if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
isString(date) && (date = NUMBER_STRING.test(date) ? int(date) :jsonStringToDate(date)), 
isNumber(date) && (date = new Date(date)), !isDate(date)) return date;
for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
format = parts.pop()) :(parts.push(format), format = null);
return forEach(parts, function(value) {
fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS) :value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
}), text;
};
}
function jsonFilter() {
return function(object) {
return toJson(object, !0);
};
}
function limitToFilter() {
return function(input, limit) {
if (!isArray(input) && !isString(input)) return input;
if (limit = 1/0 === Math.abs(Number(limit)) ? Number(limit) :int(limit), isString(input)) return limit ? limit >= 0 ? input.slice(0, limit) :input.slice(limit, input.length) :"";
var i, n, out = [];
for (limit > input.length ? limit = input.length :limit < -input.length && (limit = -input.length), 
limit > 0 ? (i = 0, n = limit) :(i = input.length + limit, n = input.length); n > i; i++) out.push(input[i]);
return out;
};
}
function orderByFilter($parse) {
return function(array, sortPredicate, reverseOrder) {
function comparator(o1, o2) {
for (var i = 0; i < sortPredicate.length; i++) {
var comp = sortPredicate[i](o1, o2);
if (0 !== comp) return comp;
}
return 0;
}
function reverseComparator(comp, descending) {
return toBoolean(descending) ? function(a, b) {
return comp(b, a);
} :comp;
}
function compare(v1, v2) {
var t1 = typeof v1, t2 = typeof v2;
return t1 == t2 ? (isDate(v1) && isDate(v2) && (v1 = v1.valueOf(), v2 = v2.valueOf()), 
"string" == t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), v1 === v2 ? 0 :v2 > v1 ? -1 :1) :t2 > t1 ? -1 :1;
}
return isArrayLike(array) ? (sortPredicate = isArray(sortPredicate) ? sortPredicate :[ sortPredicate ], 
0 === sortPredicate.length && (sortPredicate = [ "+" ]), sortPredicate = map(sortPredicate, function(predicate) {
var descending = !1, get = predicate || identity;
if (isString(predicate)) {
if (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), 
predicate = predicate.substring(1)), "" === predicate) return reverseComparator(function(a, b) {
return compare(a, b);
}, descending);
if (get = $parse(predicate), get.constant) {
var key = get();
return reverseComparator(function(a, b) {
return compare(a[key], b[key]);
}, descending);
}
}
return reverseComparator(function(a, b) {
return compare(get(a), get(b));
}, descending);
}), slice.call(array).sort(reverseComparator(comparator, reverseOrder))) :array;
};
}
function ngDirective(directive) {
return isFunction(directive) && (directive = {
link:directive
}), directive.restrict = directive.restrict || "AC", valueFn(directive);
}
function FormController(element, attrs, $scope, $animate) {
function toggleValidCss(isValid, validationErrorKey) {
validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") :"", 
$animate.setClass(element, (isValid ? VALID_CLASS :INVALID_CLASS) + validationErrorKey, (isValid ? INVALID_CLASS :VALID_CLASS) + validationErrorKey);
}
var form = this, parentForm = element.parent().controller("form") || nullFormCtrl, invalidCount = 0, errors = form.$error = {}, controls = [];
form.$name = attrs.name || attrs.ngForm, form.$dirty = !1, form.$pristine = !0, 
form.$valid = !0, form.$invalid = !1, parentForm.$addControl(form), element.addClass(PRISTINE_CLASS), 
toggleValidCss(!0), form.$addControl = function(control) {
assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control);
}, form.$removeControl = function(control) {
control.$name && form[control.$name] === control && delete form[control.$name], 
forEach(errors, function(queue, validationToken) {
form.$setValidity(validationToken, !0, control);
}), arrayRemove(controls, control);
}, form.$setValidity = function(validationToken, isValid, control) {
var queue = errors[validationToken];
if (isValid) queue && (arrayRemove(queue, control), queue.length || (invalidCount--, 
invalidCount || (toggleValidCss(isValid), form.$valid = !0, form.$invalid = !1), 
errors[validationToken] = !1, toggleValidCss(!0, validationToken), parentForm.$setValidity(validationToken, !0, form))); else {
if (invalidCount || toggleValidCss(isValid), queue) {
if (includes(queue, control)) return;
} else errors[validationToken] = queue = [], invalidCount++, toggleValidCss(!1, validationToken), 
parentForm.$setValidity(validationToken, !1, form);
queue.push(control), form.$valid = !1, form.$invalid = !0;
}
}, form.$setDirty = function() {
$animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), 
form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty();
}, form.$setPristine = function() {
$animate.removeClass(element, DIRTY_CLASS), $animate.addClass(element, PRISTINE_CLASS), 
form.$dirty = !1, form.$pristine = !0, forEach(controls, function(control) {
control.$setPristine();
});
};
}
function validate(ctrl, validatorName, validity, value) {
return ctrl.$setValidity(validatorName, validity), validity ? value :undefined;
}
function testFlags(validity, flags) {
var i, flag;
if (flags) for (i = 0; i < flags.length; ++i) if (flag = flags[i], validity[flag]) return !0;
return !1;
}
function addNativeHtml5Validators(ctrl, validatorName, badFlags, ignoreFlags, validity) {
if (isObject(validity)) {
ctrl.$$hasNativeValidators = !0;
var validator = function(value) {
return ctrl.$error[validatorName] || testFlags(validity, ignoreFlags) || !testFlags(validity, badFlags) ? value :(ctrl.$setValidity(validatorName, !1), 
void 0);
};
ctrl.$parsers.push(validator);
}
}
function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var validity = element.prop(VALIDITY_STATE_PROPERTY), placeholder = element[0].placeholder, noevent = {}, type = lowercase(element[0].type);
if (ctrl.$$validityState = validity, !$sniffer.android) {
var composing = !1;
element.on("compositionstart", function() {
composing = !0;
}), element.on("compositionend", function() {
composing = !1, listener();
});
}
var listener = function(ev) {
if (!composing) {
var value = element.val();
if (msie && "input" === (ev || noevent).type && element[0].placeholder !== placeholder) return placeholder = element[0].placeholder, 
void 0;
"password" !== type && toBoolean(attr.ngTrim || "T") && (value = trim(value));
var revalidate = validity && ctrl.$$hasNativeValidators;
(ctrl.$viewValue !== value || "" === value && revalidate) && (scope.$root.$$phase ? ctrl.$setViewValue(value) :scope.$apply(function() {
ctrl.$setViewValue(value);
}));
}
};
if ($sniffer.hasEvent("input")) element.on("input", listener); else {
var timeout, deferListener = function() {
timeout || (timeout = $browser.defer(function() {
listener(), timeout = null;
}));
};
element.on("keydown", function(event) {
var key = event.keyCode;
91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener();
}), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
}
element.on("change", listener), ctrl.$render = function() {
element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" :ctrl.$viewValue);
};
var patternValidator, match, pattern = attr.ngPattern;
if (pattern) {
var validateRegex = function(regexp, value) {
return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value);
};
match = pattern.match(/^\/(.*)\/([gim]*)$/), match ? (pattern = new RegExp(match[1], match[2]), 
patternValidator = function(value) {
return validateRegex(pattern, value);
}) :patternValidator = function(value) {
var patternObj = scope.$eval(pattern);
if (!patternObj || !patternObj.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
return validateRegex(patternObj, value);
}, ctrl.$formatters.push(patternValidator), ctrl.$parsers.push(patternValidator);
}
if (attr.ngMinlength) {
var minlength = int(attr.ngMinlength), minLengthValidator = function(value) {
return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value);
};
ctrl.$parsers.push(minLengthValidator), ctrl.$formatters.push(minLengthValidator);
}
if (attr.ngMaxlength) {
var maxlength = int(attr.ngMaxlength), maxLengthValidator = function(value) {
return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value);
};
ctrl.$parsers.push(maxLengthValidator), ctrl.$formatters.push(maxLengthValidator);
}
}
function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
if (textInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$parsers.push(function(value) {
var empty = ctrl.$isEmpty(value);
return empty || NUMBER_REGEXP.test(value) ? (ctrl.$setValidity("number", !0), "" === value ? null :empty ? value :parseFloat(value)) :(ctrl.$setValidity("number", !1), 
undefined);
}), addNativeHtml5Validators(ctrl, "number", numberBadFlags, null, ctrl.$$validityState), 
ctrl.$formatters.push(function(value) {
return ctrl.$isEmpty(value) ? "" :"" + value;
}), attr.min) {
var minValidator = function(value) {
var min = parseFloat(attr.min);
return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value);
};
ctrl.$parsers.push(minValidator), ctrl.$formatters.push(minValidator);
}
if (attr.max) {
var maxValidator = function(value) {
var max = parseFloat(attr.max);
return validate(ctrl, "max", ctrl.$isEmpty(value) || max >= value, value);
};
ctrl.$parsers.push(maxValidator), ctrl.$formatters.push(maxValidator);
}
ctrl.$formatters.push(function(value) {
return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value);
});
}
function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
textInputType(scope, element, attr, ctrl, $sniffer, $browser);
var urlValidator = function(value) {
return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value);
};
ctrl.$formatters.push(urlValidator), ctrl.$parsers.push(urlValidator);
}
function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
textInputType(scope, element, attr, ctrl, $sniffer, $browser);
var emailValidator = function(value) {
return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value);
};
ctrl.$formatters.push(emailValidator), ctrl.$parsers.push(emailValidator);
}
function radioInputType(scope, element, attr, ctrl) {
isUndefined(attr.name) && element.attr("name", nextUid()), element.on("click", function() {
element[0].checked && scope.$apply(function() {
ctrl.$setViewValue(attr.value);
});
}), ctrl.$render = function() {
var value = attr.value;
element[0].checked = value == ctrl.$viewValue;
}, attr.$observe("value", ctrl.$render);
}
function checkboxInputType(scope, element, attr, ctrl) {
var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
isString(trueValue) || (trueValue = !0), isString(falseValue) || (falseValue = !1), 
element.on("click", function() {
scope.$apply(function() {
ctrl.$setViewValue(element[0].checked);
});
}), ctrl.$render = function() {
element[0].checked = ctrl.$viewValue;
}, ctrl.$isEmpty = function(value) {
return value !== trueValue;
}, ctrl.$formatters.push(function(value) {
return value === trueValue;
}), ctrl.$parsers.push(function(value) {
return value ? trueValue :falseValue;
});
}
function classDirective(name, selector) {
return name = "ngClass" + name, [ "$animate", function($animate) {
function arrayDifference(tokens1, tokens2) {
var values = [];
outer:for (var i = 0; i < tokens1.length; i++) {
for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
values.push(token);
}
return values;
}
function arrayClasses(classVal) {
if (isArray(classVal)) return classVal;
if (isString(classVal)) return classVal.split(" ");
if (isObject(classVal)) {
var classes = [];
return forEach(classVal, function(v, k) {
v && (classes = classes.concat(k.split(" ")));
}), classes;
}
return classVal;
}
return {
restrict:"AC",
link:function(scope, element, attr) {
function addClasses(classes) {
var newClasses = digestClassCounts(classes, 1);
attr.$addClass(newClasses);
}
function removeClasses(classes) {
var newClasses = digestClassCounts(classes, -1);
attr.$removeClass(newClasses);
}
function digestClassCounts(classes, count) {
var classCounts = element.data("$classCounts") || {}, classesToUpdate = [];
return forEach(classes, function(className) {
(count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
classCounts[className] === +(count > 0) && classesToUpdate.push(className));
}), element.data("$classCounts", classCounts), classesToUpdate.join(" ");
}
function updateClasses(oldClasses, newClasses) {
var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
toRemove = digestClassCounts(toRemove, -1), toAdd = digestClassCounts(toAdd, 1), 
0 === toAdd.length ? $animate.removeClass(element, toRemove) :0 === toRemove.length ? $animate.addClass(element, toAdd) :$animate.setClass(element, toAdd, toRemove);
}
function ngClassWatchAction(newVal) {
if (selector === !0 || scope.$index % 2 === selector) {
var newClasses = arrayClasses(newVal || []);
if (oldVal) {
if (!equals(newVal, oldVal)) {
var oldClasses = arrayClasses(oldVal);
updateClasses(oldClasses, newClasses);
}
} else addClasses(newClasses);
}
oldVal = shallowCopy(newVal);
}
var oldVal;
scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function() {
ngClassWatchAction(scope.$eval(attr[name]));
}), "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
var mod = 1 & $index;
if (mod !== (1 & old$index)) {
var classes = arrayClasses(scope.$eval(attr[name]));
mod === selector ? addClasses(classes) :removeClasses(classes);
}
});
}
};
} ];
}
var VALIDITY_STATE_PROPERTY = "validity", lowercase = function(string) {
return isString(string) ? string.toLowerCase() :string;
}, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function(string) {
return isString(string) ? string.toUpperCase() :string;
}, manualLowercase = function(s) {
return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
return String.fromCharCode(32 | ch.charCodeAt(0));
}) :s;
}, manualUppercase = function(s) {
return isString(s) ? s.replace(/[a-z]/g, function(ch) {
return String.fromCharCode(-33 & ch.charCodeAt(0));
}) :s;
};
"i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
var msie, jqLite, jQuery, angularModule, nodeName_, slice = [].slice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = [ "0", "0", "0" ];
msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), isNaN(msie) && (msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])), 
noop.$inject = [], identity.$inject = [];
var isArray = function() {
return isFunction(Array.isArray) ? Array.isArray :function(value) {
return "[object Array]" === toString.call(value);
};
}(), trim = function() {
return String.prototype.trim ? function(value) {
return isString(value) ? value.trim() :value;
} :function(value) {
return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") :value;
};
}();
nodeName_ = 9 > msie ? function(element) {
return element = element.nodeName ? element :element[0], element.scopeName && "HTML" != element.scopeName ? uppercase(element.scopeName + ":" + element.nodeName) :element.nodeName;
} :function(element) {
return element.nodeName ? element.nodeName :element[0].nodeName;
};
var csp = function() {
if (isDefined(csp.isActive_)) return csp.isActive_;
var active = !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
if (!active) try {
new Function("");
} catch (e) {
active = !0;
}
return csp.isActive_ = active;
}, SNAKE_CASE_REGEXP = /[A-Z]/g, version = {
full:"1.2.28",
major:1,
minor:2,
dot:28,
codeName:"finnish-disembarkation"
};
JQLite.expando = "ng339";
var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
element.addEventListener(type, fn, !1);
} :function(element, type, fn) {
element.attachEvent("on" + type, fn);
}, removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
element.removeEventListener(type, fn, !1);
} :function(element, type, fn) {
element.detachEvent("on" + type, fn);
}, SPECIAL_CHARS_REGEXP = (JQLite._data = function(node) {
return this.cache[node[this.expando]] || {};
}, /([\:\-\_]+(.))/g), MOZ_HACK_REGEXP = /^moz([A-Z])/, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, wrapMap = {
option:[ 1, '<select multiple="multiple">', "</select>" ],
thead:[ 1, "<table>", "</table>" ],
col:[ 2, "<table><colgroup>", "</colgroup></table>" ],
tr:[ 2, "<table><tbody>", "</tbody></table>" ],
td:[ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
_default:[ 0, "", "" ]
};
wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
wrapMap.th = wrapMap.td;
var JQLitePrototype = JQLite.prototype = {
ready:function(fn) {
function trigger() {
fired || (fired = !0, fn());
}
var fired = !1;
"complete" === document.readyState ? setTimeout(trigger) :(this.on("DOMContentLoaded", trigger), 
JQLite(window).on("load", trigger));
},
toString:function() {
var value = [];
return forEach(this, function(e) {
value.push("" + e);
}), "[" + value.join(", ") + "]";
},
eq:function(index) {
return index >= 0 ? jqLite(this[index]) :jqLite(this[this.length + index]);
},
length:0,
push:push,
sort:[].sort,
splice:[].splice
}, BOOLEAN_ATTR = {};
forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
BOOLEAN_ATTR[lowercase(value)] = value;
});
var BOOLEAN_ELEMENTS = {};
forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
BOOLEAN_ELEMENTS[uppercase(value)] = !0;
}), forEach({
data:jqLiteData,
removeData:jqLiteRemoveData
}, function(fn, name) {
JQLite[name] = fn;
}), forEach({
data:jqLiteData,
inheritedData:jqLiteInheritedData,
scope:function(element) {
return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
},
isolateScope:function(element) {
return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
},
controller:jqLiteController,
injector:function(element) {
return jqLiteInheritedData(element, "$injector");
},
removeAttr:function(element, name) {
element.removeAttribute(name);
},
hasClass:jqLiteHasClass,
css:function(element, name, value) {
if (name = camelCase(name), !isDefined(value)) {
var val;
return 8 >= msie && (val = element.currentStyle && element.currentStyle[name], "" === val && (val = "auto")), 
val = val || element.style[name], 8 >= msie && (val = "" === val ? undefined :val), 
val;
}
element.style[name] = value;
},
attr:function(element, name, value) {
var lowercasedName = lowercase(name);
if (BOOLEAN_ATTR[lowercasedName]) {
if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName :undefined;
value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) :(element[name] = !1, 
element.removeAttribute(lowercasedName));
} else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
var ret = element.getAttribute(name, 2);
return null === ret ? undefined :ret;
}
},
prop:function(element, name, value) {
return isDefined(value) ? (element[name] = value, void 0) :element[name];
},
text:function() {
function getText(element, value) {
var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
return isUndefined(value) ? textProp ? element[textProp] :"" :(element[textProp] = value, 
void 0);
}
var NODE_TYPE_TEXT_PROPERTY = [];
return 9 > msie ? (NODE_TYPE_TEXT_PROPERTY[1] = "innerText", NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue") :NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent", 
getText.$dv = "", getText;
}(),
val:function(element, value) {
if (isUndefined(value)) {
if ("SELECT" === nodeName_(element) && element.multiple) {
var result = [];
return forEach(element.options, function(option) {
option.selected && result.push(option.value || option.text);
}), 0 === result.length ? null :result;
}
return element.value;
}
element.value = value;
},
html:function(element, value) {
if (isUndefined(value)) return element.innerHTML;
for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
element.innerHTML = value;
},
empty:jqLiteEmpty
}, function(fn, name) {
JQLite.prototype[name] = function(arg1, arg2) {
var i, key, nodeCount = this.length;
if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 :arg2) === undefined) {
if (isObject(arg1)) {
for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
return this;
}
for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) :nodeCount, j = 0; jj > j; j++) {
var nodeValue = fn(this[j], arg1, arg2);
value = value ? value + nodeValue :nodeValue;
}
return value;
}
for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
return this;
};
}), forEach({
removeData:jqLiteRemoveData,
dealoc:jqLiteDealoc,
on:function onFn(element, type, fn, unsupported) {
if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
events || jqLiteExpandoStore(element, "events", events = {}), handle || jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events)), 
forEach(type.split(" "), function(type) {
var eventFns = events[type];
if (!eventFns) {
if ("mouseenter" == type || "mouseleave" == type) {
var contains = document.body.contains || document.body.compareDocumentPosition ? function(a, b) {
var adown = 9 === a.nodeType ? a.documentElement :a, bup = b && b.parentNode;
return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) :a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
} :function(a, b) {
if (b) for (;b = b.parentNode; ) if (b === a) return !0;
return !1;
};
events[type] = [];
var eventmap = {
mouseleave:"mouseout",
mouseenter:"mouseover"
};
onFn(element, eventmap[type], function(event) {
var target = this, related = event.relatedTarget;
(!related || related !== target && !contains(target, related)) && handle(event, type);
});
} else addEventListenerFn(element, type, handle), events[type] = [];
eventFns = events[type];
}
eventFns.push(fn);
});
},
off:jqLiteOff,
one:function(element, type, fn) {
element = jqLite(element), element.on(type, function onFn() {
element.off(type, fn), element.off(type, onFn);
}), element.on(type, fn);
},
replaceWith:function(element, replaceNode) {
var index, parent = element.parentNode;
jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
index ? parent.insertBefore(node, index.nextSibling) :parent.replaceChild(node, element), 
index = node;
});
},
children:function(element) {
var children = [];
return forEach(element.childNodes, function(element) {
1 === element.nodeType && children.push(element);
}), children;
},
contents:function(element) {
return element.contentDocument || element.childNodes || [];
},
append:function(element, node) {
forEach(new JQLite(node), function(child) {
(1 === element.nodeType || 11 === element.nodeType) && element.appendChild(child);
});
},
prepend:function(element, node) {
if (1 === element.nodeType) {
var index = element.firstChild;
forEach(new JQLite(node), function(child) {
element.insertBefore(child, index);
});
}
},
wrap:function(element, wrapNode) {
wrapNode = jqLite(wrapNode)[0];
var parent = element.parentNode;
parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element);
},
remove:function(element) {
jqLiteDealoc(element);
var parent = element.parentNode;
parent && parent.removeChild(element);
},
after:function(element, newElement) {
var index = element, parent = element.parentNode;
forEach(new JQLite(newElement), function(node) {
parent.insertBefore(node, index.nextSibling), index = node;
});
},
addClass:jqLiteAddClass,
removeClass:jqLiteRemoveClass,
toggleClass:function(element, selector, condition) {
selector && forEach(selector.split(" "), function(className) {
var classCondition = condition;
isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
(classCondition ? jqLiteAddClass :jqLiteRemoveClass)(element, className);
});
},
parent:function(element) {
var parent = element.parentNode;
return parent && 11 !== parent.nodeType ? parent :null;
},
next:function(element) {
if (element.nextElementSibling) return element.nextElementSibling;
for (var elm = element.nextSibling; null != elm && 1 !== elm.nodeType; ) elm = elm.nextSibling;
return elm;
},
find:function(element, selector) {
return element.getElementsByTagName ? element.getElementsByTagName(selector) :[];
},
clone:jqLiteClone,
triggerHandler:function(element, event, extraParameters) {
var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName];
eventFns && (dummyEvent = {
preventDefault:function() {
this.defaultPrevented = !0;
},
isDefaultPrevented:function() {
return this.defaultPrevented === !0;
},
stopPropagation:noop,
type:eventName,
target:element
}, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) :[ dummyEvent ], 
forEach(eventFnsCopy, function(fn) {
fn.apply(element, handlerArgs);
}));
}
}, function(fn, name) {
JQLite.prototype[name] = function(arg1, arg2, arg3) {
for (var value, i = 0; i < this.length; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
isDefined(value) && (value = jqLite(value))) :jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
return isDefined(value) ? value :this;
}, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
}), HashMap.prototype = {
put:function(key, value) {
this[hashKey(key, this.nextUid)] = value;
},
get:function(key) {
return this[hashKey(key, this.nextUid)];
},
remove:function(key) {
var value = this[key = hashKey(key, this.nextUid)];
return delete this[key], value;
}
};
var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector"), $animateMinErr = minErr("$animate"), $AnimateProvider = [ "$provide", function($provide) {
this.$$selectors = {}, this.register = function(name, factory) {
var key = name + "-animation";
if (name && "." != name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
this.$$selectors[name.substr(1)] = key, $provide.factory(key, factory);
}, this.classNameFilter = function(expression) {
return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression :null), 
this.$$classNameFilter;
}, this.$get = [ "$timeout", "$$asyncCallback", function($timeout, $$asyncCallback) {
function async(fn) {
fn && $$asyncCallback(fn);
}
return {
enter:function(element, parent, after, done) {
after ? after.after(element) :(parent && parent[0] || (parent = after.parent()), 
parent.append(element)), async(done);
},
leave:function(element, done) {
element.remove(), async(done);
},
move:function(element, parent, after, done) {
this.enter(element, parent, after, done);
},
addClass:function(element, className, done) {
className = isString(className) ? className :isArray(className) ? className.join(" ") :"", 
forEach(element, function(element) {
jqLiteAddClass(element, className);
}), async(done);
},
removeClass:function(element, className, done) {
className = isString(className) ? className :isArray(className) ? className.join(" ") :"", 
forEach(element, function(element) {
jqLiteRemoveClass(element, className);
}), async(done);
},
setClass:function(element, add, remove, done) {
forEach(element, function(element) {
jqLiteAddClass(element, add), jqLiteRemoveClass(element, remove);
}), async(done);
},
enabled:noop
};
} ];
} ], $compileMinErr = minErr("$compile");
$CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i, $interpolateMinErr = minErr("$interpolate"), PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
http:80,
https:443,
ftp:21
}, $locationMinErr = minErr("$location");
LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
$$html5:!1,
$$replace:!1,
absUrl:locationGetter("$$absUrl"),
url:function(url) {
if (isUndefined(url)) return this.$$url;
var match = PATH_MATCH.exec(url);
return match[1] && this.path(decodeURIComponent(match[1])), (match[2] || match[1]) && this.search(match[3] || ""), 
this.hash(match[5] || ""), this;
},
protocol:locationGetter("$$protocol"),
host:locationGetter("$$host"),
port:locationGetter("$$port"),
path:locationGetterSetter("$$path", function(path) {
return path = null !== path ? path.toString() :"", "/" == path.charAt(0) ? path :"/" + path;
}),
search:function(search, paramValue) {
switch (arguments.length) {
case 0:
return this.$$search;

case 1:
if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
forEach(search, function(value, key) {
null == value && delete search[key];
}), this.$$search = search;
}
break;

default:
isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] :this.$$search[search] = paramValue;
}
return this.$$compose(), this;
},
hash:locationGetterSetter("$$hash", function(hash) {
return null !== hash ? hash.toString() :"";
}),
replace:function() {
return this.$$replace = !0, this;
}
};
var promiseWarning, $parseMinErr = minErr("$parse"), promiseWarningCache = {}, CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, OPERATORS = {
"null":function() {
return null;
},
"true":function() {
return !0;
},
"false":function() {
return !1;
},
undefined:noop,
"+":function(self, locals, a, b) {
return a = a(self, locals), b = b(self, locals), isDefined(a) ? isDefined(b) ? a + b :a :isDefined(b) ? b :undefined;
},
"-":function(self, locals, a, b) {
return a = a(self, locals), b = b(self, locals), (isDefined(a) ? a :0) - (isDefined(b) ? b :0);
},
"*":function(self, locals, a, b) {
return a(self, locals) * b(self, locals);
},
"/":function(self, locals, a, b) {
return a(self, locals) / b(self, locals);
},
"%":function(self, locals, a, b) {
return a(self, locals) % b(self, locals);
},
"^":function(self, locals, a, b) {
return a(self, locals) ^ b(self, locals);
},
"=":noop,
"===":function(self, locals, a, b) {
return a(self, locals) === b(self, locals);
},
"!==":function(self, locals, a, b) {
return a(self, locals) !== b(self, locals);
},
"==":function(self, locals, a, b) {
return a(self, locals) == b(self, locals);
},
"!=":function(self, locals, a, b) {
return a(self, locals) != b(self, locals);
},
"<":function(self, locals, a, b) {
return a(self, locals) < b(self, locals);
},
">":function(self, locals, a, b) {
return a(self, locals) > b(self, locals);
},
"<=":function(self, locals, a, b) {
return a(self, locals) <= b(self, locals);
},
">=":function(self, locals, a, b) {
return a(self, locals) >= b(self, locals);
},
"&&":function(self, locals, a, b) {
return a(self, locals) && b(self, locals);
},
"||":function(self, locals, a, b) {
return a(self, locals) || b(self, locals);
},
"&":function(self, locals, a, b) {
return a(self, locals) & b(self, locals);
},
"|":function(self, locals, a, b) {
return b(self, locals)(self, locals, a(self, locals));
},
"!":function(self, locals, a) {
return !a(self, locals);
}
}, ESCAPE = {
n:"\n",
f:"\f",
r:"\r",
t:"	",
v:"",
"'":"'",
'"':'"'
}, Lexer = function(options) {
this.options = options;
};
Lexer.prototype = {
constructor:Lexer,
lex:function(text) {
for (this.text = text, this.index = 0, this.ch = undefined, this.lastCh = ":", this.tokens = []; this.index < this.text.length; ) {
if (this.ch = this.text.charAt(this.index), this.is("\"'")) this.readString(this.ch); else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(this.ch)) this.readIdent(); else if (this.is("(){}[].,;:?")) this.tokens.push({
index:this.index,
text:this.ch
}), this.index++; else {
if (this.isWhitespace(this.ch)) {
this.index++;
continue;
}
var ch2 = this.ch + this.peek(), ch3 = ch2 + this.peek(2), fn = OPERATORS[this.ch], fn2 = OPERATORS[ch2], fn3 = OPERATORS[ch3];
fn3 ? (this.tokens.push({
index:this.index,
text:ch3,
fn:fn3
}), this.index += 3) :fn2 ? (this.tokens.push({
index:this.index,
text:ch2,
fn:fn2
}), this.index += 2) :fn ? (this.tokens.push({
index:this.index,
text:this.ch,
fn:fn
}), this.index += 1) :this.throwError("Unexpected next character ", this.index, this.index + 1);
}
this.lastCh = this.ch;
}
return this.tokens;
},
is:function(chars) {
return -1 !== chars.indexOf(this.ch);
},
was:function(chars) {
return -1 !== chars.indexOf(this.lastCh);
},
peek:function(i) {
var num = i || 1;
return this.index + num < this.text.length ? this.text.charAt(this.index + num) :!1;
},
isNumber:function(ch) {
return ch >= "0" && "9" >= ch;
},
isWhitespace:function(ch) {
return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "\xa0" === ch;
},
isIdent:function(ch) {
return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
},
isExpOperator:function(ch) {
return "-" === ch || "+" === ch || this.isNumber(ch);
},
throwError:function(error, start, end) {
end = end || this.index;
var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" :" " + end;
throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
},
readNumber:function() {
for (var number = "", start = this.index; this.index < this.text.length; ) {
var ch = lowercase(this.text.charAt(this.index));
if ("." == ch || this.isNumber(ch)) number += ch; else {
var peekCh = this.peek();
if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
this.throwError("Invalid exponent");
}
}
this.index++;
}
number = 1 * number, this.tokens.push({
index:start,
text:number,
literal:!0,
constant:!0,
fn:function() {
return number;
}
});
},
readIdent:function() {
for (var lastDot, peekIndex, methodName, ch, parser = this, ident = "", start = this.index; this.index < this.text.length && (ch = this.text.charAt(this.index), 
"." === ch || this.isIdent(ch) || this.isNumber(ch)); ) "." === ch && (lastDot = this.index), 
ident += ch, this.index++;
if (lastDot) for (peekIndex = this.index; peekIndex < this.text.length; ) {
if (ch = this.text.charAt(peekIndex), "(" === ch) {
methodName = ident.substr(lastDot - start + 1), ident = ident.substr(0, lastDot - start), 
this.index = peekIndex;
break;
}
if (!this.isWhitespace(ch)) break;
peekIndex++;
}
var token = {
index:start,
text:ident
};
if (OPERATORS.hasOwnProperty(ident)) token.fn = OPERATORS[ident], token.literal = !0, 
token.constant = !0; else {
var getter = getterFn(ident, this.options, this.text);
token.fn = extend(function(self, locals) {
return getter(self, locals);
}, {
assign:function(self, value) {
return setter(self, ident, value, parser.text, parser.options);
}
});
}
this.tokens.push(token), methodName && (this.tokens.push({
index:lastDot,
text:"."
}), this.tokens.push({
index:lastDot + 1,
text:methodName
}));
},
readString:function(quote) {
var start = this.index;
this.index++;
for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
var ch = this.text.charAt(this.index);
if (rawString += ch, escape) {
if ("u" === ch) {
var hex = this.text.substring(this.index + 1, this.index + 5);
hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
} else {
var rep = ESCAPE[ch];
string += rep || ch;
}
escape = !1;
} else if ("\\" === ch) escape = !0; else {
if (ch === quote) return this.index++, this.tokens.push({
index:start,
text:rawString,
string:string,
literal:!0,
constant:!0,
fn:function() {
return string;
}
}), void 0;
string += ch;
}
this.index++;
}
this.throwError("Unterminated quote", start);
}
};
var Parser = function(lexer, $filter, options) {
this.lexer = lexer, this.$filter = $filter, this.options = options;
};
Parser.ZERO = extend(function() {
return 0;
}, {
constant:!0
}), Parser.prototype = {
constructor:Parser,
parse:function(text) {
this.text = text, this.tokens = this.lexer.lex(text);
var value = this.statements();
return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
value.literal = !!value.literal, value.constant = !!value.constant, value;
},
primary:function() {
var primary;
if (this.expect("(")) primary = this.filterChain(), this.consume(")"); else if (this.expect("[")) primary = this.arrayDeclaration(); else if (this.expect("{")) primary = this.object(); else {
var token = this.expect();
primary = token.fn, primary || this.throwError("not a primary expression", token), 
primary.literal = !!token.literal, primary.constant = !!token.constant;
}
for (var next, context; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = this.functionCall(primary, context), 
context = null) :"[" === next.text ? (context = primary, primary = this.objectIndex(primary)) :"." === next.text ? (context = primary, 
primary = this.fieldAccess(primary)) :this.throwError("IMPOSSIBLE");
return primary;
},
throwError:function(msg, token) {
throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
},
peekToken:function() {
if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
return this.tokens[0];
},
peek:function(e1, e2, e3, e4) {
if (this.tokens.length > 0) {
var token = this.tokens[0], t = token.text;
if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
}
return !1;
},
expect:function(e1, e2, e3, e4) {
var token = this.peek(e1, e2, e3, e4);
return token ? (this.tokens.shift(), token) :!1;
},
consume:function(e1) {
this.expect(e1) || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
},
unaryFn:function(fn, right) {
return extend(function(self, locals) {
return fn(self, locals, right);
}, {
constant:right.constant
});
},
ternaryFn:function(left, middle, right) {
return extend(function(self, locals) {
return left(self, locals) ? middle(self, locals) :right(self, locals);
}, {
constant:left.constant && middle.constant && right.constant
});
},
binaryFn:function(left, fn, right) {
return extend(function(self, locals) {
return fn(self, locals, left, right);
}, {
constant:left.constant && right.constant
});
},
statements:function() {
for (var statements = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), 
!this.expect(";")) return 1 === statements.length ? statements[0] :function(self, locals) {
for (var value, i = 0; i < statements.length; i++) {
var statement = statements[i];
statement && (value = statement(self, locals));
}
return value;
};
},
filterChain:function() {
for (var token, left = this.expression(); ;) {
if (!(token = this.expect("|"))) return left;
left = this.binaryFn(left, token.fn, this.filter());
}
},
filter:function() {
for (var token = this.expect(), fn = this.$filter(token.text), argsFn = []; ;) {
if (!(token = this.expect(":"))) {
var fnInvoke = function(self, locals, input) {
for (var args = [ input ], i = 0; i < argsFn.length; i++) args.push(argsFn[i](self, locals));
return fn.apply(self, args);
};
return function() {
return fnInvoke;
};
}
argsFn.push(this.expression());
}
},
expression:function() {
return this.assignment();
},
assignment:function() {
var right, token, left = this.ternary();
return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), 
right = this.ternary(), function(scope, locals) {
return left.assign(scope, right(scope, locals), locals);
}) :left;
},
ternary:function() {
var middle, token, left = this.logicalOR();
return (token = this.expect("?")) ? (middle = this.assignment(), (token = this.expect(":")) ? this.ternaryFn(left, middle, this.assignment()) :(this.throwError("expected :", token), 
void 0)) :left;
},
logicalOR:function() {
for (var token, left = this.logicalAND(); ;) {
if (!(token = this.expect("||"))) return left;
left = this.binaryFn(left, token.fn, this.logicalAND());
}
},
logicalAND:function() {
var token, left = this.equality();
return (token = this.expect("&&")) && (left = this.binaryFn(left, token.fn, this.logicalAND())), 
left;
},
equality:function() {
var token, left = this.relational();
return (token = this.expect("==", "!=", "===", "!==")) && (left = this.binaryFn(left, token.fn, this.equality())), 
left;
},
relational:function() {
var token, left = this.additive();
return (token = this.expect("<", ">", "<=", ">=")) && (left = this.binaryFn(left, token.fn, this.relational())), 
left;
},
additive:function() {
for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = this.binaryFn(left, token.fn, this.multiplicative());
return left;
},
multiplicative:function() {
for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = this.binaryFn(left, token.fn, this.unary());
return left;
},
unary:function() {
var token;
return this.expect("+") ? this.primary() :(token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.fn, this.unary()) :(token = this.expect("!")) ? this.unaryFn(token.fn, this.unary()) :this.primary();
},
fieldAccess:function(object) {
var parser = this, field = this.expect().text, getter = getterFn(field, this.options, this.text);
return extend(function(scope, locals, self) {
return getter(self || object(scope, locals));
}, {
assign:function(scope, value, locals) {
var o = object(scope, locals);
return o || object.assign(scope, o = {}), setter(o, field, value, parser.text, parser.options);
}
});
},
objectIndex:function(obj) {
var parser = this, indexFn = this.expression();
return this.consume("]"), extend(function(self, locals) {
var v, p, o = obj(self, locals), i = indexFn(self, locals);
return ensureSafeMemberName(i, parser.text), o ? (v = ensureSafeObject(o[i], parser.text), 
v && v.then && parser.options.unwrapPromises && (p = v, "$$v" in v || (p.$$v = undefined, 
p.then(function(val) {
p.$$v = val;
})), v = v.$$v), v) :undefined;
}, {
assign:function(self, value, locals) {
var key = ensureSafeMemberName(indexFn(self, locals), parser.text), o = ensureSafeObject(obj(self, locals), parser.text);
return o || obj.assign(self, o = {}), o[key] = value;
}
});
},
functionCall:function(fn, contextGetter) {
var argsFn = [];
if (")" !== this.peekToken().text) do argsFn.push(this.expression()); while (this.expect(","));
this.consume(")");
var parser = this;
return function(scope, locals) {
for (var args = [], context = contextGetter ? contextGetter(scope, locals) :scope, i = 0; i < argsFn.length; i++) args.push(ensureSafeObject(argsFn[i](scope, locals), parser.text));
var fnPtr = fn(scope, locals, context) || noop;
ensureSafeObject(context, parser.text), ensureSafeFunction(fnPtr, parser.text);
var v = fnPtr.apply ? fnPtr.apply(context, args) :fnPtr(args[0], args[1], args[2], args[3], args[4]);
return ensureSafeObject(v, parser.text);
};
},
arrayDeclaration:function() {
var elementFns = [], allConstant = !0;
if ("]" !== this.peekToken().text) do {
if (this.peek("]")) break;
var elementFn = this.expression();
elementFns.push(elementFn), elementFn.constant || (allConstant = !1);
} while (this.expect(","));
return this.consume("]"), extend(function(self, locals) {
for (var array = [], i = 0; i < elementFns.length; i++) array.push(elementFns[i](self, locals));
return array;
}, {
literal:!0,
constant:allConstant
});
},
object:function() {
var keyValues = [], allConstant = !0;
if ("}" !== this.peekToken().text) do {
if (this.peek("}")) break;
var token = this.expect(), key = token.string || token.text;
this.consume(":");
var value = this.expression();
keyValues.push({
key:key,
value:value
}), value.constant || (allConstant = !1);
} while (this.expect(","));
return this.consume("}"), extend(function(self, locals) {
for (var object = {}, i = 0; i < keyValues.length; i++) {
var keyValue = keyValues[i];
object[keyValue.key] = keyValue.value(self, locals);
}
return object;
}, {
literal:!0,
constant:allConstant
});
}
};
var getterFnCacheDefault = {}, getterFnCacheExpensive = {}, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
HTML:"html",
CSS:"css",
URL:"url",
RESOURCE_URL:"resourceUrl",
JS:"js"
}, urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href, !0);
$FilterProvider.$inject = [ "$provide" ], currencyFilter.$inject = [ "$locale" ], 
numberFilter.$inject = [ "$locale" ];
var DECIMAL_SEP = ".", DATE_FORMATS = {
yyyy:dateGetter("FullYear", 4),
yy:dateGetter("FullYear", 2, 0, !0),
y:dateGetter("FullYear", 1),
MMMM:dateStrGetter("Month"),
MMM:dateStrGetter("Month", !0),
MM:dateGetter("Month", 2, 1),
M:dateGetter("Month", 1, 1),
dd:dateGetter("Date", 2),
d:dateGetter("Date", 1),
HH:dateGetter("Hours", 2),
H:dateGetter("Hours", 1),
hh:dateGetter("Hours", 2, -12),
h:dateGetter("Hours", 1, -12),
mm:dateGetter("Minutes", 2),
m:dateGetter("Minutes", 1),
ss:dateGetter("Seconds", 2),
s:dateGetter("Seconds", 1),
sss:dateGetter("Milliseconds", 3),
EEEE:dateStrGetter("Day"),
EEE:dateStrGetter("Day", !0),
a:ampmGetter,
Z:timeZoneGetter
}, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\-?\d+$/;
dateFilter.$inject = [ "$locale" ];
var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
orderByFilter.$inject = [ "$parse" ];
var htmlAnchorDirective = valueFn({
restrict:"E",
compile:function(element, attr) {
return 8 >= msie && (attr.href || attr.name || attr.$set("href", ""), element.append(document.createComment("IE fix"))), 
attr.href || attr.xlinkHref || attr.name ? void 0 :function(scope, element) {
var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" :"href";
element.on("click", function(event) {
element.attr(href) || event.preventDefault();
});
};
}
}), ngAttributeAliasDirectives = {};
forEach(BOOLEAN_ATTR, function(propName, attrName) {
if ("multiple" != propName) {
var normalized = directiveNormalize("ng-" + attrName);
ngAttributeAliasDirectives[normalized] = function() {
return {
priority:100,
link:function(scope, element, attr) {
scope.$watch(attr[normalized], function(value) {
attr.$set(attrName, !!value);
});
}
};
};
}
}), forEach([ "src", "srcset", "href" ], function(attrName) {
var normalized = directiveNormalize("ng-" + attrName);
ngAttributeAliasDirectives[normalized] = function() {
return {
priority:99,
link:function(scope, element, attr) {
var propName = attrName, name = attrName;
"href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
return value ? (attr.$set(name, value), msie && propName && element.prop(propName, attr[name]), 
void 0) :("href" === attrName && attr.$set(name, null), void 0);
});
}
};
};
});
var nullFormCtrl = {
$addControl:noop,
$removeControl:noop,
$setValidity:noop,
$setDirty:noop,
$setPristine:noop
};
FormController.$inject = [ "$element", "$attrs", "$scope", "$animate" ];
var formDirectiveFactory = function(isNgForm) {
return [ "$timeout", function($timeout) {
var formDirective = {
name:"form",
restrict:isNgForm ? "EAC" :"E",
controller:FormController,
compile:function() {
return {
pre:function(scope, formElement, attr, controller) {
if (!attr.action) {
var preventDefaultListener = function(event) {
event.preventDefault ? event.preventDefault() :event.returnValue = !1;
};
addEventListenerFn(formElement[0], "submit", preventDefaultListener), formElement.on("$destroy", function() {
$timeout(function() {
removeEventListenerFn(formElement[0], "submit", preventDefaultListener);
}, 0, !1);
});
}
var parentFormCtrl = formElement.parent().controller("form"), alias = attr.name || attr.ngForm;
alias && setter(scope, alias, controller, alias), parentFormCtrl && formElement.on("$destroy", function() {
parentFormCtrl.$removeControl(controller), alias && setter(scope, alias, undefined, alias), 
extend(controller, nullFormCtrl);
});
}
};
}
};
return formDirective;
} ];
}, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/, inputType = {
text:textInputType,
number:numberInputType,
url:urlInputType,
email:emailInputType,
radio:radioInputType,
checkbox:checkboxInputType,
hidden:noop,
button:noop,
submit:noop,
reset:noop,
file:noop
}, numberBadFlags = [ "badInput" ], inputDirective = [ "$browser", "$sniffer", function($browser, $sniffer) {
return {
restrict:"E",
require:"?ngModel",
link:function(scope, element, attr, ctrl) {
ctrl && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
}
};
} ], VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
function toggleValidCss(isValid, validationErrorKey) {
validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") :"", 
$animate.removeClass($element, (isValid ? INVALID_CLASS :VALID_CLASS) + validationErrorKey), 
$animate.addClass($element, (isValid ? VALID_CLASS :INVALID_CLASS) + validationErrorKey);
}
this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$parsers = [], 
this.$formatters = [], this.$viewChangeListeners = [], this.$pristine = !0, this.$dirty = !1, 
this.$valid = !0, this.$invalid = !1, this.$name = $attr.name;
var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
if (!ngModelSet) throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
this.$render = noop, this.$isEmpty = function(value) {
return isUndefined(value) || "" === value || null === value || value !== value;
};
var parentForm = $element.inheritedData("$formController") || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
$element.addClass(PRISTINE_CLASS), toggleValidCss(!0), this.$setValidity = function(validationErrorKey, isValid) {
$error[validationErrorKey] !== !isValid && (isValid ? ($error[validationErrorKey] && invalidCount--, 
invalidCount || (toggleValidCss(!0), this.$valid = !0, this.$invalid = !1)) :(toggleValidCss(!1), 
this.$invalid = !0, this.$valid = !1, invalidCount++), $error[validationErrorKey] = !isValid, 
toggleValidCss(isValid, validationErrorKey), parentForm.$setValidity(validationErrorKey, isValid, this));
}, this.$setPristine = function() {
this.$dirty = !1, this.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), 
$animate.addClass($element, PRISTINE_CLASS);
}, this.$setViewValue = function(value) {
this.$viewValue = value, this.$pristine && (this.$dirty = !0, this.$pristine = !1, 
$animate.removeClass($element, PRISTINE_CLASS), $animate.addClass($element, DIRTY_CLASS), 
parentForm.$setDirty()), forEach(this.$parsers, function(fn) {
value = fn(value);
}), this.$modelValue !== value && (this.$modelValue = value, ngModelSet($scope, value), 
forEach(this.$viewChangeListeners, function(listener) {
try {
listener();
} catch (e) {
$exceptionHandler(e);
}
}));
};
var ctrl = this;
$scope.$watch(function() {
var value = ngModelGet($scope);
if (ctrl.$modelValue !== value) {
var formatters = ctrl.$formatters, idx = formatters.length;
for (ctrl.$modelValue = value; idx--; ) value = formatters[idx](value);
ctrl.$viewValue !== value && (ctrl.$viewValue = value, ctrl.$render());
}
return value;
});
} ], ngModelDirective = function() {
return {
require:[ "ngModel", "^?form" ],
controller:NgModelController,
link:function(scope, element, attr, ctrls) {
var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
formCtrl.$addControl(modelCtrl), scope.$on("$destroy", function() {
formCtrl.$removeControl(modelCtrl);
});
}
};
}, ngChangeDirective = valueFn({
require:"ngModel",
link:function(scope, element, attr, ctrl) {
ctrl.$viewChangeListeners.push(function() {
scope.$eval(attr.ngChange);
});
}
}), requiredDirective = function() {
return {
require:"?ngModel",
link:function(scope, elm, attr, ctrl) {
if (ctrl) {
attr.required = !0;
var validator = function(value) {
return attr.required && ctrl.$isEmpty(value) ? (ctrl.$setValidity("required", !1), 
void 0) :(ctrl.$setValidity("required", !0), value);
};
ctrl.$formatters.push(validator), ctrl.$parsers.unshift(validator), attr.$observe("required", function() {
validator(ctrl.$viewValue);
});
}
}
};
}, ngListDirective = function() {
return {
require:"ngModel",
link:function(scope, element, attr, ctrl) {
var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ",", parse = function(viewValue) {
if (!isUndefined(viewValue)) {
var list = [];
return viewValue && forEach(viewValue.split(separator), function(value) {
value && list.push(trim(value));
}), list;
}
};
ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
return isArray(value) ? value.join(", ") :undefined;
}), ctrl.$isEmpty = function(value) {
return !value || !value.length;
};
}
};
}, CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
return {
priority:100,
compile:function(tpl, tplAttr) {
return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
attr.$set("value", scope.$eval(attr.ngValue));
} :function(scope, elm, attr) {
scope.$watch(attr.ngValue, function(value) {
attr.$set("value", value);
});
};
}
};
}, ngBindDirective = ngDirective({
compile:function(templateElement) {
return templateElement.addClass("ng-binding"), function(scope, element, attr) {
element.data("$binding", attr.ngBind), scope.$watch(attr.ngBind, function(value) {
element.text(value == undefined ? "" :value);
});
};
}
}), ngBindTemplateDirective = [ "$interpolate", function($interpolate) {
return function(scope, element, attr) {
var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
element.addClass("ng-binding").data("$binding", interpolateFn), attr.$observe("ngBindTemplate", function(value) {
element.text(value);
});
};
} ], ngBindHtmlDirective = [ "$sce", "$parse", function($sce, $parse) {
return {
compile:function(tElement) {
return tElement.addClass("ng-binding"), function(scope, element, attr) {
function getStringValue() {
return (parsed(scope) || "").toString();
}
element.data("$binding", attr.ngBindHtml);
var parsed = $parse(attr.ngBindHtml);
scope.$watch(getStringValue, function() {
element.html($sce.getTrustedHtml(parsed(scope)) || "");
});
};
}
};
} ], ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
compile:function(element, attr) {
attr.$set("ngCloak", undefined), element.removeClass("ng-cloak");
}
}), ngControllerDirective = [ function() {
return {
scope:!0,
controller:"@",
priority:500
};
} ], ngEventDirectives = {}, forceAsyncEvents = {
blur:!0,
focus:!0
};
forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
var directiveName = directiveNormalize("ng-" + eventName);
ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
return {
compile:function($element, attr) {
var fn = $parse(attr[directiveName], !0);
return function(scope, element) {
element.on(eventName, function(event) {
var callback = function() {
fn(scope, {
$event:event
});
};
forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) :scope.$apply(callback);
});
};
}
};
} ];
});
var ngIfDirective = [ "$animate", function($animate) {
return {
transclude:"element",
priority:600,
terminal:!0,
restrict:"A",
$$tlb:!0,
link:function($scope, $element, $attr, ctrl, $transclude) {
var block, childScope, previousElements;
$scope.$watch($attr.ngIf, function(value) {
toBoolean(value) ? childScope || (childScope = $scope.$new(), $transclude(childScope, function(clone) {
clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), 
block = {
clone:clone
}, $animate.enter(clone, $element.parent(), $element);
})) :(previousElements && (previousElements.remove(), previousElements = null), 
childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockElements(block.clone), 
$animate.leave(previousElements, function() {
previousElements = null;
}), block = null));
});
}
};
} ], ngIncludeDirective = [ "$http", "$templateCache", "$anchorScroll", "$animate", "$sce", function($http, $templateCache, $anchorScroll, $animate, $sce) {
return {
restrict:"ECA",
priority:400,
terminal:!0,
transclude:"element",
controller:angular.noop,
compile:function(element, attr) {
var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
return function(scope, $element, $attr, ctrl, $transclude) {
var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
currentScope = null), currentElement && ($animate.leave(currentElement, function() {
previousElement = null;
}), previousElement = currentElement, currentElement = null);
};
scope.$watch($sce.parseAsResourceUrl(srcExp), function(src) {
var afterAnimation = function() {
!isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
}, thisChangeId = ++changeCounter;
src ? ($http.get(src, {
cache:$templateCache
}).success(function(response) {
if (thisChangeId === changeCounter) {
var newScope = scope.$new();
ctrl.template = response;
var clone = $transclude(newScope, function(clone) {
cleanupLastIncludeContent(), $animate.enter(clone, null, $element, afterAnimation);
});
currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded"), 
scope.$eval(onloadExp);
}
}).error(function() {
thisChangeId === changeCounter && cleanupLastIncludeContent();
}), scope.$emit("$includeContentRequested")) :(cleanupLastIncludeContent(), ctrl.template = null);
});
};
}
};
} ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
return {
restrict:"ECA",
priority:-400,
require:"ngInclude",
link:function(scope, $element, $attr, ctrl) {
$element.html(ctrl.template), $compile($element.contents())(scope);
}
};
} ], ngInitDirective = ngDirective({
priority:450,
compile:function() {
return {
pre:function(scope, element, attrs) {
scope.$eval(attrs.ngInit);
}
};
}
}), ngNonBindableDirective = ngDirective({
terminal:!0,
priority:1e3
}), ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
var BRACE = /{}/g;
return {
restrict:"EA",
link:function(scope, element, attr) {
var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), isWhen = /^when(Minus)?(.+)$/;
forEach(attr, function(expression, attributeName) {
isWhen.test(attributeName) && (whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]));
}), forEach(whens, function(expression, key) {
whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol));
}), scope.$watch(function() {
var value = parseFloat(scope.$eval(numberExp));
return isNaN(value) ? "" :(value in whens || (value = $locale.pluralCat(value - offset)), 
whensExpFns[value](scope, element, !0));
}, function(newVal) {
element.text(newVal);
});
}
};
} ], ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
function getBlockStart(block) {
return block.clone[0];
}
function getBlockEnd(block) {
return block.clone[block.clone.length - 1];
}
var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat");
return {
transclude:"element",
priority:1e3,
terminal:!0,
$$tlb:!0,
link:function($scope, $element, $attr, ctrl, $transclude) {
var trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, expression = $attr.ngRepeat, match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), hashFnLocals = {
$id:hashKey
};
if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
if (lhs = match[1], rhs = match[2], trackByExp = match[3], trackByExp ? (trackByExpGetter = $parse(trackByExp), 
trackByIdExpFn = function(key, value, index) {
return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
}) :(trackByIdArrayFn = function(key, value) {
return hashKey(value);
}, trackByIdObjFn = function(key) {
return key;
}), match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
var lastBlockMap = {};
$scope.$watchCollection(rhs, function(collection) {
var index, length, nextNode, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, elementsToRemove, previousNode = $element[0], nextBlockMap = {}, nextBlockOrder = [];
if (isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
for (key in collection) collection.hasOwnProperty(key) && "$" != key.charAt(0) && collectionKeys.push(key);
collectionKeys.sort();
}
for (arrayLength = collectionKeys.length, length = nextBlockOrder.length = collectionKeys.length, 
index = 0; length > index; index++) if (key = collection === collectionKeys ? index :collectionKeys[index], 
value = collection[key], trackById = trackByIdFn(key, value, index), assertNotHasOwnProperty(trackById, "`track by` id"), 
lastBlockMap.hasOwnProperty(trackById)) block = lastBlockMap[trackById], delete lastBlockMap[trackById], 
nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
if (nextBlockMap.hasOwnProperty(trackById)) throw forEach(nextBlockOrder, function(block) {
block && block.scope && (lastBlockMap[block.id] = block);
}), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, toJson(value));
nextBlockOrder[index] = {
id:trackById
}, nextBlockMap[trackById] = !1;
}
for (key in lastBlockMap) lastBlockMap.hasOwnProperty(key) && (block = lastBlockMap[key], 
elementsToRemove = getBlockElements(block.clone), $animate.leave(elementsToRemove), 
forEach(elementsToRemove, function(element) {
element[NG_REMOVED] = !0;
}), block.scope.$destroy());
for (index = 0, length = collectionKeys.length; length > index; index++) {
if (key = collection === collectionKeys ? index :collectionKeys[index], value = collection[key], 
block = nextBlockOrder[index], nextBlockOrder[index - 1] && (previousNode = getBlockEnd(nextBlockOrder[index - 1])), 
block.scope) {
childScope = block.scope, nextNode = previousNode;
do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
getBlockStart(block) != nextNode && $animate.move(getBlockElements(block.clone), null, jqLite(previousNode)), 
previousNode = getBlockEnd(block);
} else childScope = $scope.$new();
childScope[valueIdentifier] = value, keyIdentifier && (childScope[keyIdentifier] = key), 
childScope.$index = index, childScope.$first = 0 === index, childScope.$last = index === arrayLength - 1, 
childScope.$middle = !(childScope.$first || childScope.$last), childScope.$odd = !(childScope.$even = 0 === (1 & index)), 
block.scope || $transclude(childScope, function(clone) {
clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " "), 
$animate.enter(clone, null, jqLite(previousNode)), previousNode = clone, block.scope = childScope, 
block.clone = clone, nextBlockMap[block.id] = block;
});
}
lastBlockMap = nextBlockMap;
});
}
};
} ], ngShowDirective = [ "$animate", function($animate) {
return function(scope, element, attr) {
scope.$watch(attr.ngShow, function(value) {
$animate[toBoolean(value) ? "removeClass" :"addClass"](element, "ng-hide");
});
};
} ], ngHideDirective = [ "$animate", function($animate) {
return function(scope, element, attr) {
scope.$watch(attr.ngHide, function(value) {
$animate[toBoolean(value) ? "addClass" :"removeClass"](element, "ng-hide");
});
};
} ], ngStyleDirective = ngDirective(function(scope, element, attr) {
scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
element.css(style, "");
}), newStyles && element.css(newStyles);
}, !0);
}), ngSwitchDirective = [ "$animate", function($animate) {
return {
restrict:"EA",
require:"ngSwitch",
controller:[ "$scope", function() {
this.cases = {};
} ],
link:function(scope, element, attr, ngSwitchController) {
var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousElements = [], selectedScopes = [];
scope.$watch(watchExpr, function(value) {
var i, ii;
for (i = 0, ii = previousElements.length; ii > i; ++i) previousElements[i].remove();
for (previousElements.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
var selected = selectedElements[i];
selectedScopes[i].$destroy(), previousElements[i] = selected, $animate.leave(selected, function() {
previousElements.splice(i, 1);
});
}
selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && (scope.$eval(attr.change), 
forEach(selectedTranscludes, function(selectedTransclude) {
var selectedScope = scope.$new();
selectedScopes.push(selectedScope), selectedTransclude.transclude(selectedScope, function(caseElement) {
var anchor = selectedTransclude.element;
selectedElements.push(caseElement), $animate.enter(caseElement, anchor.parent(), anchor);
});
}));
});
}
};
} ], ngSwitchWhenDirective = ngDirective({
transclude:"element",
priority:800,
require:"^ngSwitch",
link:function(scope, element, attrs, ctrl, $transclude) {
ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], 
ctrl.cases["!" + attrs.ngSwitchWhen].push({
transclude:$transclude,
element:element
});
}
}), ngSwitchDefaultDirective = ngDirective({
transclude:"element",
priority:800,
require:"^ngSwitch",
link:function(scope, element, attr, ctrl, $transclude) {
ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
transclude:$transclude,
element:element
});
}
}), ngTranscludeDirective = ngDirective({
link:function($scope, $element, $attrs, controller, $transclude) {
if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
$transclude(function(clone) {
$element.empty(), $element.append(clone);
});
}
}), scriptDirective = [ "$templateCache", function($templateCache) {
return {
restrict:"E",
terminal:!0,
compile:function(element, attr) {
if ("text/ng-template" == attr.type) {
var templateUrl = attr.id, text = element[0].text;
$templateCache.put(templateUrl, text);
}
}
};
} ], ngOptionsMinErr = minErr("ngOptions"), ngOptionsDirective = valueFn({
terminal:!0
}), selectDirective = [ "$compile", "$parse", function($compile, $parse) {
var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
$setViewValue:noop
};
return {
restrict:"E",
require:[ "select", "?ngModel" ],
controller:[ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
var nullOption, unknownOption, self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl;
self.databound = $attrs.ngModel, self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
ngModelCtrl = ngModelCtrl_, nullOption = nullOption_, unknownOption = unknownOption_;
}, self.addOption = function(value) {
assertNotHasOwnProperty(value, '"option value"'), optionsMap[value] = !0, ngModelCtrl.$viewValue == value && ($element.val(value), 
unknownOption.parent() && unknownOption.remove());
}, self.removeOption = function(value) {
this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue == value && this.renderUnknownOption(value));
}, self.renderUnknownOption = function(val) {
var unknownVal = "? " + hashKey(val) + " ?";
unknownOption.val(unknownVal), $element.prepend(unknownOption), $element.val(unknownVal), 
unknownOption.prop("selected", !0);
}, self.hasOption = function(value) {
return optionsMap.hasOwnProperty(value);
}, $scope.$on("$destroy", function() {
self.renderUnknownOption = noop;
});
} ],
link:function(scope, element, attr, ctrls) {
function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
ngModelCtrl.$render = function() {
var viewValue = ngModelCtrl.$viewValue;
selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), 
selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) :isUndefined(viewValue) && emptyOption ? selectElement.val("") :selectCtrl.renderUnknownOption(viewValue);
}, selectElement.on("change", function() {
scope.$apply(function() {
unknownOption.parent() && unknownOption.remove(), ngModelCtrl.$setViewValue(selectElement.val());
});
});
}
function setupAsMultiple(scope, selectElement, ctrl) {
var lastView;
ctrl.$render = function() {
var items = new HashMap(ctrl.$viewValue);
forEach(selectElement.find("option"), function(option) {
option.selected = isDefined(items.get(option.value));
});
}, scope.$watch(function() {
equals(lastView, ctrl.$viewValue) || (lastView = shallowCopy(ctrl.$viewValue), ctrl.$render());
}), selectElement.on("change", function() {
scope.$apply(function() {
var array = [];
forEach(selectElement.find("option"), function(option) {
option.selected && array.push(option.value);
}), ctrl.$setViewValue(array);
});
});
}
function setupAsOptions(scope, selectElement, ctrl) {
function getSelectedSet() {
var selectedSet = !1;
if (multiple) {
var modelValue = ctrl.$modelValue;
if (trackFn && isArray(modelValue)) {
selectedSet = new HashMap([]);
for (var locals = {}, trackIndex = 0; trackIndex < modelValue.length; trackIndex++) locals[valueName] = modelValue[trackIndex], 
selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
} else selectedSet = new HashMap(modelValue);
}
return selectedSet;
}
function render() {
var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionGroups = {
"":[]
}, optionGroupNames = [ "" ], modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) :values, locals = {}, selectedSet = getSelectedSet();
for (index = 0; length = keys.length, length > index; index++) {
if (key = index, keyName) {
if (key = keys[index], "$" === key.charAt(0)) continue;
locals[keyName] = key;
}
if (locals[valueName] = values[key], optionGroupName = groupByFn(scope, locals) || "", 
(optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], 
optionGroupNames.push(optionGroupName)), multiple) selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) :valueFn(scope, locals))); else {
if (trackFn) {
var modelCast = {};
modelCast[valueName] = modelValue, selected = trackFn(scope, modelCast) === trackFn(scope, locals);
} else selected = modelValue === valueFn(scope, locals);
selectedSet = selectedSet || selected;
}
label = displayFn(scope, locals), label = isDefined(label) ? label :"", optionGroup.push({
id:trackFn ? trackFn(scope, locals) :keyName ? keys[index] :index,
label:label,
selected:selected
});
}
for (multiple || (nullOption || null === modelValue ? optionGroups[""].unshift({
id:"",
label:"",
selected:!selectedSet
}) :selectedSet || optionGroups[""].unshift({
id:"?",
label:"",
selected:!0
})), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], 
optionGroupsCache.length <= groupIndex ? (existingParent = {
element:optGroupTemplate.clone().attr("label", optionGroupName),
label:optionGroup.label
}, existingOptions = [ existingParent ], optionGroupsCache.push(existingOptions), 
selectElement.append(existingParent.element)) :(existingOptions = optionGroupsCache[groupIndex], 
existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), 
lastElement = null, index = 0, length = optionGroup.length; length > index; index++) option = optionGroup[index], 
(existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, 
existingOption.label !== option.label && (lastElement.text(existingOption.label = option.label), 
lastElement.prop("label", existingOption.label)), existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), 
lastElement[0].selected !== option.selected && (lastElement.prop("selected", existingOption.selected = option.selected), 
msie && lastElement.prop("selected", existingOption.selected))) :("" === option.id && nullOption ? element = nullOption :(element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label), 
existingOptions.push(existingOption = {
element:element,
label:option.label,
id:option.id,
selected:option.selected
}), selectCtrl.addOption(option.label, element), lastElement ? lastElement.after(element) :existingParent.element.append(element), 
lastElement = element);
for (index++; existingOptions.length > index; ) option = existingOptions.pop(), 
selectCtrl.removeOption(option.label), option.element.remove();
}
for (;optionGroupsCache.length > groupIndex; ) optionGroupsCache.pop()[0].element.remove();
}
var match;
if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] :valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) :null, optionGroupsCache = [ [ {
element:selectElement,
label:""
} ] ];
nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), 
nullOption.remove()), selectElement.empty(), selectElement.on("change", function() {
scope.$apply(function() {
var optionGroup, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex, collection = valuesFn(scope) || [], locals = {};
if (multiple) {
for (value = [], groupIndex = 0, groupLength = optionGroupsCache.length; groupLength > groupIndex; groupIndex++) for (optionGroup = optionGroupsCache[groupIndex], 
index = 1, length = optionGroup.length; length > index; index++) if ((optionElement = optionGroup[index].element)[0].selected) {
if (key = optionElement.val(), keyName && (locals[keyName] = key), trackFn) for (trackIndex = 0; trackIndex < collection.length && (locals[valueName] = collection[trackIndex], 
trackFn(scope, locals) != key); trackIndex++) ; else locals[valueName] = collection[key];
value.push(valueFn(scope, locals));
}
} else if (key = selectElement.val(), "?" == key) value = undefined; else if ("" === key) value = null; else if (trackFn) {
for (trackIndex = 0; trackIndex < collection.length; trackIndex++) if (locals[valueName] = collection[trackIndex], 
trackFn(scope, locals) == key) {
value = valueFn(scope, locals);
break;
}
} else locals[valueName] = collection[key], keyName && (locals[keyName] = key), 
value = valueFn(scope, locals);
ctrl.$setViewValue(value), render();
});
}), ctrl.$render = render, scope.$watchCollection(valuesFn, render), scope.$watchCollection(function() {
var locals = {}, values = valuesFn(scope);
if (values) {
for (var toDisplay = new Array(values.length), i = 0, ii = values.length; ii > i; i++) locals[valueName] = values[i], 
toDisplay[i] = displayFn(scope, locals);
return toDisplay;
}
}, render), multiple && scope.$watchCollection(function() {
return ctrl.$modelValue;
}, render);
}
if (ctrls[1]) {
for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
emptyOption = nullOption = children.eq(i);
break;
}
selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (ngModelCtrl.$isEmpty = function(value) {
return !value || 0 === value.length;
}), optionsExp ? setupAsOptions(scope, element, ngModelCtrl) :multiple ? setupAsMultiple(scope, element, ngModelCtrl) :setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
}
}
};
} ], optionDirective = [ "$interpolate", function($interpolate) {
var nullSelectCtrl = {
addOption:noop,
removeOption:noop
};
return {
restrict:"E",
priority:100,
compile:function(element, attr) {
if (isUndefined(attr.value)) {
var interpolateFn = $interpolate(element.text(), !0);
interpolateFn || attr.$set("value", element.text());
}
return function(scope, element, attr) {
var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
selectCtrl && selectCtrl.databound ? element.prop("selected", !1) :selectCtrl = nullSelectCtrl, 
interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
attr.$set("value", newVal), newVal !== oldVal && selectCtrl.removeOption(oldVal), 
selectCtrl.addOption(newVal);
}) :selectCtrl.addOption(attr.value), element.on("$destroy", function() {
selectCtrl.removeOption(attr.value);
});
};
}
};
} ], styleDirective = valueFn({
restrict:"E",
terminal:!0
});
return window.angular.bootstrap ? (console.log("WARNING: Tried to load angular more than once."), 
void 0) :(bindJQuery(), publishExternalAPI(angular), jqLite(document).ready(function() {
angularInit(document, bootstrap);
}), void 0);
}(window, document), !window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>'), 
function(window, angular) {
"use strict";
function $RouteProvider() {
function inherit(parent, extra) {
return angular.extend(new (angular.extend(function() {}, {
prototype:parent
}))(), extra);
}
function pathRegExp(path, opts) {
var insensitive = opts.caseInsensitiveMatch, ret = {
originalPath:path,
regexp:path
}, keys = ret.keys = [];
return path = path.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)([\?\*])?/g, function(_, slash, key, option) {
var optional = "?" === option ? option :null, star = "*" === option ? option :null;
return keys.push({
name:key,
optional:!!optional
}), slash = slash || "", "" + (optional ? "" :slash) + "(?:" + (optional ? slash :"") + (star && "(.+?)" || "([^/]+)") + (optional || "") + ")" + (optional || "");
}).replace(/([\/$\*])/g, "\\$1"), ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" :""), 
ret;
}
var routes = {};
this.when = function(path, route) {
if (routes[path] = angular.extend({
reloadOnSearch:!0
}, route, path && pathRegExp(path, route)), path) {
var redirectPath = "/" == path[path.length - 1] ? path.substr(0, path.length - 1) :path + "/";
routes[redirectPath] = angular.extend({
redirectTo:path
}, pathRegExp(redirectPath, route));
}
return this;
}, this.otherwise = function(params) {
return this.when(null, params), this;
}, this.$get = [ "$rootScope", "$location", "$routeParams", "$q", "$injector", "$http", "$templateCache", "$sce", function($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache, $sce) {
function switchRouteMatcher(on, route) {
var keys = route.keys, params = {};
if (!route.regexp) return null;
var m = route.regexp.exec(on);
if (!m) return null;
for (var i = 1, len = m.length; len > i; ++i) {
var key = keys[i - 1], val = m[i];
key && val && (params[key.name] = val);
}
return params;
}
function updateRoute() {
var next = parseRoute(), last = $route.current;
next && last && next.$$route === last.$$route && angular.equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload ? (last.params = next.params, 
angular.copy(last.params, $routeParams), $rootScope.$broadcast("$routeUpdate", last)) :(next || last) && (forceReload = !1, 
$rootScope.$broadcast("$routeChangeStart", next, last), $route.current = next, next && next.redirectTo && (angular.isString(next.redirectTo) ? $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace() :$location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace()), 
$q.when(next).then(function() {
if (next) {
var template, templateUrl, locals = angular.extend({}, next.resolve);
return angular.forEach(locals, function(value, key) {
locals[key] = angular.isString(value) ? $injector.get(value) :$injector.invoke(value);
}), angular.isDefined(template = next.template) ? angular.isFunction(template) && (template = template(next.params)) :angular.isDefined(templateUrl = next.templateUrl) && (angular.isFunction(templateUrl) && (templateUrl = templateUrl(next.params)), 
templateUrl = $sce.getTrustedResourceUrl(templateUrl), angular.isDefined(templateUrl) && (next.loadedTemplateUrl = templateUrl, 
template = $http.get(templateUrl, {
cache:$templateCache
}).then(function(response) {
return response.data;
}))), angular.isDefined(template) && (locals.$template = template), $q.all(locals);
}
}).then(function(locals) {
next == $route.current && (next && (next.locals = locals, angular.copy(next.params, $routeParams)), 
$rootScope.$broadcast("$routeChangeSuccess", next, last));
}, function(error) {
next == $route.current && $rootScope.$broadcast("$routeChangeError", next, last, error);
}));
}
function parseRoute() {
var params, match;
return angular.forEach(routes, function(route) {
!match && (params = switchRouteMatcher($location.path(), route)) && (match = inherit(route, {
params:angular.extend({}, $location.search(), params),
pathParams:params
}), match.$$route = route);
}), match || routes[null] && inherit(routes[null], {
params:{},
pathParams:{}
});
}
function interpolate(string, params) {
var result = [];
return angular.forEach((string || "").split(":"), function(segment, i) {
if (0 === i) result.push(segment); else {
var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/), key = segmentMatch[1];
result.push(params[key]), result.push(segmentMatch[2] || ""), delete params[key];
}
}), result.join("");
}
var forceReload = !1, $route = {
routes:routes,
reload:function() {
forceReload = !0, $rootScope.$evalAsync(updateRoute);
}
};
return $rootScope.$on("$locationChangeSuccess", updateRoute), $route;
} ];
}
function $RouteParamsProvider() {
this.$get = function() {
return {};
};
}
function ngViewFactory($route, $anchorScroll, $animate) {
return {
restrict:"ECA",
terminal:!0,
priority:400,
transclude:"element",
link:function(scope, $element, attr, ctrl, $transclude) {
function cleanupLastView() {
previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
currentScope = null), currentElement && ($animate.leave(currentElement, function() {
previousElement = null;
}), previousElement = currentElement, currentElement = null);
}
function update() {
var locals = $route.current && $route.current.locals, template = locals && locals.$template;
if (angular.isDefined(template)) {
var newScope = scope.$new(), current = $route.current, clone = $transclude(newScope, function(clone) {
$animate.enter(clone, null, currentElement || $element, function() {
!angular.isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
}), cleanupLastView();
});
currentElement = clone, currentScope = current.scope = newScope, currentScope.$emit("$viewContentLoaded"), 
currentScope.$eval(onloadExp);
} else cleanupLastView();
}
var currentScope, currentElement, previousElement, autoScrollExp = attr.autoscroll, onloadExp = attr.onload || "";
scope.$on("$routeChangeSuccess", update), update();
}
};
}
function ngViewFillContentFactory($compile, $controller, $route) {
return {
restrict:"ECA",
priority:-400,
link:function(scope, $element) {
var current = $route.current, locals = current.locals;
$element.html(locals.$template);
var link = $compile($element.contents());
if (current.controller) {
locals.$scope = scope;
var controller = $controller(current.controller, locals);
current.controllerAs && (scope[current.controllerAs] = controller), $element.data("$ngControllerController", controller), 
$element.children().data("$ngControllerController", controller);
}
link(scope);
}
};
}
var ngRouteModule = angular.module("ngRoute", [ "ng" ]).provider("$route", $RouteProvider);
ngRouteModule.provider("$routeParams", $RouteParamsProvider), ngRouteModule.directive("ngView", ngViewFactory), 
ngRouteModule.directive("ngView", ngViewFillContentFactory), ngViewFactory.$inject = [ "$route", "$anchorScroll", "$animate" ], 
ngViewFillContentFactory.$inject = [ "$compile", "$controller", "$route" ];
}(window, window.angular), function(window, angular, undefined) {
"use strict";
angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
return function(scope, element, attrs) {
var val = attrs.ngAnimateChildren;
angular.isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN, !0) :scope.$watch(val, function(value) {
element.data(NG_ANIMATE_CHILDREN, !!value);
});
};
}).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
var bod = $document[0].body;
return function(fn) {
return $$rAF(function() {
bod.offsetWidth + 1;
fn();
});
};
} ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
function extractElementNode(element) {
for (var i = 0; i < element.length; i++) {
var elm = element[i];
if (elm.nodeType == ELEMENT_NODE) return elm;
}
}
function prepareElement(element) {
return element && angular.element(element);
}
function stripCommentsFromElement(element) {
return angular.element(extractElementNode(element));
}
function isMatchingElement(elm1, elm2) {
return extractElementNode(elm1) == extractElementNode(elm2);
}
var noop = angular.noop, forEach = angular.forEach, selectors = $animateProvider.$$selectors, ELEMENT_NODE = 1, NG_ANIMATE_STATE = "$$ngAnimateState", NG_ANIMATE_CHILDREN = "$$ngAnimateChildren", NG_ANIMATE_CLASS_NAME = "ng-animate", rootAnimateState = {
running:!0
};
$provide.decorator("$animate", [ "$delegate", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", function($delegate, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope) {
function blockElementAnimations(element) {
var data = element.data(NG_ANIMATE_STATE) || {};
data.running = !0, element.data(NG_ANIMATE_STATE, data);
}
function lookup(name) {
if (name) {
var matches = [], flagMap = {}, classes = name.substr(1).split(".");
($sniffer.transitions || $sniffer.animations) && matches.push($injector.get(selectors[""]));
for (var i = 0; i < classes.length; i++) {
var klass = classes[i], selectorFactoryName = selectors[klass];
selectorFactoryName && !flagMap[klass] && (matches.push($injector.get(selectorFactoryName)), 
flagMap[klass] = !0);
}
return matches;
}
}
function animationRunner(element, animationEvent, className) {
function registerAnimation(animationFactory, event) {
var afterFn = animationFactory[event], beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
return afterFn || beforeFn ? ("leave" == event && (beforeFn = afterFn, afterFn = null), 
after.push({
event:event,
fn:afterFn
}), before.push({
event:event,
fn:beforeFn
}), !0) :void 0;
}
function run(fns, cancellations, allCompleteFn) {
function afterAnimationComplete(index) {
if (cancellations) {
if ((cancellations[index] || noop)(), ++count < animations.length) return;
cancellations = null;
}
allCompleteFn();
}
var animations = [];
forEach(fns, function(animation) {
animation.fn && animations.push(animation);
});
var count = 0;
forEach(animations, function(animation, index) {
var progress = function() {
afterAnimationComplete(index);
};
switch (animation.event) {
case "setClass":
cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress));
break;

case "addClass":
cancellations.push(animation.fn(element, classNameAdd || className, progress));
break;

case "removeClass":
cancellations.push(animation.fn(element, classNameRemove || className, progress));
break;

default:
cancellations.push(animation.fn(element, progress));
}
}), cancellations && 0 === cancellations.length && allCompleteFn();
}
var node = element[0];
if (node) {
var classNameAdd, classNameRemove, isSetClassOperation = "setClass" == animationEvent, isClassBased = isSetClassOperation || "addClass" == animationEvent || "removeClass" == animationEvent;
angular.isArray(className) && (classNameAdd = className[0], classNameRemove = className[1], 
className = classNameAdd + " " + classNameRemove);
var currentClassName = element.attr("class"), classes = currentClassName + " " + className;
if (isAnimatableClassName(classes)) {
var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [], animationLookup = (" " + classes).replace(/\s+/g, ".");
return forEach(lookup(animationLookup), function(animationFactory) {
var created = registerAnimation(animationFactory, animationEvent);
!created && isSetClassOperation && (registerAnimation(animationFactory, "addClass"), 
registerAnimation(animationFactory, "removeClass"));
}), {
node:node,
event:animationEvent,
className:className,
isClassBased:isClassBased,
isSetClassOperation:isSetClassOperation,
before:function(allCompleteFn) {
beforeComplete = allCompleteFn, run(before, beforeCancel, function() {
beforeComplete = noop, allCompleteFn();
});
},
after:function(allCompleteFn) {
afterComplete = allCompleteFn, run(after, afterCancel, function() {
afterComplete = noop, allCompleteFn();
});
},
cancel:function() {
beforeCancel && (forEach(beforeCancel, function(cancelFn) {
(cancelFn || noop)(!0);
}), beforeComplete(!0)), afterCancel && (forEach(afterCancel, function(cancelFn) {
(cancelFn || noop)(!0);
}), afterComplete(!0));
}
};
}
}
}
function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
function fireDOMCallback(animationPhase) {
var eventName = "$animate:" + animationPhase;
elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0 && $$asyncCallback(function() {
element.triggerHandler(eventName, {
event:animationEvent,
className:className
});
});
}
function fireBeforeCallbackAsync() {
fireDOMCallback("before");
}
function fireAfterCallbackAsync() {
fireDOMCallback("after");
}
function fireDoneCallbackAsync() {
fireDOMCallback("close"), doneCallback && $$asyncCallback(function() {
doneCallback();
});
}
function fireDOMOperation() {
fireDOMOperation.hasBeenRun || (fireDOMOperation.hasBeenRun = !0, domOperation());
}
function closeAnimation() {
if (!closeAnimation.hasBeenRun) {
closeAnimation.hasBeenRun = !0;
var data = element.data(NG_ANIMATE_STATE);
data && (runner && runner.isClassBased ? cleanup(element, className) :($$asyncCallback(function() {
var data = element.data(NG_ANIMATE_STATE) || {};
localAnimationCount == data.index && cleanup(element, className, animationEvent);
}), element.data(NG_ANIMATE_STATE, data))), fireDoneCallbackAsync();
}
}
var runner = animationRunner(element, animationEvent, className);
if (!runner) return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), 
closeAnimation(), void 0;
className = runner.className;
var elementEvents = angular.element._data(runner.node);
elementEvents = elementEvents && elementEvents.events, parentElement || (parentElement = afterElement ? afterElement.parent() :element.parent());
var skipAnimations, ngAnimateState = element.data(NG_ANIMATE_STATE) || {}, runningAnimations = ngAnimateState.active || {}, totalActiveAnimations = ngAnimateState.totalActive || 0, lastAnimation = ngAnimateState.last;
if (runner.isClassBased && (skipAnimations = ngAnimateState.running || ngAnimateState.disabled || lastAnimation && !lastAnimation.isClassBased), 
skipAnimations || animationsDisabled(element, parentElement)) return fireDOMOperation(), 
fireBeforeCallbackAsync(), fireAfterCallbackAsync(), closeAnimation(), void 0;
var skipAnimation = !1;
if (totalActiveAnimations > 0) {
var animationsToCancel = [];
if (runner.isClassBased) {
if ("setClass" == lastAnimation.event) animationsToCancel.push(lastAnimation), cleanup(element, className); else if (runningAnimations[className]) {
var current = runningAnimations[className];
current.event == animationEvent ? skipAnimation = !0 :(animationsToCancel.push(current), 
cleanup(element, className));
}
} else if ("leave" == animationEvent && runningAnimations["ng-leave"]) skipAnimation = !0; else {
for (var klass in runningAnimations) animationsToCancel.push(runningAnimations[klass]), 
cleanup(element, klass);
runningAnimations = {}, totalActiveAnimations = 0;
}
animationsToCancel.length > 0 && forEach(animationsToCancel, function(operation) {
operation.cancel();
});
}
if (!runner.isClassBased || runner.isSetClassOperation || skipAnimation || (skipAnimation = "addClass" == animationEvent == element.hasClass(className)), 
skipAnimation) return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), 
fireDoneCallbackAsync(), void 0;
"leave" == animationEvent && element.one("$destroy", function() {
var element = angular.element(this), state = element.data(NG_ANIMATE_STATE);
if (state) {
var activeLeaveAnimation = state.active["ng-leave"];
activeLeaveAnimation && (activeLeaveAnimation.cancel(), cleanup(element, "ng-leave"));
}
}), element.addClass(NG_ANIMATE_CLASS_NAME);
var localAnimationCount = globalAnimationCounter++;
totalActiveAnimations++, runningAnimations[className] = runner, element.data(NG_ANIMATE_STATE, {
last:runner,
active:runningAnimations,
index:localAnimationCount,
totalActive:totalActiveAnimations
}), fireBeforeCallbackAsync(), runner.before(function(cancelled) {
var data = element.data(NG_ANIMATE_STATE);
cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent, 
fireDOMOperation(), cancelled === !0 ? closeAnimation() :(fireAfterCallbackAsync(), 
runner.after(closeAnimation));
});
}
function cancelChildAnimations(element) {
var node = extractElementNode(element);
if (node) {
var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) :node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
forEach(nodes, function(element) {
element = angular.element(element);
var data = element.data(NG_ANIMATE_STATE);
data && data.active && forEach(data.active, function(runner) {
runner.cancel();
});
});
}
}
function cleanup(element, className) {
if (isMatchingElement(element, $rootElement)) rootAnimateState.disabled || (rootAnimateState.running = !1, 
rootAnimateState.structural = !1); else if (className) {
var data = element.data(NG_ANIMATE_STATE) || {}, removeAnimations = className === !0;
!removeAnimations && data.active && data.active[className] && (data.totalActive--, 
delete data.active[className]), (removeAnimations || !data.totalActive) && (element.removeClass(NG_ANIMATE_CLASS_NAME), 
element.removeData(NG_ANIMATE_STATE));
}
}
function animationsDisabled(element, parentElement) {
if (rootAnimateState.disabled) return !0;
if (isMatchingElement(element, $rootElement)) return rootAnimateState.running;
var allowChildAnimations, parentRunningAnimation, hasParent;
do {
if (0 === parentElement.length) break;
var isRoot = isMatchingElement(parentElement, $rootElement), state = isRoot ? rootAnimateState :parentElement.data(NG_ANIMATE_STATE) || {};
if (state.disabled) return !0;
if (isRoot && (hasParent = !0), allowChildAnimations !== !1) {
var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
angular.isDefined(animateChildrenFlag) && (allowChildAnimations = animateChildrenFlag);
}
parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
} while (parentElement = parentElement.parent());
return !hasParent || !allowChildAnimations && parentRunningAnimation;
}
var globalAnimationCounter = 0;
$rootElement.data(NG_ANIMATE_STATE, rootAnimateState), $rootScope.$$postDigest(function() {
$rootScope.$$postDigest(function() {
rootAnimateState.running = !1;
});
});
var classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function(className) {
return classNameFilter.test(className);
} :function() {
return !0;
};
return {
enter:function(element, parentElement, afterElement, doneCallback) {
element = angular.element(element), parentElement = prepareElement(parentElement), 
afterElement = prepareElement(afterElement), blockElementAnimations(element), $delegate.enter(element, parentElement, afterElement), 
$rootScope.$$postDigest(function() {
element = stripCommentsFromElement(element), performAnimation("enter", "ng-enter", element, parentElement, afterElement, noop, doneCallback);
});
},
leave:function(element, doneCallback) {
element = angular.element(element), cancelChildAnimations(element), blockElementAnimations(element), 
$rootScope.$$postDigest(function() {
performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
$delegate.leave(element);
}, doneCallback);
});
},
move:function(element, parentElement, afterElement, doneCallback) {
element = angular.element(element), parentElement = prepareElement(parentElement), 
afterElement = prepareElement(afterElement), cancelChildAnimations(element), blockElementAnimations(element), 
$delegate.move(element, parentElement, afterElement), $rootScope.$$postDigest(function() {
element = stripCommentsFromElement(element), performAnimation("move", "ng-move", element, parentElement, afterElement, noop, doneCallback);
});
},
addClass:function(element, className, doneCallback) {
element = angular.element(element), element = stripCommentsFromElement(element), 
performAnimation("addClass", className, element, null, null, function() {
$delegate.addClass(element, className);
}, doneCallback);
},
removeClass:function(element, className, doneCallback) {
element = angular.element(element), element = stripCommentsFromElement(element), 
performAnimation("removeClass", className, element, null, null, function() {
$delegate.removeClass(element, className);
}, doneCallback);
},
setClass:function(element, add, remove, doneCallback) {
element = angular.element(element), element = stripCommentsFromElement(element), 
performAnimation("setClass", [ add, remove ], element, null, null, function() {
$delegate.setClass(element, add, remove);
}, doneCallback);
},
enabled:function(value, element) {
switch (arguments.length) {
case 2:
if (value) cleanup(element); else {
var data = element.data(NG_ANIMATE_STATE) || {};
data.disabled = !0, element.data(NG_ANIMATE_STATE, data);
}
break;

case 1:
rootAnimateState.disabled = !value;
break;

default:
value = !rootAnimateState.disabled;
}
return !!value;
}
};
} ]), $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
function clearCacheAfterReflow() {
cancelAnimationReflow || (cancelAnimationReflow = $$animateReflow(function() {
animationReflowQueue = [], cancelAnimationReflow = null, lookupCache = {};
}));
}
function afterReflow(element, callback) {
cancelAnimationReflow && cancelAnimationReflow(), animationReflowQueue.push(callback), 
cancelAnimationReflow = $$animateReflow(function() {
forEach(animationReflowQueue, function(fn) {
fn();
}), animationReflowQueue = [], cancelAnimationReflow = null, lookupCache = {};
});
}
function animationCloseHandler(element, totalTime) {
var node = extractElementNode(element);
element = angular.element(node), animationElementQueue.push(element);
var futureTimestamp = Date.now() + totalTime;
closingTimestamp >= futureTimestamp || ($timeout.cancel(closingTimer), closingTimestamp = futureTimestamp, 
closingTimer = $timeout(function() {
closeAllAnimations(animationElementQueue), animationElementQueue = [];
}, totalTime, !1));
}
function closeAllAnimations(elements) {
forEach(elements, function(element) {
var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
elementData && (elementData.closeAnimationFn || noop)();
});
}
function getElementAnimationDetails(element, cacheKey) {
var data = cacheKey ? lookupCache[cacheKey] :null;
if (!data) {
var transitionDelayStyle, animationDelayStyle, transitionDurationStyle, transitionPropertyStyle, transitionDuration = 0, transitionDelay = 0, animationDuration = 0, animationDelay = 0;
forEach(element, function(element) {
if (element.nodeType == ELEMENT_NODE) {
var elementStyles = $window.getComputedStyle(element) || {};
transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY], transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration), 
transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY], transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY], 
transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay), 
animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY], animationDelay = Math.max(parseMaxTime(animationDelayStyle), animationDelay);
var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
aDuration > 0 && (aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1), 
animationDuration = Math.max(aDuration, animationDuration);
}
}), data = {
total:0,
transitionPropertyStyle:transitionPropertyStyle,
transitionDurationStyle:transitionDurationStyle,
transitionDelayStyle:transitionDelayStyle,
transitionDelay:transitionDelay,
transitionDuration:transitionDuration,
animationDelayStyle:animationDelayStyle,
animationDelay:animationDelay,
animationDuration:animationDuration
}, cacheKey && (lookupCache[cacheKey] = data);
}
return data;
}
function parseMaxTime(str) {
var maxValue = 0, values = angular.isString(str) ? str.split(/\s*,\s*/) :[];
return forEach(values, function(value) {
maxValue = Math.max(parseFloat(value) || 0, maxValue);
}), maxValue;
}
function getCacheKey(element) {
var parentElement = element.parent(), parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
return parentID || (parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter), 
parentID = parentCounter), parentID + "-" + extractElementNode(element).getAttribute("class");
}
function animateSetup(animationEvent, element, className, calculationDecorator) {
var cacheKey = getCacheKey(element), eventCacheKey = cacheKey + " " + className, itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total :0, stagger = {};
if (itemIndex > 0) {
var staggerClassName = className + "-stagger", staggerCacheKey = cacheKey + " " + staggerClassName, applyClasses = !lookupCache[staggerCacheKey];
applyClasses && element.addClass(staggerClassName), stagger = getElementAnimationDetails(element, staggerCacheKey), 
applyClasses && element.removeClass(staggerClassName);
}
calculationDecorator = calculationDecorator || function(fn) {
return fn();
}, element.addClass(className);
var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {}, timings = calculationDecorator(function() {
return getElementAnimationDetails(element, eventCacheKey);
}), transitionDuration = timings.transitionDuration, animationDuration = timings.animationDuration;
if (0 === transitionDuration && 0 === animationDuration) return element.removeClass(className), 
!1;
element.data(NG_ANIMATE_CSS_DATA_KEY, {
running:formerData.running || 0,
itemIndex:itemIndex,
stagger:stagger,
timings:timings,
closeAnimationFn:noop
});
var isCurrentlyAnimating = formerData.running > 0 || "setClass" == animationEvent;
return transitionDuration > 0 && blockTransitions(element, className, isCurrentlyAnimating), 
animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration && blockKeyframeAnimations(element), 
!0;
}
function isStructuralAnimation(className) {
return "ng-enter" == className || "ng-move" == className || "ng-leave" == className;
}
function blockTransitions(element, className, isAnimating) {
isStructuralAnimation(className) || !isAnimating ? extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = "none" :element.addClass(NG_ANIMATE_BLOCK_CLASS_NAME);
}
function blockKeyframeAnimations(element) {
extractElementNode(element).style[ANIMATION_PROP] = "none 0s";
}
function unblockTransitions(element) {
var prop = TRANSITION_PROP + PROPERTY_KEY, node = extractElementNode(element);
node.style[prop] && node.style[prop].length > 0 && (node.style[prop] = ""), element.removeClass(NG_ANIMATE_BLOCK_CLASS_NAME);
}
function unblockKeyframeAnimations(element) {
var prop = ANIMATION_PROP, node = extractElementNode(element);
node.style[prop] && node.style[prop].length > 0 && (node.style[prop] = "");
}
function animateRun(animationEvent, element, className, activeAnimationComplete) {
function onEnd() {
element.off(css3AnimationEvents, onAnimationProgress), element.removeClass(activeClassName), 
animateClose(element, className);
var node = extractElementNode(element);
for (var i in appliedStyles) node.style.removeProperty(appliedStyles[i]);
}
function onAnimationProgress(event) {
event.stopPropagation();
var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && activeAnimationComplete();
}
var node = extractElementNode(element), elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
if (-1 == node.getAttribute("class").indexOf(className) || !elementData) return activeAnimationComplete(), 
void 0;
var activeClassName = "";
forEach(className.split(" "), function(klass, i) {
activeClassName += (i > 0 ? " " :"") + klass + "-active";
});
var stagger = elementData.stagger, timings = elementData.timings, itemIndex = elementData.itemIndex, maxDuration = Math.max(timings.transitionDuration, timings.animationDuration), maxDelay = Math.max(timings.transitionDelay, timings.animationDelay), maxDelayTime = maxDelay * ONE_SECOND, startTime = Date.now(), css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT, style = "", appliedStyles = [];
if (timings.transitionDuration > 0) {
var propertyStyle = timings.transitionPropertyStyle;
-1 == propertyStyle.indexOf("all") && (style += CSS_PREFIX + "transition-property: " + propertyStyle + ";", 
style += CSS_PREFIX + "transition-duration: " + timings.transitionDurationStyle + ";", 
appliedStyles.push(CSS_PREFIX + "transition-property"), appliedStyles.push(CSS_PREFIX + "transition-duration"));
}
if (itemIndex > 0) {
if (stagger.transitionDelay > 0 && 0 === stagger.transitionDuration) {
var delayStyle = timings.transitionDelayStyle;
style += CSS_PREFIX + "transition-delay: " + prepareStaggerDelay(delayStyle, stagger.transitionDelay, itemIndex) + "; ", 
appliedStyles.push(CSS_PREFIX + "transition-delay");
}
stagger.animationDelay > 0 && 0 === stagger.animationDuration && (style += CSS_PREFIX + "animation-delay: " + prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, itemIndex) + "; ", 
appliedStyles.push(CSS_PREFIX + "animation-delay"));
}
if (appliedStyles.length > 0) {
var oldStyle = node.getAttribute("style") || "";
node.setAttribute("style", oldStyle + "; " + style);
}
element.on(css3AnimationEvents, onAnimationProgress), element.addClass(activeClassName), 
elementData.closeAnimationFn = function() {
onEnd(), activeAnimationComplete();
};
var staggerTime = itemIndex * (Math.max(stagger.animationDelay, stagger.transitionDelay) || 0), animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER, totalTime = (staggerTime + animationTime) * ONE_SECOND;
return elementData.running++, animationCloseHandler(element, totalTime), onEnd;
}
function prepareStaggerDelay(delayStyle, staggerDelay, index) {
var style = "";
return forEach(delayStyle.split(","), function(val, i) {
style += (i > 0 ? "," :"") + (index * staggerDelay + parseInt(val, 10)) + "s";
}), style;
}
function animateBefore(animationEvent, element, className, calculationDecorator) {
return animateSetup(animationEvent, element, className, calculationDecorator) ? function(cancelled) {
cancelled && animateClose(element, className);
} :void 0;
}
function animateAfter(animationEvent, element, className, afterAnimationComplete) {
return element.data(NG_ANIMATE_CSS_DATA_KEY) ? animateRun(animationEvent, element, className, afterAnimationComplete) :(animateClose(element, className), 
afterAnimationComplete(), void 0);
}
function animate(animationEvent, element, className, animationComplete) {
var preReflowCancellation = animateBefore(animationEvent, element, className);
if (!preReflowCancellation) return clearCacheAfterReflow(), animationComplete(), 
void 0;
var cancel = preReflowCancellation;
return afterReflow(element, function() {
unblockTransitions(element, className), unblockKeyframeAnimations(element), cancel = animateAfter(animationEvent, element, className, animationComplete);
}), function(cancelled) {
(cancel || noop)(cancelled);
};
}
function animateClose(element, className) {
element.removeClass(className);
var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
data && (data.running && data.running--, data.running && 0 !== data.running || element.removeData(NG_ANIMATE_CSS_DATA_KEY));
}
function suffixClasses(classes, suffix) {
var className = "";
return classes = angular.isArray(classes) ? classes :classes.split(/\s+/), forEach(classes, function(klass, i) {
klass && klass.length > 0 && (className += (i > 0 ? " " :"") + klass + suffix);
}), className;
}
var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, CSS_PREFIX = "";
window.ontransitionend === undefined && window.onwebkittransitionend !== undefined ? (CSS_PREFIX = "-webkit-", 
TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") :(TRANSITION_PROP = "transition", 
TRANSITIONEND_EVENT = "transitionend"), window.onanimationend === undefined && window.onwebkitanimationend !== undefined ? (CSS_PREFIX = "-webkit-", 
ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") :(ANIMATION_PROP = "animation", 
ANIMATIONEND_EVENT = "animationend");
var cancelAnimationReflow, DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey", NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data", NG_ANIMATE_BLOCK_CLASS_NAME = "ng-animate-block-transitions", ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, ONE_SECOND = 1e3, lookupCache = {}, parentCounter = 0, animationReflowQueue = [], closingTimer = null, closingTimestamp = 0, animationElementQueue = [];
return {
enter:function(element, animationCompleted) {
return animate("enter", element, "ng-enter", animationCompleted);
},
leave:function(element, animationCompleted) {
return animate("leave", element, "ng-leave", animationCompleted);
},
move:function(element, animationCompleted) {
return animate("move", element, "ng-move", animationCompleted);
},
beforeSetClass:function(element, add, remove, animationCompleted) {
var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add"), cancellationMethod = animateBefore("setClass", element, className, function(fn) {
var klass = element.attr("class");
element.removeClass(remove), element.addClass(add);
var timings = fn();
return element.attr("class", klass), timings;
});
return cancellationMethod ? (afterReflow(element, function() {
unblockTransitions(element, className), unblockKeyframeAnimations(element), animationCompleted();
}), cancellationMethod) :(clearCacheAfterReflow(), animationCompleted(), void 0);
},
beforeAddClass:function(element, className, animationCompleted) {
var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), function(fn) {
element.addClass(className);
var timings = fn();
return element.removeClass(className), timings;
});
return cancellationMethod ? (afterReflow(element, function() {
unblockTransitions(element, className), unblockKeyframeAnimations(element), animationCompleted();
}), cancellationMethod) :(clearCacheAfterReflow(), animationCompleted(), void 0);
},
setClass:function(element, add, remove, animationCompleted) {
remove = suffixClasses(remove, "-remove"), add = suffixClasses(add, "-add");
var className = remove + " " + add;
return animateAfter("setClass", element, className, animationCompleted);
},
addClass:function(element, className, animationCompleted) {
return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted);
},
beforeRemoveClass:function(element, className, animationCompleted) {
var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), function(fn) {
var klass = element.attr("class");
element.removeClass(className);
var timings = fn();
return element.attr("class", klass), timings;
});
return cancellationMethod ? (afterReflow(element, function() {
unblockTransitions(element, className), unblockKeyframeAnimations(element), animationCompleted();
}), cancellationMethod) :(animationCompleted(), void 0);
},
removeClass:function(element, className, animationCompleted) {
return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted);
}
};
} ]);
} ]);
}(window, window.angular), function() {
var $D = Date, lang = Date.CultureStrings ? Date.CultureStrings.lang :null, loggedKeys = {}, getText = {
getFromKey:function(key, countryCode) {
var output;
return output = Date.CultureStrings && Date.CultureStrings[countryCode] && Date.CultureStrings[countryCode][key] ? Date.CultureStrings[countryCode][key] :getText.buildFromDefault(key), 
"/" === key.charAt(0) && (output = getText.buildFromRegex(key, countryCode)), output;
},
getFromObjectValues:function(obj, countryCode) {
var key, output = {};
for (key in obj) obj.hasOwnProperty(key) && (output[key] = getText.getFromKey(obj[key], countryCode));
return output;
},
getFromObjectKeys:function(obj, countryCode) {
var key, output = {};
for (key in obj) obj.hasOwnProperty(key) && (output[getText.getFromKey(key, countryCode)] = obj[key]);
return output;
},
getFromArray:function(arr, countryCode) {
for (var output = [], i = 0; i < arr.length; i++) i in arr && (output[i] = getText.getFromKey(arr[i], countryCode));
return output;
},
buildFromDefault:function(key) {
var output, length, split, last;
switch (key) {
case "name":
output = "en-US";
break;

case "englishName":
output = "English (United States)";
break;

case "nativeName":
output = "English (United States)";
break;

case "twoDigitYearMax":
output = 2049;
break;

case "firstDayOfWeek":
output = 0;
break;

default:
output = key, split = key.split("_"), length = split.length, length > 1 && "/" !== key.charAt(0) && (last = split[length - 1].toLowerCase(), 
("initial" === last || "abbr" === last) && (output = split[0]));
}
return output;
},
buildFromRegex:function(key, countryCode) {
var output;
return output = Date.CultureStrings && Date.CultureStrings[countryCode] && Date.CultureStrings[countryCode][key] ? new RegExp(Date.CultureStrings[countryCode][key], "i") :new RegExp(key.replace(new RegExp("/", "g"), ""), "i");
}
}, shallowMerge = function(obj1, obj2) {
for (var attrname in obj2) obj2.hasOwnProperty(attrname) && (obj1[attrname] = obj2[attrname]);
}, __ = function(key, language) {
var countryCode = language ? language :lang;
return loggedKeys[key] = key, "object" == typeof key ? key instanceof Array ? getText.getFromArray(key, countryCode) :getText.getFromObjectKeys(key, countryCode) :getText.getFromKey(key, countryCode);
}, loadI18nScript = function(code) {
var url = Date.Config.i18n + code + ".js", head = document.getElementsByTagName("head")[0] || document.documentElement, script = document.createElement("script");
script.src = url;
var completed = !1, events = {
done:function() {}
};
return script.onload = script.onreadystatechange = function() {
completed || this.readyState && "loaded" !== this.readyState && "complete" !== this.readyState || (events.done(), 
head.removeChild(script));
}, setTimeout(function() {
head.insertBefore(script, head.firstChild);
}, 0), {
done:function(cb) {
events.done = function() {
cb && setTimeout(cb, 0);
};
}
};
}, buildInfo = {
buildFromMethodHash:function(obj) {
var key;
for (key in obj) obj.hasOwnProperty(key) && (obj[key] = buildInfo[obj[key]]());
return obj;
},
timeZoneDST:function() {
var DST = {
CHADT:"+1345",
NZDT:"+1300",
AEDT:"+1100",
ACDT:"+1030",
AZST:"+0500",
IRDT:"+0430",
EEST:"+0300",
CEST:"+0200",
BST:"+0100",
PMDT:"-0200",
ADT:"-0300",
NDT:"-0230",
EDT:"-0400",
CDT:"-0500",
MDT:"-0600",
PDT:"-0700",
AKDT:"-0800",
HADT:"-0900"
};
return __(DST);
},
timeZoneStandard:function() {
var standard = {
LINT:"+1400",
TOT:"+1300",
CHAST:"+1245",
NZST:"+1200",
NFT:"+1130",
SBT:"+1100",
AEST:"+1000",
ACST:"+0930",
JST:"+0900",
CWST:"+0845",
CT:"+0800",
ICT:"+0700",
MMT:"+0630",
BST:"+0600",
NPT:"+0545",
IST:"+0530",
PKT:"+0500",
AFT:"+0430",
MSK:"+0400",
IRST:"+0330",
FET:"+0300",
EET:"+0200",
CET:"+0100",
GMT:"+0000",
UTC:"+0000",
CVT:"-0100",
GST:"-0200",
BRT:"-0300",
NST:"-0330",
AST:"-0400",
EST:"-0500",
CST:"-0600",
MST:"-0700",
PST:"-0800",
AKST:"-0900",
MIT:"-0930",
HST:"-1000",
SST:"-1100",
BIT:"-1200"
};
return __(standard);
},
timeZones:function(data) {
var zone;
data.timezones = [];
for (zone in data.abbreviatedTimeZoneStandard) data.abbreviatedTimeZoneStandard.hasOwnProperty(zone) && data.timezones.push({
name:zone,
offset:data.abbreviatedTimeZoneStandard[zone]
});
for (zone in data.abbreviatedTimeZoneDST) data.abbreviatedTimeZoneDST.hasOwnProperty(zone) && data.timezones.push({
name:zone,
offset:data.abbreviatedTimeZoneDST[zone],
dst:!0
});
return data.timezones;
},
days:function() {
return __([ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ]);
},
dayAbbr:function() {
return __([ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ]);
},
dayShortNames:function() {
return __([ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]);
},
dayFirstLetters:function() {
return __([ "S_Sun_Initial", "M_Mon_Initial", "T_Tues_Initial", "W_Wed_Initial", "T_Thu_Initial", "F_Fri_Initial", "S_Sat_Initial" ]);
},
months:function() {
return __([ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ]);
},
monthAbbr:function() {
return __([ "Jan_Abbr", "Feb_Abbr", "Mar_Abbr", "Apr_Abbr", "May_Abbr", "Jun_Abbr", "Jul_Abbr", "Aug_Abbr", "Sep_Abbr", "Oct_Abbr", "Nov_Abbr", "Dec_Abbr" ]);
},
formatPatterns:function() {
return getText.getFromObjectValues({
shortDate:"M/d/yyyy",
longDate:"dddd, MMMM dd, yyyy",
shortTime:"h:mm tt",
longTime:"h:mm:ss tt",
fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",
sortableDateTime:"yyyy-MM-ddTHH:mm:ss",
universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",
rfc1123:"ddd, dd MMM yyyy HH:mm:ss",
monthDay:"MMMM dd",
yearMonth:"MMMM, yyyy"
}, Date.i18n.currentLanguage());
},
regex:function() {
return getText.getFromObjectValues({
inTheMorning:"/( in the )(morn(ing)?)\\b/",
thisMorning:"/(this )(morn(ing)?)\\b/",
amThisMorning:"/(\b\\d(am)? )(this )(morn(ing)?)/",
inTheEvening:"/( in the )(even(ing)?)\\b/",
thisEvening:"/(this )(even(ing)?)\\b/",
pmThisEvening:"/(\b\\d(pm)? )(this )(even(ing)?)/",
jan:"/jan(uary)?/",
feb:"/feb(ruary)?/",
mar:"/mar(ch)?/",
apr:"/apr(il)?/",
may:"/may/",
jun:"/jun(e)?/",
jul:"/jul(y)?/",
aug:"/aug(ust)?/",
sep:"/sep(t(ember)?)?/",
oct:"/oct(ober)?/",
nov:"/nov(ember)?/",
dec:"/dec(ember)?/",
sun:"/^su(n(day)?)?/",
mon:"/^mo(n(day)?)?/",
tue:"/^tu(e(s(day)?)?)?/",
wed:"/^we(d(nesday)?)?/",
thu:"/^th(u(r(s(day)?)?)?)?/",
fri:"/fr(i(day)?)?/",
sat:"/^sa(t(urday)?)?/",
future:"/^next/",
past:"/^last|past|prev(ious)?/",
add:"/^(\\+|aft(er)?|from|hence)/",
subtract:"/^(\\-|bef(ore)?|ago)/",
yesterday:"/^yes(terday)?/",
today:"/^t(od(ay)?)?/",
tomorrow:"/^tom(orrow)?/",
now:"/^n(ow)?/",
millisecond:"/^ms|milli(second)?s?/",
second:"/^sec(ond)?s?/",
minute:"/^mn|min(ute)?s?/",
hour:"/^h(our)?s?/",
week:"/^w(eek)?s?/",
month:"/^m(onth)?s?/",
day:"/^d(ay)?s?/",
year:"/^y(ear)?s?/",
shortMeridian:"/^(a|p)/",
longMeridian:"/^(a\\.?m?\\.?|p\\.?m?\\.?)/",
timezone:"/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\\s*(\\+|\\-)\\s*\\d\\d\\d\\d?)|gmt|utc)/",
ordinalSuffix:"/^\\s*(st|nd|rd|th)/",
timeContext:"/^\\s*(\\:|a(?!u|p)|p)/"
}, Date.i18n.currentLanguage());
}
}, CultureInfo = function() {
var info = getText.getFromObjectValues({
name:"name",
englishName:"englishName",
nativeName:"nativeName",
amDesignator:"AM",
pmDesignator:"PM",
firstDayOfWeek:"firstDayOfWeek",
twoDigitYearMax:"twoDigitYearMax",
dateElementOrder:"mdy"
}, Date.i18n.currentLanguage()), constructedInfo = buildInfo.buildFromMethodHash({
dayNames:"days",
abbreviatedDayNames:"dayAbbr",
shortestDayNames:"dayShortNames",
firstLetterDayNames:"dayFirstLetters",
monthNames:"months",
abbreviatedMonthNames:"monthAbbr",
formatPatterns:"formatPatterns",
regexPatterns:"regex",
abbreviatedTimeZoneDST:"timeZoneDST",
abbreviatedTimeZoneStandard:"timeZoneStandard"
});
return shallowMerge(info, constructedInfo), buildInfo.timeZones(info), info;
};
$D.i18n = {
__:function(key, lang) {
return __(key, lang);
},
currentLanguage:function() {
return lang || "en-US";
},
setLanguage:function(code, force, cb) {
var async = !1;
if (force || "en-US" === code || Date.CultureStrings && Date.CultureStrings[code]) lang = code, 
Date.CultureStrings = Date.CultureStrings || {}, Date.CultureStrings.lang = code, 
Date.CultureInfo = new CultureInfo(); else if (!Date.CultureStrings || !Date.CultureStrings[code]) if ("undefined" != typeof exports && this.exports !== exports) try {
require("../i18n/" + code + ".js"), lang = code, Date.CultureStrings.lang = code, 
Date.CultureInfo = new CultureInfo();
} catch (e) {
throw new Error("The DateJS IETF language tag '" + code + "' could not be loaded by Node. It likely does not exist.");
} else {
if (!Date.Config || !Date.Config.i18n) return Date.console.error("The DateJS IETF language tag '" + code + "' is not available and has not been loaded."), 
!1;
async = !0, loadI18nScript(code).done(function() {
lang = code, Date.CultureStrings = Date.CultureStrings || {}, Date.CultureStrings.lang = code, 
Date.CultureInfo = new CultureInfo(), $D.Parsing.Normalizer.buildReplaceData(), 
$D.Grammar && $D.Grammar.buildGrammarFormats(), cb && setTimeout(cb, 0);
});
}
$D.Parsing.Normalizer.buildReplaceData(), $D.Grammar && $D.Grammar.buildGrammarFormats(), 
!async && cb && setTimeout(cb, 0);
},
getLoggedKeys:function() {
return loggedKeys;
},
updateCultureInfo:function() {
Date.CultureInfo = new CultureInfo();
}
}, $D.i18n.updateCultureInfo();
}(), function() {
var $D = Date, $P = $D.prototype, p = function(s, l) {
return l || (l = 2), ("000" + s).slice(-1 * l);
};
$D.console = "undefined" != typeof window && "undefined" != typeof window.console && "undefined" != typeof window.console.log ? console :{
log:function() {},
error:function() {}
}, $D.Config = $D.Config || {}, $D.initOverloads = function() {
$D.now ? $D._now || ($D._now = $D.now) :$D._now = function() {
return new Date().getTime();
}, $D.now = function(returnObj) {
return returnObj ? $D.present() :$D._now();
}, $P.toISOString || ($P.toISOString = function() {
return this.getUTCFullYear() + "-" + p(this.getUTCMonth() + 1) + "-" + p(this.getUTCDate()) + "T" + p(this.getUTCHours()) + ":" + p(this.getUTCMinutes()) + ":" + p(this.getUTCSeconds()) + "." + String((this.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + "Z";
}), void 0 === $P._toString && ($P._toString = $P.toString);
}, $D.initOverloads(), $D.today = function() {
return new Date().clearTime();
}, $D.present = function() {
return new Date();
}, $D.compare = function(date1, date2) {
if (isNaN(date1) || isNaN(date2)) throw new Error(date1 + " - " + date2);
if (date1 instanceof Date && date2 instanceof Date) return date2 > date1 ? -1 :date1 > date2 ? 1 :0;
throw new TypeError(date1 + " - " + date2);
}, $D.equals = function(date1, date2) {
return 0 === date1.compareTo(date2);
}, $D.getDayName = function(n) {
return Date.CultureInfo.dayNames[n];
}, $D.getDayNumberFromName = function(name) {
for (var n = Date.CultureInfo.dayNames, m = Date.CultureInfo.abbreviatedDayNames, o = Date.CultureInfo.shortestDayNames, s = name.toLowerCase(), i = 0; i < n.length; i++) if (n[i].toLowerCase() === s || m[i].toLowerCase() === s || o[i].toLowerCase() === s) return i;
return -1;
}, $D.getMonthNumberFromName = function(name) {
for (var n = Date.CultureInfo.monthNames, m = Date.CultureInfo.abbreviatedMonthNames, s = name.toLowerCase(), i = 0; i < n.length; i++) if (n[i].toLowerCase() === s || m[i].toLowerCase() === s) return i;
return -1;
}, $D.getMonthName = function(n) {
return Date.CultureInfo.monthNames[n];
}, $D.isLeapYear = function(year) {
return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}, $D.getDaysInMonth = function(year, month) {
return !month && $D.validateMonth(year) && (month = year, year = Date.today().getFullYear()), 
[ 31, $D.isLeapYear(year) ? 29 :28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ][month];
}, $P.getDaysInMonth = function() {
return $D.getDaysInMonth(this.getFullYear(), this.getMonth());
}, $D.getTimezoneAbbreviation = function(offset, dst) {
var p, n = dst ? Date.CultureInfo.abbreviatedTimeZoneDST :Date.CultureInfo.abbreviatedTimeZoneStandard;
for (p in n) if (n.hasOwnProperty(p) && n[p] === offset) return p;
return null;
}, $D.getTimezoneOffset = function(name, dst) {
var i, a = [], z = Date.CultureInfo.timezones;
for (name || (name = new Date().getTimezone()), i = 0; i < z.length; i++) z[i].name === name.toUpperCase() && a.push(i);
if (!z[a[0]]) return null;
if (1 === a.length || !dst) return z[a[0]].offset;
for (i = 0; i < a.length; i++) if (z[a[i]].dst) return z[a[i]].offset;
}, $D.getQuarter = function(d) {
d = d || new Date();
var q = [ 1, 2, 3, 4 ];
return q[Math.floor(d.getMonth() / 3)];
}, $D.getDaysLeftInQuarter = function(d) {
d = d || new Date();
var qEnd = new Date(d);
return qEnd.setMonth(qEnd.getMonth() + 3 - qEnd.getMonth() % 3, 0), Math.floor((qEnd - d) / 864e5);
};
var validate = function(n, min, max, name) {
if (name = name ? name :"Object", "undefined" == typeof n) return !1;
if ("number" != typeof n) throw new TypeError(n + " is not a Number.");
return min > n || n > max ? !1 :!0;
};
$D.validateMillisecond = function(value) {
return validate(value, 0, 999, "millisecond");
}, $D.validateSecond = function(value) {
return validate(value, 0, 59, "second");
}, $D.validateMinute = function(value) {
return validate(value, 0, 59, "minute");
}, $D.validateHour = function(value) {
return validate(value, 0, 23, "hour");
}, $D.validateDay = function(value, year, month) {
return void 0 === year || null === year || void 0 === month || null === month ? !1 :validate(value, 1, $D.getDaysInMonth(year, month), "day");
}, $D.validateWeek = function(value) {
return validate(value, 0, 53, "week");
}, $D.validateMonth = function(value) {
return validate(value, 0, 11, "month");
}, $D.validateYear = function(value) {
return validate(value, -271822, 275760, "year");
}, $D.validateTimezone = function(value) {
var timezones = {
ACDT:1,
ACST:1,
ACT:1,
ADT:1,
AEDT:1,
AEST:1,
AFT:1,
AKDT:1,
AKST:1,
AMST:1,
AMT:1,
ART:1,
AST:1,
AWDT:1,
AWST:1,
AZOST:1,
AZT:1,
BDT:1,
BIOT:1,
BIT:1,
BOT:1,
BRT:1,
BST:1,
BTT:1,
CAT:1,
CCT:1,
CDT:1,
CEDT:1,
CEST:1,
CET:1,
CHADT:1,
CHAST:1,
CHOT:1,
ChST:1,
CHUT:1,
CIST:1,
CIT:1,
CKT:1,
CLST:1,
CLT:1,
COST:1,
COT:1,
CST:1,
CT:1,
CVT:1,
CWST:1,
CXT:1,
DAVT:1,
DDUT:1,
DFT:1,
EASST:1,
EAST:1,
EAT:1,
ECT:1,
EDT:1,
EEDT:1,
EEST:1,
EET:1,
EGST:1,
EGT:1,
EIT:1,
EST:1,
FET:1,
FJT:1,
FKST:1,
FKT:1,
FNT:1,
GALT:1,
GAMT:1,
GET:1,
GFT:1,
GILT:1,
GIT:1,
GMT:1,
GST:1,
GYT:1,
HADT:1,
HAEC:1,
HAST:1,
HKT:1,
HMT:1,
HOVT:1,
HST:1,
ICT:1,
IDT:1,
IOT:1,
IRDT:1,
IRKT:1,
IRST:1,
IST:1,
JST:1,
KGT:1,
KOST:1,
KRAT:1,
KST:1,
LHST:1,
LINT:1,
MAGT:1,
MART:1,
MAWT:1,
MDT:1,
MET:1,
MEST:1,
MHT:1,
MIST:1,
MIT:1,
MMT:1,
MSK:1,
MST:1,
MUT:1,
MVT:1,
MYT:1,
NCT:1,
NDT:1,
NFT:1,
NPT:1,
NST:1,
NT:1,
NUT:1,
NZDT:1,
NZST:1,
OMST:1,
ORAT:1,
PDT:1,
PET:1,
PETT:1,
PGT:1,
PHOT:1,
PHT:1,
PKT:1,
PMDT:1,
PMST:1,
PONT:1,
PST:1,
PYST:1,
PYT:1,
RET:1,
ROTT:1,
SAKT:1,
SAMT:1,
SAST:1,
SBT:1,
SCT:1,
SGT:1,
SLST:1,
SRT:1,
SST:1,
SYOT:1,
TAHT:1,
THA:1,
TFT:1,
TJT:1,
TKT:1,
TLT:1,
TMT:1,
TOT:1,
TVT:1,
UCT:1,
ULAT:1,
UTC:1,
UYST:1,
UYT:1,
UZT:1,
VET:1,
VLAT:1,
VOLT:1,
VOST:1,
VUT:1,
WAKT:1,
WAST:1,
WAT:1,
WEDT:1,
WEST:1,
WET:1,
WST:1,
YAKT:1,
YEKT:1,
Z:1
};
return 1 === timezones[value];
}, $D.validateTimezoneOffset = function(value) {
return value > -841 && 721 > value;
};
}(), function() {
var $D = Date, $P = $D.prototype, p = function(s, l) {
return l || (l = 2), ("000" + s).slice(-1 * l);
}, validateConfigObject = function(obj) {
var prop, testFunc, result = {}, self = this;
testFunc = function(prop, func, value) {
if ("day" === prop) {
var month = void 0 !== obj.month ? obj.month :self.getMonth(), year = void 0 !== obj.year ? obj.year :self.getFullYear();
return $D[func](value, year, month);
}
return $D[func](value);
};
for (prop in obj) if (hasOwnProperty.call(obj, prop)) {
var func = "validate" + prop.charAt(0).toUpperCase() + prop.slice(1);
$D[func] && null !== obj[prop] && testFunc(prop, func, obj[prop]) && (result[prop] = obj[prop]);
}
return result;
};
$P.clearTime = function() {
return this.setHours(0), this.setMinutes(0), this.setSeconds(0), this.setMilliseconds(0), 
this;
}, $P.setTimeToNow = function() {
var n = new Date();
return this.setHours(n.getHours()), this.setMinutes(n.getMinutes()), this.setSeconds(n.getSeconds()), 
this.setMilliseconds(n.getMilliseconds()), this;
}, $P.clone = function() {
return new Date(this.getTime());
}, $P.compareTo = function(date) {
return Date.compare(this, date);
}, $P.equals = function(date) {
return Date.equals(this, void 0 !== date ? date :new Date());
}, $P.between = function(start, end) {
return this.getTime() >= start.getTime() && this.getTime() <= end.getTime();
}, $P.isAfter = function(date) {
return 1 === this.compareTo(date || new Date());
}, $P.isBefore = function(date) {
return -1 === this.compareTo(date || new Date());
}, $P.isToday = $P.isSameDay = function(date) {
return this.clone().clearTime().equals((date || new Date()).clone().clearTime());
}, $P.addMilliseconds = function(value) {
return value ? (this.setTime(this.getTime() + 1 * value), this) :this;
}, $P.addSeconds = function(value) {
return value ? this.addMilliseconds(1e3 * value) :this;
}, $P.addMinutes = function(value) {
return value ? this.addMilliseconds(6e4 * value) :this;
}, $P.addHours = function(value) {
return value ? this.addMilliseconds(36e5 * value) :this;
}, $P.addDays = function(value) {
return value ? (this.setDate(this.getDate() + 1 * value), this) :this;
}, $P.addWeekdays = function(value) {
if (!value) return this;
var day = this.getDay(), weeks = Math.ceil(Math.abs(value) / 7);
if ((0 === day || 6 === day) && value > 0 && (this.next().monday(), this.addDays(-1), 
day = this.getDay()), 0 > value) {
for (;0 > value; ) this.addDays(-1), day = this.getDay(), 0 !== day && 6 !== day && value++;
return this;
}
return (value > 5 || value >= 6 - day) && (value += 2 * weeks), this.addDays(value);
}, $P.addWeeks = function(value) {
return value ? this.addDays(7 * value) :this;
}, $P.addMonths = function(value) {
if (!value) return this;
var n = this.getDate();
return this.setDate(1), this.setMonth(this.getMonth() + 1 * value), this.setDate(Math.min(n, $D.getDaysInMonth(this.getFullYear(), this.getMonth()))), 
this;
}, $P.addQuarters = function(value) {
return value ? this.addMonths(3 * value) :this;
}, $P.addYears = function(value) {
return value ? this.addMonths(12 * value) :this;
}, $P.add = function(config) {
if ("number" == typeof config) return this._orient = config, this;
var x = config;
return x.day && x.day - this.getDate() !== 0 && this.setDate(x.day), x.milliseconds && this.addMilliseconds(x.milliseconds), 
x.seconds && this.addSeconds(x.seconds), x.minutes && this.addMinutes(x.minutes), 
x.hours && this.addHours(x.hours), x.weeks && this.addWeeks(x.weeks), x.months && this.addMonths(x.months), 
x.years && this.addYears(x.years), x.days && this.addDays(x.days), this;
}, $P.getWeek = function(utc) {
var self, target = new Date(this.valueOf());
utc ? (target.addMinutes(target.getTimezoneOffset()), self = target.clone()) :self = this;
var dayNr = (self.getDay() + 6) % 7;
target.setDate(target.getDate() - dayNr + 3);
var firstThursday = target.valueOf();
return target.setMonth(0, 1), 4 !== target.getDay() && target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7), 
1 + Math.ceil((firstThursday - target) / 6048e5);
}, $P.getISOWeek = function() {
return p(this.getWeek(!0));
}, $P.setWeek = function(n) {
return n - this.getWeek() === 0 ? 1 !== this.getDay() ? this.moveToDayOfWeek(1, this.getDay() > 1 ? -1 :1) :this :this.moveToDayOfWeek(1, this.getDay() > 1 ? -1 :1).addWeeks(n - this.getWeek());
}, $P.setQuarter = function(qtr) {
var month = Math.abs(3 * (qtr - 1) + 1);
return this.setMonth(month, 1);
}, $P.getQuarter = function() {
return Date.getQuarter(this);
}, $P.getDaysLeftInQuarter = function() {
return Date.getDaysLeftInQuarter(this);
}, $P.moveToNthOccurrence = function(dayOfWeek, occurrence) {
if ("Weekday" === dayOfWeek) {
if (occurrence > 0) this.moveToFirstDayOfMonth(), this.is().weekday() && (occurrence -= 1); else {
if (!(0 > occurrence)) return this;
this.moveToLastDayOfMonth(), this.is().weekday() && (occurrence += 1);
}
return this.addWeekdays(occurrence);
}
var shift = 0;
if (occurrence > 0) shift = occurrence - 1; else if (-1 === occurrence) return this.moveToLastDayOfMonth(), 
this.getDay() !== dayOfWeek && this.moveToDayOfWeek(dayOfWeek, -1), this;
return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek, 1).addWeeks(shift);
};
var moveToN = function(getFunc, addFunc, nVal) {
return function(value, orient) {
var diff = (value - this[getFunc]() + nVal * (orient || 1)) % nVal;
return this[addFunc](0 === diff ? diff += nVal * (orient || 1) :diff);
};
};
$P.moveToDayOfWeek = moveToN("getDay", "addDays", 7), $P.moveToMonth = moveToN("getMonth", "addMonths", 12), 
$P.getOrdinate = function() {
var num = this.getDate();
return ord(num);
}, $P.getOrdinalNumber = function() {
return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 864e5) + 1;
}, $P.getTimezone = function() {
return $D.getTimezoneAbbreviation(this.getUTCOffset(), this.isDaylightSavingTime());
}, $P.setTimezoneOffset = function(offset) {
var here = this.getTimezoneOffset(), there = -6 * Number(offset) / 10;
return there || 0 === there ? this.addMinutes(there - here) :this;
}, $P.setTimezone = function(offset) {
return this.setTimezoneOffset($D.getTimezoneOffset(offset));
}, $P.hasDaylightSavingTime = function() {
return Date.today().set({
month:0,
day:1
}).getTimezoneOffset() !== Date.today().set({
month:6,
day:1
}).getTimezoneOffset();
}, $P.isDaylightSavingTime = function() {
return Date.today().set({
month:0,
day:1
}).getTimezoneOffset() !== this.getTimezoneOffset();
}, $P.getUTCOffset = function(offset) {
var r, n = -10 * (offset || this.getTimezoneOffset()) / 6;
return 0 > n ? (r = (n - 1e4).toString(), r.charAt(0) + r.substr(2)) :(r = (n + 1e4).toString(), 
"+" + r.substr(1));
}, $P.getElapsed = function(date) {
return (date || new Date()) - this;
}, $P.set = function(config) {
config = validateConfigObject.call(this, config);
var key;
for (key in config) if (hasOwnProperty.call(config, key)) {
var addFunc, getFunc, name = key.charAt(0).toUpperCase() + key.slice(1);
"week" !== key && "month" !== key && "timezone" !== key && "timezoneOffset" !== key && (name += "s"), 
addFunc = "add" + name, getFunc = "get" + name, "month" === key ? addFunc += "s" :"year" === key && (getFunc = "getFullYear"), 
"day" !== key && "timezone" !== key && "timezoneOffset" !== key && "week" !== key && "hour" !== key ? this[addFunc](config[key] - this[getFunc]()) :("timezone" === key || "timezoneOffset" === key || "week" === key || "hour" === key) && this["set" + name](config[key]);
}
return config.day && this.addDays(config.day - this.getDate()), this;
}, $P.moveToFirstDayOfMonth = function() {
return this.set({
day:1
});
}, $P.moveToLastDayOfMonth = function() {
return this.set({
day:$D.getDaysInMonth(this.getFullYear(), this.getMonth())
});
};
var ord = function(n) {
switch (1 * n) {
case 1:
case 21:
case 31:
return "st";

case 2:
case 22:
return "nd";

case 3:
case 23:
return "rd";

default:
return "th";
}
}, parseStandardFormats = function(format) {
var y, c = Date.CultureInfo.formatPatterns;
switch (format) {
case "d":
return this.toString(c.shortDate);

case "D":
return this.toString(c.longDate);

case "F":
return this.toString(c.fullDateTime);

case "m":
return this.toString(c.monthDay);

case "r":
case "R":
return y = this.clone().addMinutes(this.getTimezoneOffset()), y.toString(c.rfc1123) + " GMT";

case "s":
return this.toString(c.sortableDateTime);

case "t":
return this.toString(c.shortTime);

case "T":
return this.toString(c.longTime);

case "u":
return y = this.clone().addMinutes(this.getTimezoneOffset()), y.toString(c.universalSortableDateTime);

case "y":
return this.toString(c.yearMonth);

default:
return !1;
}
}, parseFormatStringsClosure = function(context) {
return function(m) {
if ("\\" === m.charAt(0)) return m.replace("\\", "");
switch (m) {
case "hh":
return p(context.getHours() < 13 ? 0 === context.getHours() ? 12 :context.getHours() :context.getHours() - 12);

case "h":
return context.getHours() < 13 ? 0 === context.getHours() ? 12 :context.getHours() :context.getHours() - 12;

case "HH":
return p(context.getHours());

case "H":
return context.getHours();

case "mm":
return p(context.getMinutes());

case "m":
return context.getMinutes();

case "ss":
return p(context.getSeconds());

case "s":
return context.getSeconds();

case "yyyy":
return p(context.getFullYear(), 4);

case "yy":
return p(context.getFullYear());

case "y":
return context.getFullYear();

case "E":
case "dddd":
return Date.CultureInfo.dayNames[context.getDay()];

case "ddd":
return Date.CultureInfo.abbreviatedDayNames[context.getDay()];

case "dd":
return p(context.getDate());

case "d":
return context.getDate();

case "MMMM":
return Date.CultureInfo.monthNames[context.getMonth()];

case "MMM":
return Date.CultureInfo.abbreviatedMonthNames[context.getMonth()];

case "MM":
return p(context.getMonth() + 1);

case "M":
return context.getMonth() + 1;

case "t":
return context.getHours() < 12 ? Date.CultureInfo.amDesignator.substring(0, 1) :Date.CultureInfo.pmDesignator.substring(0, 1);

case "tt":
return context.getHours() < 12 ? Date.CultureInfo.amDesignator :Date.CultureInfo.pmDesignator;

case "S":
return ord(context.getDate());

case "W":
return context.getWeek();

case "WW":
return context.getISOWeek();

case "Q":
return "Q" + context.getQuarter();

case "q":
return String(context.getQuarter());

case "z":
return context.getTimezone();

case "Z":
case "X":
return Date.getTimezoneOffset(context.getTimezone());

case "ZZ":
return -60 * context.getTimezoneOffset();

case "u":
return context.getDay();

case "L":
return $D.isLeapYear(context.getFullYear()) ? 1 :0;

case "B":
return "@" + (context.getUTCSeconds() + 60 * context.getUTCMinutes() + 3600 * (context.getUTCHours() + 1)) / 86.4;

default:
return m;
}
};
};
$P.toString = function(format, ignoreStandards) {
if (!ignoreStandards && format && 1 === format.length && (output = parseStandardFormats.call(this, format))) return output;
var parseFormatStrings = parseFormatStringsClosure(this);
return format ? format.replace(/((\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S|q|Q|WW?W?W?)(?![^\[]*\]))/g, parseFormatStrings).replace(/\[|\]/g, "") :this._toString();
};
}(), function() {
var $D = Date, $P = $D.prototype, $N = Number.prototype;
$P._orient = 1, $P._nth = null, $P._is = !1, $P._same = !1, $P._isSecond = !1, $N._dateElement = "days", 
$P.next = function() {
return this._move = !0, this._orient = 1, this;
}, $D.next = function() {
return $D.today().next();
}, $P.last = $P.prev = $P.previous = function() {
return this._move = !0, this._orient = -1, this;
}, $D.last = $D.prev = $D.previous = function() {
return $D.today().last();
}, $P.is = function() {
return this._is = !0, this;
}, $P.same = function() {
return this._same = !0, this._isSecond = !1, this;
}, $P.today = function() {
return this.same().day();
}, $P.weekday = function() {
return this._nth ? df("Weekday").call(this) :this._move ? this.addWeekdays(this._orient) :this._is ? (this._is = !1, 
!this.is().sat() && !this.is().sun()) :!1;
}, $P.weekend = function() {
return this._is ? (this._is = !1, this.is().sat() || this.is().sun()) :!1;
}, $P.at = function(time) {
return "string" == typeof time ? $D.parse(this.toString("d") + " " + time) :this.set(time);
}, $N.fromNow = $N.after = function(date) {
var c = {};
return c[this._dateElement] = this, (date ? date.clone() :new Date()).add(c);
}, $N.ago = $N.before = function(date) {
var c = {}, s = "s" !== this._dateElement[this._dateElement.length - 1] ? this._dateElement + "s" :this._dateElement;
return c[s] = -1 * this, (date ? date.clone() :new Date()).add(c);
};
var de, dx = "sunday monday tuesday wednesday thursday friday saturday".split(/\s/), mx = "january february march april may june july august september october november december".split(/\s/), px = "Millisecond Second Minute Hour Day Week Month Year Quarter Weekday".split(/\s/), pxf = "Milliseconds Seconds Minutes Hours Date Week Month FullYear Quarter".split(/\s/), nth = "final first second third fourth fifth".split(/\s/);
$P.toObject = function() {
for (var o = {}, i = 0; i < px.length; i++) this["get" + pxf[i]] && (o[px[i].toLowerCase()] = this["get" + pxf[i]]());
return o;
}, $D.fromObject = function(config) {
return config.week = null, Date.today().set(config);
};
var df = function(n) {
return function() {
if (this._is) return this._is = !1, this.getDay() === n;
if (this._move && (this._move = null), null !== this._nth) {
this._isSecond && this.addSeconds(-1 * this._orient), this._isSecond = !1;
var ntemp = this._nth;
this._nth = null;
var temp = this.clone().moveToLastDayOfMonth();
if (this.moveToNthOccurrence(n, ntemp), this > temp) throw new RangeError($D.getDayName(n) + " does not occur " + ntemp + " times in the month of " + $D.getMonthName(temp.getMonth()) + " " + temp.getFullYear() + ".");
return this;
}
return this.moveToDayOfWeek(n, this._orient);
};
}, sdf = function(n) {
return function() {
var t = $D.today(), shift = n - t.getDay();
return 0 === n && 1 === Date.CultureInfo.firstDayOfWeek && 0 !== t.getDay() && (shift += 7), 
t.addDays(shift);
};
}, month_instance_functions = function(n) {
return function() {
return this._is ? (this._is = !1, this.getMonth() === n) :this.moveToMonth(n, this._orient);
};
}, month_static_functions = function(n) {
return function() {
return $D.today().set({
month:n,
day:1
});
};
}, processTerms = function(names, staticFunc, instanceFunc) {
for (var i = 0; i < names.length; i++) $D[names[i].toUpperCase()] = $D[names[i].toUpperCase().substring(0, 3)] = i, 
$D[names[i]] = $D[names[i].substring(0, 3)] = staticFunc(i), $P[names[i]] = $P[names[i].substring(0, 3)] = instanceFunc(i);
};
processTerms(dx, sdf, df), processTerms(mx, month_static_functions, month_instance_functions);
for (var ef = function(j) {
return function() {
if (this._isSecond) return this._isSecond = !1, this;
if (this._same) {
this._same = this._is = !1;
var o1 = this.toObject(), o2 = (arguments[0] || new Date()).toObject(), v = "", k = j.toLowerCase();
k = "s" === k[k.length - 1] ? k.substring(0, k.length - 1) :k;
for (var m = px.length - 1; m > -1; m--) {
if (v = px[m].toLowerCase(), o1[v] !== o2[v]) return !1;
if (k === v) break;
}
return !0;
}
return "s" !== j.substring(j.length - 1) && (j += "s"), this._move && (this._move = null), 
this["add" + j](this._orient);
};
}, nf = function(n) {
return function() {
return this._dateElement = n, this;
};
}, k = 0; k < px.length; k++) de = px[k].toLowerCase(), "weekday" !== de && ($P[de] = $P[de + "s"] = ef(px[k]), 
$N[de] = $N[de + "s"] = nf(de + "s"));
$P._ss = ef("Second");
for (var nthfn = function(n) {
return function(dayOfWeek) {
return this._same ? this._ss(arguments[0]) :dayOfWeek || 0 === dayOfWeek ? this.moveToNthOccurrence(dayOfWeek, n) :(this._nth = n, 
2 !== n || void 0 !== dayOfWeek && null !== dayOfWeek ? this :(this._isSecond = !0, 
this.addSeconds(this._orient)));
};
}, l = 0; l < nth.length; l++) $P[nth[l]] = 0 === l ? nthfn(-1) :nthfn(l);
}(), function() {
"use strict";
Date.Parsing = {
Exception:function(s) {
this.message = "Parse error at '" + s.substring(0, 10) + " ...'";
}
};
var $P = Date.Parsing, dayOffsets = {
standard:[ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ],
leap:[ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 ]
};
$P.isLeapYear = function(year) {
return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var utils = {
multiReplace:function(str, hash) {
var key;
for (key in hash) if (Object.prototype.hasOwnProperty.call(hash, key)) {
var regex;
"function" == typeof hash[key] || (regex = hash[key] instanceof RegExp ? hash[key] :new RegExp(hash[key], "g")), 
str = str.replace(regex, key);
}
return str;
},
getDayOfYearFromWeek:function(obj) {
var d, jan4, offset;
return obj.weekDay = obj.weekDay || 0 === obj.weekDay ? obj.weekDay :1, d = new Date(obj.year, 0, 4), 
jan4 = 0 === d.getDay() ? 7 :d.getDay(), offset = jan4 + 3, obj.dayOfYear = 7 * obj.week + (0 === obj.weekDay ? 7 :obj.weekDay) - offset, 
obj;
},
getDayOfYear:function(obj, dayOffset) {
obj.dayOfYear || (obj = utils.getDayOfYearFromWeek(obj));
for (var i = 0; i <= dayOffset.length; i++) {
if (obj.dayOfYear < dayOffset[i] || i === dayOffset.length) {
obj.day = obj.day ? obj.day :obj.dayOfYear - dayOffset[i - 1];
break;
}
obj.month = i;
}
return obj;
},
adjustForTimeZone:function(obj, date) {
var offset;
return "Z" === obj.zone.toUpperCase() || 0 === obj.zone_hours && 0 === obj.zone_minutes ? offset = -date.getTimezoneOffset() :(offset = 60 * obj.zone_hours + (obj.zone_minutes || 0), 
"+" === obj.zone_sign && (offset *= -1), offset -= date.getTimezoneOffset()), date.setMinutes(date.getMinutes() + offset), 
date;
},
setDefaults:function(obj) {
return obj.year = obj.year || Date.today().getFullYear(), obj.hours = obj.hours || 0, 
obj.minutes = obj.minutes || 0, obj.seconds = obj.seconds || 0, obj.milliseconds = obj.milliseconds || 0, 
(obj.month || !obj.week && !obj.dayOfYear) && (obj.month = obj.month || 0, obj.day = obj.day || 1), 
obj;
},
dataNum:function(data, mod, explict, postProcess) {
var dataNum = 1 * data;
return mod ? postProcess ? data ? 1 * mod(data) :data :data ? mod(dataNum) :data :explict ? data && "undefined" != typeof data ? dataNum :data :data ? dataNum :data;
},
timeDataProcess:function(obj) {
var timeObj = {};
for (var x in obj.data) obj.data.hasOwnProperty(x) && (timeObj[x] = obj.ignore[x] ? obj.data[x] :utils.dataNum(obj.data[x], obj.mods[x], obj.explict[x], obj.postProcess[x]));
return obj.data.secmins && (obj.data.secmins = 60 * obj.data.secmins.replace(",", "."), 
timeObj.minutes ? timeObj.seconds || (timeObj.seconds = obj.data.secmins) :timeObj.minutes = obj.data.secmins, 
delete obj.secmins), timeObj;
},
buildTimeObjectFromData:function(data) {
var time = utils.timeDataProcess({
data:{
year:data[1],
month:data[5],
day:data[7],
week:data[8],
dayOfYear:data[10],
hours:data[15],
zone_hours:data[23],
zone_minutes:data[24],
zone:data[21],
zone_sign:data[22],
weekDay:data[9],
minutes:data[16],
seconds:data[19],
milliseconds:data[20],
secmins:data[18]
},
mods:{
month:function(data) {
return data - 1;
},
weekDay:function(data) {
return data = Math.abs(data), 7 === data ? 0 :data;
},
minutes:function(data) {
return data.replace(":", "");
},
seconds:function(data) {
return Math.floor(1 * data.replace(":", "").replace(",", "."));
},
milliseconds:function(data) {
return 1e3 * data.replace(",", ".");
}
},
postProcess:{
minutes:!0,
seconds:!0,
milliseconds:!0
},
explict:{
zone_hours:!0,
zone_minutes:!0
},
ignore:{
zone:!0,
zone_sign:!0,
secmins:!0
}
});
return time;
},
addToHash:function(hash, keys, data) {
keys = keys, data = data;
for (var len = keys.length, i = 0; len > i; i++) hash[keys[i]] = data[i];
return hash;
},
combineRegex:function(r1, r2) {
return new RegExp("((" + r1.source + ")\\s(" + r2.source + "))");
},
getDateNthString:function(add, last, inc) {
return add ? Date.today().addDays(inc).toString("d") :last ? Date.today().last()[inc]().toString("d") :void 0;
},
buildRegexData:function(array) {
for (var arr = [], len = array.length, i = 0; len > i; i++) "[object Array]" === Object.prototype.toString.call(array[i]) ? arr.push(this.combineRegex(array[i][0], array[i][1])) :arr.push(array[i]);
return arr;
}
};
$P.processTimeObject = function(obj) {
var date, dayOffset;
return utils.setDefaults(obj), dayOffset = $P.isLeapYear(obj.year) ? dayOffsets.leap :dayOffsets.standard, 
obj.month || !obj.week && !obj.dayOfYear ? obj.dayOfYear = dayOffset[obj.month] + obj.day :utils.getDayOfYear(obj, dayOffset), 
date = new Date(obj.year, obj.month, obj.day, obj.hours, obj.minutes, obj.seconds, obj.milliseconds), 
obj.zone && utils.adjustForTimeZone(obj, date), date;
}, $P.ISO = {
regex:/^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-4])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?\s?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,
parse:function(s) {
var time, data = s.match(this.regex);
return data && data.length ? (time = utils.buildTimeObjectFromData(data), time.year && (time.year || time.month || time.day || time.week || time.dayOfYear) ? $P.processTimeObject(time) :null) :null;
}
}, $P.Numeric = {
isNumeric:function(e) {
return !isNaN(parseFloat(e)) && isFinite(e);
},
regex:/\b([0-1]?[0-9])([0-3]?[0-9])([0-2]?[0-9]?[0-9][0-9])\b/i,
parse:function(s) {
var data, i, time = {}, order = Date.CultureInfo.dateElementOrder.split("");
if (!this.isNumeric(s) || "+" === s[0] && "-" === s[0]) return null;
if (s.length < 5 && s.indexOf(".") < 0 && s.indexOf("/") < 0) return time.year = s, 
$P.processTimeObject(time);
if (data = s.match(this.regex), !data || !data.length) return null;
for (i = 0; i < order.length; i++) switch (order[i]) {
case "d":
time.day = data[i + 1];
break;

case "m":
time.month = data[i + 1] - 1;
break;

case "y":
time.year = data[i + 1];
}
return $P.processTimeObject(time);
}
}, $P.Normalizer = {
regexData:function() {
var $R = Date.CultureInfo.regexPatterns;
return utils.buildRegexData([ $R.tomorrow, $R.yesterday, [ $R.past, $R.mon ], [ $R.past, $R.tue ], [ $R.past, $R.wed ], [ $R.past, $R.thu ], [ $R.past, $R.fri ], [ $R.past, $R.sat ], [ $R.past, $R.sun ] ]);
},
basicReplaceHash:function() {
var $R = Date.CultureInfo.regexPatterns;
return {
January:$R.jan.source,
February:$R.feb,
March:$R.mar,
April:$R.apr,
May:$R.may,
June:$R.jun,
July:$R.jul,
August:$R.aug,
September:$R.sep,
October:$R.oct,
November:$R.nov,
December:$R.dec,
"":/\bat\b/gi,
" ":/\s{2,}/,
am:$R.inTheMorning,
"9am":$R.thisMorning,
pm:$R.inTheEvening,
"7pm":$R.thisEvening
};
},
keys:function() {
return [ utils.getDateNthString(!0, !1, 1), utils.getDateNthString(!0, !1, -1), utils.getDateNthString(!1, !0, "monday"), utils.getDateNthString(!1, !0, "tuesday"), utils.getDateNthString(!1, !0, "wednesday"), utils.getDateNthString(!1, !0, "thursday"), utils.getDateNthString(!1, !0, "friday"), utils.getDateNthString(!1, !0, "saturday"), utils.getDateNthString(!1, !0, "sunday") ];
},
buildRegexFunctions:function() {
var $R = Date.CultureInfo.regexPatterns, __ = Date.i18n.__, tomorrowRE = new RegExp("(\\b\\d\\d?(" + __("AM") + "|" + __("PM") + ")? )(" + $R.tomorrow.source.slice(1) + ")", "i"), todayRE = new RegExp($R.today.source + "(?!\\s*([+-]))\\b");
this.replaceFuncs = [ [ todayRE, function(full) {
return full.length > 1 ? Date.today().toString("d") :full;
} ], [ tomorrowRE, function(full, m1) {
var t = Date.today().addDays(1).toString("d");
return t + " " + m1;
} ], [ $R.amThisMorning, function(str, am) {
return am;
} ], [ $R.pmThisEvening, function(str, pm) {
return pm;
} ] ];
},
buildReplaceData:function() {
this.buildRegexFunctions(), this.replaceHash = utils.addToHash(this.basicReplaceHash(), this.keys(), this.regexData());
},
stringReplaceFuncs:function(s) {
for (var i = 0; i < this.replaceFuncs.length; i++) s = s.replace(this.replaceFuncs[i][0], this.replaceFuncs[i][1]);
return s;
},
parse:function(s) {
s = this.stringReplaceFuncs(s), s = utils.multiReplace(s, this.replaceHash);
try {
var n = s.split(/([\s\-\.\,\/\x27]+)/);
3 === n.length && $P.Numeric.isNumeric(n[0]) && $P.Numeric.isNumeric(n[2]) && n[2].length >= 4 && "d" === Date.CultureInfo.dateElementOrder[0] && (s = "1/" + n[0] + "/" + n[2]);
} catch (e) {}
return s;
}
}, $P.Normalizer.buildReplaceData();
}(), function() {
for (var $P = Date.Parsing, _ = $P.Operators = {
rtoken:function(r) {
return function(s) {
var mx = s.match(r);
if (mx) return [ mx[0], s.substring(mx[0].length) ];
throw new $P.Exception(s);
};
},
token:function() {
return function(s) {
return _.rtoken(new RegExp("^\\s*" + s + "\\s*"))(s);
};
},
stoken:function(s) {
return _.rtoken(new RegExp("^" + s));
},
until:function(p) {
return function(s) {
for (var qx = [], rx = null; s.length; ) {
try {
rx = p.call(this, s);
} catch (e) {
qx.push(rx[0]), s = rx[1];
continue;
}
break;
}
return [ qx, s ];
};
},
many:function(p) {
return function(s) {
for (var rx = [], r = null; s.length; ) {
try {
r = p.call(this, s);
} catch (e) {
return [ rx, s ];
}
rx.push(r[0]), s = r[1];
}
return [ rx, s ];
};
},
optional:function(p) {
return function(s) {
var r = null;
try {
r = p.call(this, s);
} catch (e) {
return [ null, s ];
}
return [ r[0], r[1] ];
};
},
not:function(p) {
return function(s) {
try {
p.call(this, s);
} catch (e) {
return [ null, s ];
}
throw new $P.Exception(s);
};
},
ignore:function(p) {
return p ? function(s) {
var r = null;
return r = p.call(this, s), [ null, r[1] ];
} :null;
},
product:function() {
for (var px = arguments[0], qx = Array.prototype.slice.call(arguments, 1), rx = [], i = 0; i < px.length; i++) rx.push(_.each(px[i], qx));
return rx;
},
cache:function(rule) {
var cache = {}, cache_length = 0, cache_keys = [], CACHE_MAX = Date.Config.CACHE_MAX || 1e5, r = null, cacheCheck = function() {
if (cache_length === CACHE_MAX) for (var i = 0; 10 > i; i++) {
var key = cache_keys.shift();
key && (delete cache[key], cache_length--);
}
};
return function(s) {
cacheCheck();
try {
r = cache[s] = cache[s] || rule.call(this, s);
} catch (e) {
r = cache[s] = e;
}
if (cache_length++, cache_keys.push(s), r instanceof $P.Exception) throw r;
return r;
};
},
any:function() {
var px = arguments;
return function(s) {
for (var r = null, i = 0; i < px.length; i++) if (null != px[i]) {
try {
r = px[i].call(this, s);
} catch (e) {
r = null;
}
if (r) return r;
}
throw new $P.Exception(s);
};
},
each:function() {
var px = arguments;
return function(s) {
for (var rx = [], r = null, i = 0; i < px.length; i++) if (null != px[i]) {
try {
r = px[i].call(this, s);
} catch (e) {
throw new $P.Exception(s);
}
rx.push(r[0]), s = r[1];
}
return [ rx, s ];
};
},
all:function() {
var px = arguments, _ = _;
return _.each(_.optional(px));
},
sequence:function(px, d, c) {
return d = d || _.rtoken(/^\s*/), c = c || null, 1 === px.length ? px[0] :function(s) {
for (var r = null, q = null, rx = [], i = 0; i < px.length; i++) {
try {
r = px[i].call(this, s);
} catch (e) {
break;
}
rx.push(r[0]);
try {
q = d.call(this, r[1]);
} catch (ex) {
q = null;
break;
}
s = q[1];
}
if (!r) throw new $P.Exception(s);
if (q) throw new $P.Exception(q[1]);
if (c) try {
r = c.call(this, r[1]);
} catch (ey) {
throw new $P.Exception(r[1]);
}
return [ rx, r ? r[1] :s ];
};
},
between:function(d1, p, d2) {
d2 = d2 || d1;
var _fn = _.each(_.ignore(d1), p, _.ignore(d2));
return function(s) {
var rx = _fn.call(this, s);
return [ [ rx[0][0], r[0][2] ], rx[1] ];
};
},
list:function(p, d, c) {
return d = d || _.rtoken(/^\s*/), c = c || null, p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) :_.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c));
},
set:function(px, d, c) {
return d = d || _.rtoken(/^\s*/), c = c || null, function(s) {
for (var r = null, p = null, q = null, rx = null, best = [ [], s ], last = !1, i = 0; i < px.length; i++) {
q = null, p = null, r = null, last = 1 === px.length;
try {
r = px[i].call(this, s);
} catch (e) {
continue;
}
if (rx = [ [ r[0] ], r[1] ], r[1].length > 0 && !last) try {
q = d.call(this, r[1]);
} catch (ex) {
last = !0;
} else last = !0;
if (last || 0 !== q[1].length || (last = !0), !last) {
for (var qx = [], j = 0; j < px.length; j++) i !== j && qx.push(px[j]);
p = _.set(qx, d).call(this, q[1]), p[0].length > 0 && (rx[0] = rx[0].concat(p[0]), 
rx[1] = p[1]);
}
if (rx[1].length < best[1].length && (best = rx), 0 === best[1].length) break;
}
if (0 === best[0].length) return best;
if (c) {
try {
q = c.call(this, best[1]);
} catch (ey) {
throw new $P.Exception(best[1]);
}
best[1] = q[1];
}
return best;
};
},
forward:function(gr, fname) {
return function(s) {
return gr[fname].call(this, s);
};
},
replace:function(rule, repl) {
return function(s) {
var r = rule.call(this, s);
return [ repl, r[1] ];
};
},
process:function(rule, fn) {
return function(s) {
var r = rule.call(this, s);
return [ fn.call(this, r[0]), r[1] ];
};
},
min:function(min, rule) {
return function(s) {
var rx = rule.call(this, s);
if (rx[0].length < min) throw new $P.Exception(s);
return rx;
};
}
}, _generator = function(op) {
function gen() {
var px, i, args = null, rx = [];
return arguments.length > 1 ? args = Array.prototype.slice.call(arguments) :arguments[0] instanceof Array && (args = arguments[0]), 
args ? (px = args.shift(), px.length > 0 ? (args.unshift(px[i]), rx.push(op.apply(null, args)), 
args.shift(), rx) :void 0) :op.apply(null, arguments);
}
return gen;
}, gx = "optional not ignore cache".split(/\s/), i = 0; i < gx.length; i++) _[gx[i]] = _generator(_[gx[i]]);
for (var _vector = function(op) {
return function() {
return arguments[0] instanceof Array ? op.apply(null, arguments[0]) :op.apply(null, arguments);
};
}, vx = "each any all".split(/\s/), j = 0; j < vx.length; j++) _[vx[j]] = _vector(_[vx[j]]);
}(), function() {
var $D = Date, flattenAndCompact = function(ax) {
for (var rx = [], i = 0; i < ax.length; i++) ax[i] instanceof Array ? rx = rx.concat(flattenAndCompact(ax[i])) :ax[i] && rx.push(ax[i]);
return rx;
}, parseMeridian = function() {
if (this.meridian && (this.hour || 0 === this.hour)) {
if ("a" === this.meridian && this.hour > 11 && Date.Config.strict24hr) throw "Invalid hour and meridian combination";
if ("p" === this.meridian && this.hour < 12 && Date.Config.strict24hr) throw "Invalid hour and meridian combination";
"p" === this.meridian && this.hour < 12 ? this.hour = this.hour + 12 :"a" === this.meridian && 12 === this.hour && (this.hour = 0);
}
}, setDefaults = function() {
var now = new Date();
!this.hour && !this.minute || this.month || this.year || this.day || (this.day = now.getDate()), 
this.year || (this.year = now.getFullYear()), this.month || 0 === this.month || (this.month = now.getMonth()), 
this.day || (this.day = 1), this.hour || (this.hour = 0), this.minute || (this.minute = 0), 
this.second || (this.second = 0), this.millisecond || (this.millisecond = 0);
}, finishUtils = {
getToday:function() {
return this.now || -1 !== "hour minute second".indexOf(this.unit) ? new Date() :$D.today();
},
setDaysFromWeekday:function(today, orient) {
var gap;
return orient = orient || 1, this.unit = "day", gap = $D.getDayNumberFromName(this.weekday) - today.getDay(), 
this.days = gap ? (gap + 7 * orient) % 7 :7 * orient, this;
},
setMonthsFromMonth:function(today, orient) {
var gap;
return orient = orient || 1, this.unit = "month", gap = this.month - today.getMonth(), 
this.months = gap ? (gap + 12 * orient) % 12 :12 * orient, this.month = null, this;
},
setDMYFromWeekday:function() {
var d = Date[this.weekday]();
return this.day = d.getDate(), this.month || (this.month = d.getMonth()), this.year = d.getFullYear(), 
this;
},
setUnitValue:function(orient) {
!this.value && this.operator && null !== this.operator && this[this.unit + "s"] && null !== this[this.unit + "s"] ? this[this.unit + "s"] = this[this.unit + "s"] + ("add" === this.operator ? 1 :-1) + (this.value || 0) * orient :(null == this[this.unit + "s"] || null != this.operator) && (this.value || (this.value = 1), 
this[this.unit + "s"] = this.value * orient);
},
generateDateFromWeeks:function() {
var weekday = void 0 !== this.weekday ? this.weekday :"today", d = Date[weekday]().addWeeks(this.weeks);
return this.now && d.setTimeToNow(), d;
}
};
$D.Translator = {
hour:function(s) {
return function() {
this.hour = Number(s);
};
},
minute:function(s) {
return function() {
this.minute = Number(s);
};
},
second:function(s) {
return function() {
this.second = Number(s);
};
},
secondAndMillisecond:function(s) {
return function() {
var mx = s.match(/^([0-5][0-9])\.([0-9]{1,3})/);
this.second = Number(mx[1]), this.millisecond = Number(mx[2]);
};
},
meridian:function(s) {
return function() {
this.meridian = s.slice(0, 1).toLowerCase();
};
},
timezone:function(s) {
return function() {
var n = s.replace(/[^\d\+\-]/g, "");
n.length ? this.timezoneOffset = Number(n) :this.timezone = s.toLowerCase();
};
},
day:function(x) {
var s = x[0];
return function() {
if (this.day = Number(s.match(/\d+/)[0]), this.day < 1) throw "invalid day";
};
},
month:function(s) {
return function() {
if (this.month = 3 === s.length ? "jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s) / 4 :Number(s) - 1, 
this.month < 0) throw "invalid month";
};
},
year:function(s) {
return function() {
var n = Number(s);
this.year = s.length > 2 ? n :n + (n + 2e3 < Date.CultureInfo.twoDigitYearMax ? 2e3 :1900);
};
},
rday:function(s) {
return function() {
switch (s) {
case "yesterday":
this.days = -1;
break;

case "tomorrow":
this.days = 1;
break;

case "today":
this.days = 0;
break;

case "now":
this.days = 0, this.now = !0;
}
};
},
finishExact:function(x) {
var d;
x = x instanceof Array ? x :[ x ];
for (var i = 0; i < x.length; i++) x[i] && x[i].call(this);
if (setDefaults.call(this), parseMeridian.call(this), this.day > $D.getDaysInMonth(this.year, this.month)) throw new RangeError(this.day + " is not a valid value for days.");
return d = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond), 
this.year < 100 && d.setFullYear(this.year), this.timezone ? d.set({
timezone:this.timezone
}) :this.timezoneOffset && d.set({
timezoneOffset:this.timezoneOffset
}), d;
},
finish:function(x) {
var today, expression, orient, temp;
if (x = x instanceof Array ? flattenAndCompact(x) :[ x ], 0 === x.length) return null;
for (var i = 0; i < x.length; i++) "function" == typeof x[i] && x[i].call(this);
if (this.now && !this.unit && !this.operator) return new Date();
if (today = finishUtils.getToday.call(this), expression = !!(this.days && null !== this.days || this.orient || this.operator), 
orient = "past" === this.orient || "subtract" === this.operator ? -1 :1, this.month && "week" === this.unit && (this.value = this.month + 1, 
delete this.month, delete this.day), !this.month && 0 !== this.month || -1 === "year day hour minute second".indexOf(this.unit) || (this.value || (this.value = this.month + 1), 
this.month = null, expression = !0), expression || !this.weekday || this.day || this.days || finishUtils.setDMYFromWeekday.call(this), 
expression && this.weekday && "month" !== this.unit && "week" !== this.unit && finishUtils.setDaysFromWeekday.call(this, today, orient), 
!this.weekday || "week" === this.unit || this.day || this.days || (temp = Date[this.weekday](), 
this.day = temp.getDate(), temp.getMonth() !== today.getMonth() && (this.month = temp.getMonth())), 
this.month && "day" === this.unit && this.operator && (this.value || (this.value = this.month + 1), 
this.month = null), null != this.value && null != this.month && null != this.year && (this.day = 1 * this.value), 
this.month && !this.day && this.value && (today.set({
day:1 * this.value
}), expression || (this.day = 1 * this.value)), this.month || !this.value || "month" !== this.unit || this.now || (this.month = this.value, 
expression = !0), expression && (this.month || 0 === this.month) && "year" !== this.unit && finishUtils.setMonthsFromMonth.call(this, today, orient), 
this.unit || (this.unit = "day"), finishUtils.setUnitValue.call(this, orient), parseMeridian.call(this), 
!this.month && 0 !== this.month || this.day || (this.day = 1), !this.orient && !this.operator && "week" === this.unit && this.value && !this.day && !this.month) return Date.today().setWeek(this.value);
if ("week" === this.unit && this.weeks && !this.day && !this.month) return finishUtils.generateDateFromWeeks.call(this);
if (expression && this.timezone && this.day && this.days && (this.day = this.days), 
expression ? today.add(this) :today.set(this), this.timezone) {
this.timezone = this.timezone.toUpperCase();
var timezone, offset = $D.getTimezoneOffset(this.timezone);
today.hasDaylightSavingTime() && (timezone = $D.getTimezoneAbbreviation(offset, today.isDaylightSavingTime()), 
timezone !== this.timezone && (today.isDaylightSavingTime() ? today.addHours(-1) :today.addHours(1))), 
today.setTimezoneOffset(offset);
}
return today;
}
};
}(), function() {
var $D = Date;
$D.Grammar = {};
var _fn, _ = $D.Parsing.Operators, g = $D.Grammar, t = $D.Translator;
_fn = function() {
return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext")));
}, g.datePartDelimiter = _.rtoken(/^([\s\-\.\,\/\x27]+)/), g.timePartDelimiter = _.stoken(":"), 
g.whiteSpace = _.rtoken(/^\s*/), g.generalDelimiter = _.rtoken(/^(([\s\,]|at|@|on)+)/);
var _C = {};
g.ctoken = function(keys) {
var fn = _C[keys];
if (!fn) {
for (var c = Date.CultureInfo.regexPatterns, kx = keys.split(/\s+/), px = [], i = 0; i < kx.length; i++) px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));
fn = _C[keys] = _.any.apply(null, px);
}
return fn;
}, g.ctoken2 = function(key) {
return _.rtoken(Date.CultureInfo.regexPatterns[key]);
};
var cacheProcessRtoken = function(key, token, type, eachToken) {
g[key] = eachToken ? _.cache(_.process(_.each(_.rtoken(token), _.optional(g.ctoken2(eachToken))), type)) :_.cache(_.process(_.rtoken(token), type));
}, cacheProcessCtoken = function(token, type) {
return _.cache(_.process(g.ctoken2(token), type));
}, _F = {}, _get = function(f) {
return _F[f] = _F[f] || g.format(f)[0], _F[f];
};
g.allformats = function(fx) {
var rx = [];
if (fx instanceof Array) for (var i = 0; i < fx.length; i++) rx.push(_get(fx[i])); else rx.push(_get(fx));
return rx;
}, g.formats = function(fx) {
if (fx instanceof Array) {
for (var rx = [], i = 0; i < fx.length; i++) rx.push(_get(fx[i]));
return _.any.apply(null, rx);
}
return _get(fx);
};
var grammarFormats = {
timeFormats:function() {
var i, RTokenKeys = [ "h", "hh", "H", "HH", "m", "mm", "s", "ss", "ss.s", "z", "zz" ], RToken = [ /^(0[0-9]|1[0-2]|[1-9])/, /^(0[0-9]|1[0-2])/, /^([0-1][0-9]|2[0-3]|[0-9])/, /^([0-1][0-9]|2[0-3])/, /^([0-5][0-9]|[0-9])/, /^[0-5][0-9]/, /^([0-5][0-9]|[0-9])/, /^[0-5][0-9]/, /^[0-5][0-9]\.[0-9]{1,3}/, /^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/, /^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/ ], tokens = [ t.hour, t.hour, t.hour, t.minute, t.minute, t.second, t.second, t.secondAndMillisecond, t.timezone, t.timezone, t.timezone ];
for (i = 0; i < RTokenKeys.length; i++) cacheProcessRtoken(RTokenKeys[i], RToken[i], tokens[i]);
g.hms = _.cache(_.sequence([ g.H, g.m, g.s ], g.timePartDelimiter)), g.t = cacheProcessCtoken("shortMeridian", t.meridian), 
g.tt = cacheProcessCtoken("longMeridian", t.meridian), g.zzz = cacheProcessCtoken("timezone", t.timezone), 
g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([ g.tt, g.zzz ])), g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);
},
dateFormats:function() {
var i, _setfn = function() {
return _.set(arguments, g.datePartDelimiter);
}, RTokenKeys = [ "d", "dd", "M", "MM", "y", "yy", "yyy", "yyyy" ], RToken = [ /^([0-2]\d|3[0-1]|\d)/, /^([0-2]\d|3[0-1])/, /^(1[0-2]|0\d|\d)/, /^(1[0-2]|0\d)/, /^(\d+)/, /^(\d\d)/, /^(\d\d?\d?\d?)/, /^(\d\d\d\d)/ ], tokens = [ t.day, t.day, t.month, t.month, t.year, t.year, t.year, t.year ], eachToken = [ "ordinalSuffix", "ordinalSuffix" ];
for (i = 0; i < RTokenKeys.length; i++) cacheProcessRtoken(RTokenKeys[i], RToken[i], tokens[i], eachToken[i]);
g.MMM = g.MMMM = _.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month)), 
g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"), function(s) {
return function() {
this.weekday = s;
};
})), g.day = _fn(g.d, g.dd), g.month = _fn(g.M, g.MMM), g.year = _fn(g.yyyy, g.yy), 
g.mdy = _setfn(g.ddd, g.month, g.day, g.year), g.ymd = _setfn(g.ddd, g.year, g.month, g.day), 
g.dmy = _setfn(g.ddd, g.day, g.month, g.year), g.date = function(s) {
return (g[Date.CultureInfo.dateElementOrder] || g.mdy).call(this, s);
};
},
relative:function() {
g.orientation = _.process(g.ctoken("past future"), function(s) {
return function() {
this.orient = s;
};
}), g.operator = _.process(g.ctoken("add subtract"), function(s) {
return function() {
this.operator = s;
};
}), g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday), g.unit = _.process(g.ctoken("second minute hour day week month year"), function(s) {
return function() {
this.unit = s;
};
});
}
};
g.buildGrammarFormats = function() {
_C = {}, grammarFormats.timeFormats(), grammarFormats.dateFormats(), grammarFormats.relative(), 
g.value = _.process(_.rtoken(/^([-+]?\d+)?(st|nd|rd|th)?/), function(s) {
return function() {
this.value = s.replace(/\D/g, "");
};
}), g.expression = _.set([ g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM ]), 
g.format = _.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?(?!e)|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), function(fmt) {
if (g[fmt]) return g[fmt];
throw $D.Parsing.Exception(fmt);
}), _.process(_.rtoken(/^[^dMyhHmstz]+/), function(s) {
return _.ignore(_.stoken(s));
}))), function(rules) {
return _.process(_.each.apply(null, rules), t.finishExact);
}), g._start = _.process(_.set([ g.date, g.time, g.expression ], g.generalDelimiter, g.whiteSpace), t.finish);
}, g.buildGrammarFormats(), g._formats = g.formats([ '"yyyy-MM-ddTHH:mm:ssZ"', "yyyy-MM-ddTHH:mm:ss.sz", "yyyy-MM-ddTHH:mm:ssZ", "yyyy-MM-ddTHH:mm:ssz", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mmZ", "yyyy-MM-ddTHH:mmz", "yyyy-MM-ddTHH:mm", "ddd, MMM dd, yyyy H:mm:ss tt", "ddd MMM d yyyy HH:mm:ss zzz", "MMddyyyy", "ddMMyyyy", "Mddyyyy", "ddMyyyy", "Mdyyyy", "dMyyyy", "yyyy", "Mdyy", "dMyy", "d" ]), 
g.start = function(s) {
try {
var r = g._formats.call({}, s);
if (0 === r[1].length) return r;
} catch (e) {}
return g._start.call({}, s);
};
}(), function() {
function parse(s) {
var d;
return s ? s instanceof Date ? s.clone() :(s.length >= 4 && "0" !== s.charAt(0) && "+" !== s.charAt(0) && "-" !== s.charAt(0) && (d = $D.Parsing.ISO.parse(s) || $D.Parsing.Numeric.parse(s)), 
d instanceof Date && !isNaN(d.getTime()) ? d :(s = $D.Parsing.Normalizer.parse(parseUtils.removeOrds(s)), 
d = parseUtils.grammarParser(s), null !== d ? d :parseUtils.nativeFallback(s))) :null;
}
var $D = Date, parseUtils = {
removeOrds:function(s) {
return ords = s.match(/\b(\d+)(?:st|nd|rd|th)\b/), s = ords && 2 === ords.length ? s.replace(ords[0], ords[1]) :s;
},
grammarParser:function(s) {
var r = null;
try {
r = $D.Grammar.start.call({}, s.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1"));
} catch (e) {
return null;
}
return 0 === r[1].length ? r[0] :null;
},
nativeFallback:function(s) {
var t;
try {
return t = Date._parse(s), t || 0 === t ? new Date(t) :null;
} catch (e) {
return null;
}
}
};
$D._parse || ($D._parse = $D.parse), $D.parse = parse, Date.getParseFunction = function(fx) {
var fns = Date.Grammar.allformats(fx);
return function(s) {
for (var r = null, i = 0; i < fns.length; i++) {
try {
r = fns[i].call({}, s);
} catch (e) {
continue;
}
if (0 === r[1].length) return r[0];
}
return null;
};
}, $D.parseExact = function(s, fx) {
return $D.getParseFunction(fx)(s);
};
}(), function() {
var $D = Date, $P = $D.prototype, p = function(s, l) {
return l || (l = 2), ("000" + s).slice(-1 * l);
}, normalizerSubstitutions = {
d:"dd",
"%d":"dd",
D:"ddd",
"%a":"ddd",
j:"dddd",
l:"dddd",
"%A":"dddd",
S:"S",
F:"MMMM",
"%B":"MMMM",
m:"MM",
"%m":"MM",
M:"MMM",
"%b":"MMM",
"%h":"MMM",
n:"M",
Y:"yyyy",
"%Y":"yyyy",
y:"yy",
"%y":"yy",
g:"h",
"%I":"h",
G:"H",
h:"hh",
H:"HH",
"%H":"HH",
i:"mm",
"%M":"mm",
s:"ss",
"%S":"ss",
"%r":"hh:mm tt",
"%R":"H:mm",
"%T":"H:mm:ss",
"%X":"t",
"%x":"d",
"%e":"d",
"%D":"MM/dd/yy",
"%n":"\\n",
"%t":"\\t",
e:"z",
T:"z",
"%z":"z",
"%Z":"z",
Z:"ZZ",
N:"u",
w:"u",
"%w":"u",
W:"W",
"%V":"W"
}, normalizer = {
substitutes:function(m) {
return normalizerSubstitutions[m];
},
interpreted:function(m, x) {
var y;
switch (m) {
case "%u":
return x.getDay() + 1;

case "z":
return x.getOrdinalNumber();

case "%j":
return p(x.getOrdinalNumber(), 3);

case "%U":
var d1 = x.clone().set({
month:0,
day:1
}).addDays(-1).moveToDayOfWeek(0), d2 = x.clone().addDays(1).moveToDayOfWeek(0, -1);
return d1 > d2 ? "00" :p((d2.getOrdinalNumber() - d1.getOrdinalNumber()) / 7 + 1);

case "%W":
return p(x.getWeek());

case "t":
return $D.getDaysInMonth(x.getFullYear(), x.getMonth());

case "o":
case "%G":
return x.setWeek(x.getISOWeek()).toString("yyyy");

case "%g":
return x._format("%G").slice(-2);

case "a":
case "%p":
return t("tt").toLowerCase();

case "A":
return t("tt").toUpperCase();

case "u":
return p(x.getMilliseconds(), 3);

case "I":
return x.isDaylightSavingTime() ? 1 :0;

case "O":
return x.getUTCOffset();

case "P":
return y = x.getUTCOffset(), y.substring(0, y.length - 2) + ":" + y.substring(y.length - 2);

case "B":
var now = new Date();
return Math.floor((3600 * now.getHours() + 60 * now.getMinutes() + now.getSeconds() + 60 * (now.getTimezoneOffset() + 60)) / 86.4);

case "c":
return x.toISOString().replace(/\"/g, "");

case "U":
return $D.strtotime("now");

case "%c":
return t("d") + " " + t("t");

case "%C":
return Math.floor(x.getFullYear() / 100 + 1);
}
},
shouldOverrideDefaults:function(m) {
switch (m) {
case "%e":
return !0;

default:
return !1;
}
},
parse:function(m, context) {
var formatString, c = context || new Date();
return (formatString = normalizer.substitutes(m)) ? formatString :(formatString = normalizer.interpreted(m, c), 
formatString ? formatString :m);
}
};
$D.normalizeFormat = function(format, context) {
return format.replace(/(%|\\)?.|%%/g, function(t) {
return normalizer.parse(t, context);
});
}, $D.strftime = function(format, time) {
var d = Date.parse(time);
return d._format(format);
}, $D.strtotime = function(time) {
var d = $D.parse(time);
return Math.round($D.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()) / 1e3);
};
var formatReplace = function(context) {
return function(m) {
var formatString, override = !1;
return "\\" === m.charAt(0) || "%%" === m.substring(0, 2) ? m.replace("\\", "").replace("%%", "%") :(override = normalizer.shouldOverrideDefaults(m), 
formatString = $D.normalizeFormat(m, context), formatString ? context.toString(formatString, override) :void 0);
};
};
$P._format = function(format) {
var formatter = formatReplace(this);
return format ? format.replace(/(%|\\)?.|%%/g, formatter) :this._toString();
}, $P.format || ($P.format = $P._format);
}(), function() {
"use strict";
var gFn = function(attr) {
return function() {
return this[attr];
};
}, sFn = function(attr) {
return function(val) {
return this[attr] = val, this;
};
}, attrs = [ "years", "months", "days", "hours", "minutes", "seconds", "milliseconds" ], addSetFuncs = function(context, attrs) {
for (var i = 0; i < attrs.length; i++) {
var $a = attrs[i], $b = $a.slice(0, 1).toUpperCase() + $a.slice(1);
context.prototype[$a] = 0, context.prototype["get" + $b] = gFn($a), context.prototype["set" + $b] = sFn($a);
}
}, TimeSpan = function(days, hours, minutes, seconds, milliseconds) {
if (1 === arguments.length && "number" == typeof days) {
var orient = 0 > days ? -1 :1, millsLeft = Math.abs(days);
this.setDays(Math.floor(millsLeft / 864e5) * orient), millsLeft %= 864e5, this.setHours(Math.floor(millsLeft / 36e5) * orient), 
millsLeft %= 36e5, this.setMinutes(Math.floor(millsLeft / 6e4) * orient), millsLeft %= 6e4, 
this.setSeconds(Math.floor(millsLeft / 1e3) * orient), millsLeft %= 1e3, this.setMilliseconds(millsLeft * orient);
} else this.set(days, hours, minutes, seconds, milliseconds);
return this.getTotalMilliseconds = function() {
return 864e5 * this.getDays() + 36e5 * this.getHours() + 6e4 * this.getMinutes() + 1e3 * this.getSeconds();
}, this.compareTo = function(time) {
var t2, t1 = new Date(1970, 1, 1, this.getHours(), this.getMinutes(), this.getSeconds());
return t2 = null === time ? new Date(1970, 1, 1, 0, 0, 0) :new Date(1970, 1, 1, time.getHours(), time.getMinutes(), time.getSeconds()), 
t2 > t1 ? -1 :t1 > t2 ? 1 :0;
}, this.equals = function(time) {
return 0 === this.compareTo(time);
}, this.add = function(time) {
return null === time ? this :this.addSeconds(time.getTotalMilliseconds() / 1e3);
}, this.subtract = function(time) {
return null === time ? this :this.addSeconds(-time.getTotalMilliseconds() / 1e3);
}, this.addDays = function(n) {
return new TimeSpan(this.getTotalMilliseconds() + 864e5 * n);
}, this.addHours = function(n) {
return new TimeSpan(this.getTotalMilliseconds() + 36e5 * n);
}, this.addMinutes = function(n) {
return new TimeSpan(this.getTotalMilliseconds() + 6e4 * n);
}, this.addSeconds = function(n) {
return new TimeSpan(this.getTotalMilliseconds() + 1e3 * n);
}, this.addMilliseconds = function(n) {
return new TimeSpan(this.getTotalMilliseconds() + n);
}, this.get12HourHour = function() {
return this.getHours() > 12 ? this.getHours() - 12 :0 === this.getHours() ? 12 :this.getHours();
}, this.getDesignator = function() {
return this.getHours() < 12 ? Date.CultureInfo.amDesignator :Date.CultureInfo.pmDesignator;
}, this.toString = function(format) {
this._toString = function() {
return null !== this.getDays() && this.getDays() > 0 ? this.getDays() + "." + this.getHours() + ":" + this.p(this.getMinutes()) + ":" + this.p(this.getSeconds()) :this.getHours() + ":" + this.p(this.getMinutes()) + ":" + this.p(this.getSeconds());
}, this.p = function(s) {
return s.toString().length < 2 ? "0" + s :s;
};
var me = this;
return format ? format.replace(/dd?|HH?|hh?|mm?|ss?|tt?/g, function(format) {
switch (format) {
case "d":
return me.getDays();

case "dd":
return me.p(me.getDays());

case "H":
return me.getHours();

case "HH":
return me.p(me.getHours());

case "h":
return me.get12HourHour();

case "hh":
return me.p(me.get12HourHour());

case "m":
return me.getMinutes();

case "mm":
return me.p(me.getMinutes());

case "s":
return me.getSeconds();

case "ss":
return me.p(me.getSeconds());

case "t":
return (me.getHours() < 12 ? Date.CultureInfo.amDesignator :Date.CultureInfo.pmDesignator).substring(0, 1);

case "tt":
return me.getHours() < 12 ? Date.CultureInfo.amDesignator :Date.CultureInfo.pmDesignator;
}
}) :this._toString();
}, this;
};
addSetFuncs(TimeSpan, attrs.slice(2)), TimeSpan.prototype.set = function(days, hours, minutes, seconds, milliseconds) {
this.setDays(days || this.getDays()), this.setHours(hours || this.getHours()), this.setMinutes(minutes || this.getMinutes()), 
this.setSeconds(seconds || this.getSeconds()), this.setMilliseconds(milliseconds || this.getMilliseconds());
}, Date.prototype.getTimeOfDay = function() {
return new TimeSpan(0, this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds());
}, Date.TimeSpan = TimeSpan, "undefined" != typeof window && (window.TimeSpan = TimeSpan);
}(), function() {
"use strict";
var attrs = [ "years", "months", "days", "hours", "minutes", "seconds", "milliseconds" ], gFn = function(attr) {
return function() {
return this[attr];
};
}, sFn = function(attr) {
return function(val) {
return this[attr] = val, this;
};
}, addSetFuncs = function(context, attrs) {
for (var i = 0; i < attrs.length; i++) {
var $a = attrs[i], $b = $a.slice(0, 1).toUpperCase() + $a.slice(1);
context.prototype[$a] = 0, context.prototype["get" + $b] = gFn($a), context.prototype["set" + $b] = sFn($a);
}
}, setMonthsAndYears = function(orient, d1, d2, context) {
function inc() {
d1.addMonths(-orient), context.months++, 12 === context.months && (context.years++, 
context.months = 0);
}
if (1 === orient) for (;d1 > d2; ) inc(); else for (;d2 > d1; ) inc();
context.months--, context.months *= orient, context.years *= orient;
}, adjustForDST = function(orient, startDate, endDate) {
var hasDSTMismatch = !1 == (startDate.isDaylightSavingTime() === endDate.isDaylightSavingTime());
hasDSTMismatch && 1 === orient ? startDate.addHours(-1) :hasDSTMismatch && startDate.addHours(1);
}, TimePeriod = function(years, months, days, hours, minutes, seconds, milliseconds) {
if (7 === arguments.length) this.set(years, months, days, hours, minutes, seconds, milliseconds); else if (2 === arguments.length && arguments[0] instanceof Date && arguments[1] instanceof Date) {
var startDate = arguments[0].clone(), endDate = arguments[1].clone(), orient = startDate > endDate ? 1 :-1;
this.dates = {
start:arguments[0].clone(),
end:arguments[1].clone()
}, setMonthsAndYears(orient, startDate, endDate, this), adjustForDST(orient, startDate, endDate);
var diff = endDate - startDate;
if (0 !== diff) {
var ts = new TimeSpan(diff);
this.set(this.years, this.months, ts.getDays(), ts.getHours(), ts.getMinutes(), ts.getSeconds(), ts.getMilliseconds());
}
}
return this;
};
addSetFuncs(TimePeriod, attrs), TimePeriod.prototype.set = function(years, months, days, hours, minutes, seconds, milliseconds) {
this.setYears(years || this.getYears()), this.setMonths(months || this.getMonths()), 
this.setDays(days || this.getDays()), this.setHours(hours || this.getHours()), this.setMinutes(minutes || this.getMinutes()), 
this.setSeconds(seconds || this.getSeconds()), this.setMilliseconds(milliseconds || this.getMilliseconds());
}, Date.TimePeriod = TimePeriod, "undefined" != typeof window && (window.TimePeriod = TimePeriod);
}(), function() {
angular.module("angular-minimodal", []).provider("$modal", function() {
this.$get = [ "$http", "$q", "$controller", "$compile", "$rootScope", "$templateCache", function($http, $q, $controller, $compile, $rootScope, $templateCache) {
var defaultOptions, getModal;
return getModal = function(path) {
var cacheData, deferred;
return deferred = $q.defer(), cacheData = $templateCache.get(path), null != cacheData && cacheData.length > 0 ? (deferred.resolve(angular.element(cacheData)), 
deferred.promise) :$http.get(path).then(function(response) {
if (200 !== response.status) throw new Error("$modal could not find path '" + path + "'");
return angular.element(response.data);
});
}, defaultOptions = {
dismissEscape:!0
}, angular.extend(this, {
show:function(options) {
var deferred, getModalPromise, instance;
if (options = angular.extend(defaultOptions, options), null == options) throw new Error("angular-minimodal: No options provided");
if ("string" != typeof options.templateUrl) throw new Error("angular-minmodal: Invalid templateUrl");
return deferred = $q.defer(), instance = {
resolve:function(v) {
return deferred.resolve(v);
},
reject:function(v) {
return deferred.reject(v);
},
result:deferred.promise
}, getModalPromise = getModal(options.templateUrl), getModalPromise.then(function($modal) {
var controller, isChrome, locals, modal;
return modal = $modal[0], document.body.appendChild(modal), options.controller && (locals = {
$scope:options.$scope || $rootScope.$new(),
$modalInstance:instance
}, controller = $controller(options.controller, locals), $modal.data("$ngControllerController", controller), 
$modal.children().data("$ngControllerController", controller)), $compile($modal)(locals.$scope), 
options.dismissEscape && (modal.oncancel = function() {
return instance.reject();
}), isChrome = navigator.userAgent.toLowerCase().indexOf("chrome") > -1, isChrome || dialogPolyfill.registerDialog(modal), 
null != modal.showModal && modal.showModal(), deferred.promise["finally"](function() {
return null != modal.close && modal.close(), $modal.remove();
});
}), instance;
}
});
} ];
});
}.call(this);

var dialogPolyfill = function() {
var supportCustomEvent = window.CustomEvent;
supportCustomEvent || (supportCustomEvent = function(event, x) {
x = x || {};
var ev = document.createEvent("CustomEvent");
return ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null), 
ev;
}, supportCustomEvent.prototype = window.Event.prototype);
var dialogPolyfill = {};
dialogPolyfill.reposition = function(element) {
var scrollTop = document.body.scrollTop || document.documentElement.scrollTop, topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
element.style.top = Math.max(0, topValue) + "px", element.dialogPolyfillInfo.isTopOverridden = !0;
}, dialogPolyfill.inNodeList = function(nodeList, node) {
for (var i = 0; i < nodeList.length; ++i) if (nodeList[i] == node) return !0;
return !1;
}, dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {
for (var i = 0; i < document.styleSheets.length; ++i) {
var styleSheet = document.styleSheets[i], cssRules = null;
try {
cssRules = styleSheet.cssRules;
} catch (e) {}
if (cssRules) for (var j = 0; j < cssRules.length; ++j) {
var rule = cssRules[j], selectedNodes = null;
try {
selectedNodes = document.querySelectorAll(rule.selectorText);
} catch (e) {}
if (selectedNodes && dialogPolyfill.inNodeList(selectedNodes, element)) {
var cssTop = rule.style.getPropertyValue("top"), cssBottom = rule.style.getPropertyValue("bottom");
if (cssTop && "auto" != cssTop || cssBottom && "auto" != cssBottom) return !0;
}
}
}
return !1;
}, dialogPolyfill.needsCentering = function(dialog) {
var computedStyle = window.getComputedStyle(dialog);
return "absolute" != computedStyle.position ? !1 :"auto" != dialog.style.top && "" != dialog.style.top || "auto" != dialog.style.bottom && "" != dialog.style.bottom ? !1 :!dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
}, dialogPolyfill.showDialog = function(isModal) {
if (this.open) throw "InvalidStateError: showDialog called on open dialog";
if (this.open = !0, this.setAttribute("open", "open"), isModal) {
var first_form_ctrl = null, autofocus = null, findElementToFocus = function(root) {
if (root.children) for (var i = 0; i < root.children.length; i++) {
var elem = root.children[i];
if (null !== first_form_ctrl || elem.disabled || "BUTTON" != elem.nodeName && "INPUT" != elem.nodeName && "KEYGEN" != elem.nodeName && "SELECT" != elem.nodeName && "TEXTAREA" != elem.nodeName || (first_form_ctrl = elem), 
elem.autofocus) return autofocus = elem, void 0;
if (findElementToFocus(elem), null !== autofocus) return;
}
};
findElementToFocus(this), null !== autofocus ? autofocus.focus() :null !== first_form_ctrl && first_form_ctrl.focus();
}
dialogPolyfill.needsCentering(this) && dialogPolyfill.reposition(this), isModal && (this.dialogPolyfillInfo.modal = !0, 
dialogPolyfill.dm.pushDialog(this));
try {
null !== autofocus ? autofocus.focus() :null !== first_form_ctrl && first_form_ctrl.focus();
} catch (e) {}
this.style.zoom = 1;
}, dialogPolyfill.close = function(retval) {
if (!this.open && !window.HTMLDialogElement) throw "InvalidStateError: close called on closed dialog";
this.open = !1, this.removeAttribute("open"), "undefined" != typeof retval && (this.returnValue = retval), 
this.dialogPolyfillInfo.isTopOverridden && (this.style.top = "auto"), this.dialogPolyfillInfo.modal && dialogPolyfill.dm.removeDialog(this);
var event;
return document.createEvent ? (event = document.createEvent("HTMLEvents"), event.initEvent("close", !0, !0)) :event = new Event("close"), 
this.dispatchEvent(event), this.returnValue;
}, dialogPolyfill.registerDialog = function(element) {
element.show && console.warn("This browser already supports <dialog>, the polyfill may not work correctly."), 
element.addEventListener("dialog_submit", function(e) {
element.close(e.detail.target.value), e.preventDefault(), e.stopPropagation();
}), element.show = dialogPolyfill.showDialog.bind(element, !1), element.showModal = dialogPolyfill.showDialog.bind(element, !0), 
element.close = dialogPolyfill.close.bind(element), element.dialogPolyfillInfo = {};
};
var TOP_LAYER_ZINDEX = 1e5, MAX_PENDING_DIALOGS = 1e5;
return dialogPolyfill.DialogManager = function() {
this.pendingDialogStack = [], this.overlay = document.createElement("div"), this.overlay.style.width = "100%", 
this.overlay.style.height = "100%", this.overlay.style.position = "fixed", this.overlay.style.left = "0px", 
this.overlay.style.top = "0px", this.overlay.style.backgroundColor = "rgba(0,0,0,0.0)", 
this.focusPageLast = this.createFocusable(), this.overlay.appendChild(this.focusPageLast), 
this.overlay.addEventListener("click", function(e) {
var redirectedEvent = document.createEvent("MouseEvents");
redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), 
document.body.dispatchEvent(redirectedEvent);
}), window.addEventListener("load", function() {
for (var forms = document.getElementsByTagName("form"), i = forms.length; i--; ) !function(form) {
"dialog" == form.getAttribute("method") && form.addEventListener("click", function(e) {
if ("submit" == e.target.type) {
var event = new supportCustomEvent("dialog_submit", {
bubbles:!0,
detail:{
target:e.target
}
});
this.dispatchEvent(event), e.preventDefault();
}
});
}(forms[i]);
});
}, dialogPolyfill.DialogManager.prototype.createFocusable = function(tabIndex) {
var span = document.createElement("span");
return span.tabIndex = tabIndex || 0, span.style.opacity = 0, span.style.position = "static", 
span;
}, dialogPolyfill.DialogManager.prototype.blockDocument = function() {
document.body.contains(this.overlay) || (document.body.appendChild(this.overlay), 
void 0 === this.needsDocumentElementFocus && (document.documentElement.focus(), 
this.needsDocumentElementFocus = document.activeElement != document.documentElement), 
this.needsDocumentElementFocus && (document.documentElement.tabIndex = 1));
}, dialogPolyfill.DialogManager.prototype.unblockDocument = function() {
document.body.removeChild(this.overlay), this.needsDocumentElementFocus && (document.documentElement.tabIndex = "");
}, dialogPolyfill.DialogManager.prototype.updateStacking = function() {
if (0 == this.pendingDialogStack.length) return this.unblockDocument(), void 0;
this.blockDocument();
for (var zIndex = TOP_LAYER_ZINDEX, i = 0; i < this.pendingDialogStack.length; i++) {
i == this.pendingDialogStack.length - 1 && (this.overlay.style.zIndex = zIndex++);
var dialog = this.pendingDialogStack[i];
dialog.dialogPolyfillInfo.backdrop.style.zIndex = zIndex++, dialog.style.zIndex = zIndex++;
}
}, dialogPolyfill.DialogManager.prototype.handleKey = function(event) {
var dialogCount = this.pendingDialogStack.length;
if (0 != dialogCount) {
var dialog = this.pendingDialogStack[dialogCount - 1], pfi = dialog.dialogPolyfillInfo;
switch (event.keyCode) {
case 9:
var activeElement = document.activeElement, forward = !event.shiftKey;
forward ? activeElement == document.documentElement || activeElement == document.body || activeElement == pfi.backdrop ? pfi.focusFirst.focus() :activeElement == pfi.focusLast && pfi.focusFirst.focus() :activeElement == pfi.focusFirst ? pfi.focusLast.focus() :activeElement == this.focusPageLast && pfi.focusLast.focus();
break;

case 27:
event.preventDefault(), event.stopPropagation();
var cancelEvent = new supportCustomEvent("cancel", {
bubbles:!1,
cancelable:!0
});
dialog.dispatchEvent(cancelEvent) && dialog.close();
}
}
}, dialogPolyfill.DialogManager.prototype.pushDialog = function(dialog) {
if (this.pendingDialogStack.length >= MAX_PENDING_DIALOGS) throw "Too many modal dialogs";
var backdrop = document.createElement("div");
backdrop.className = "backdrop";
var clickEventListener = function(e) {
var redirectedEvent = document.createEvent("MouseEvents");
redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), 
dialog.dispatchEvent(redirectedEvent);
};
backdrop.addEventListener("click", clickEventListener), dialog.parentNode.insertBefore(backdrop, dialog.nextSibling), 
dialog.dialogPolyfillInfo.backdrop = backdrop, dialog.dialogPolyfillInfo.clickEventListener = clickEventListener, 
this.pendingDialogStack.push(dialog), this.updateStacking(), dialog.dialogPolyfillInfo.focusFirst = this.createFocusable(), 
dialog.dialogPolyfillInfo.focusLast = this.createFocusable(), dialog.appendChild(dialog.dialogPolyfillInfo.focusLast), 
dialog.insertBefore(dialog.dialogPolyfillInfo.focusFirst, dialog.firstChild);
}, dialogPolyfill.DialogManager.prototype.removeDialog = function(dialog) {
var index = this.pendingDialogStack.indexOf(dialog);
if (-1 != index) {
this.pendingDialogStack.splice(index, 1);
var backdrop = dialog.dialogPolyfillInfo.backdrop, clickEventListener = dialog.dialogPolyfillInfo.clickEventListener;
backdrop.removeEventListener("click", clickEventListener), backdrop.parentNode.removeChild(backdrop), 
dialog.dialogPolyfillInfo.backdrop = null, dialog.dialogPolyfillInfo.clickEventListener = null, 
this.updateStacking(), dialog.removeChild(dialog.dialogPolyfillInfo.focusFirst), 
dialog.removeChild(dialog.dialogPolyfillInfo.focusLast), dialog.dialogPolyfillInfo.focusFirst = null, 
dialog.dialogPolyfillInfo.focusLast = null;
}
}, dialogPolyfill.dm = new dialogPolyfill.DialogManager(), document.addEventListener("keydown", dialogPolyfill.dm.handleKey.bind(dialogPolyfill.dm)), 
dialogPolyfill;
}();

!function(f) {
if ("object" == typeof exports && "undefined" != typeof module) module.exports = f(); else if ("function" == typeof define && define.amd) define([], f); else {
var g;
g = "undefined" != typeof window ? window :"undefined" != typeof global ? global :"undefined" != typeof self ? self :this, 
g.scribeAngular = f();
}
}(function() {
var define;
return function e(t, n, r) {
function s(o, u) {
if (!n[o]) {
if (!t[o]) {
var a = "function" == typeof require && require;
if (!u && a) return a(o, !0);
if (i) return i(o, !0);
var f = new Error("Cannot find module '" + o + "'");
throw f.code = "MODULE_NOT_FOUND", f;
}
var l = n[o] = {
exports:{}
};
t[o][0].call(l.exports, function(e) {
var n = t[o][1][e];
return s(n ? n :e);
}, l, l.exports, e, t, n, r);
}
return n[o].exports;
}
for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
return s;
}({
1:[ function(require, module, exports) {
!function(global, factory) {
"object" == typeof exports && "undefined" != typeof module ? module.exports = factory() :"function" == typeof define && define.amd ? define(factory) :global.Immutable = factory();
}(this, function() {
"use strict";
function createClass(ctor, superClass) {
superClass && (ctor.prototype = Object.create(superClass.prototype)), ctor.prototype.constructor = ctor;
}
function MakeRef(ref) {
return ref.value = !1, ref;
}
function SetRef(ref) {
ref && (ref.value = !0);
}
function OwnerID() {}
function arrCopy(arr, offset) {
offset = offset || 0;
for (var len = Math.max(0, arr.length - offset), newArr = new Array(len), ii = 0; len > ii; ii++) newArr[ii] = arr[ii + offset];
return newArr;
}
function ensureSize(iter) {
return void 0 === iter.size && (iter.size = iter.__iterate(returnTrue)), iter.size;
}
function wrapIndex(iter, index) {
return index >= 0 ? +index :ensureSize(iter) + +index;
}
function returnTrue() {
return !0;
}
function wholeSlice(begin, end, size) {
return (0 === begin || void 0 !== size && -size >= begin) && (void 0 === end || void 0 !== size && end >= size);
}
function resolveBegin(begin, size) {
return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
return void 0 === index ? defaultIndex :0 > index ? Math.max(0, size + index) :void 0 === size ? index :Math.min(size, index);
}
function Iterable(value) {
return isIterable(value) ? value :Seq(value);
}
function KeyedIterable(value) {
return isKeyed(value) ? value :KeyedSeq(value);
}
function IndexedIterable(value) {
return isIndexed(value) ? value :IndexedSeq(value);
}
function SetIterable(value) {
return isIterable(value) && !isAssociative(value) ? value :SetSeq(value);
}
function isIterable(maybeIterable) {
return !(!maybeIterable || !maybeIterable[IS_ITERABLE_SENTINEL]);
}
function isKeyed(maybeKeyed) {
return !(!maybeKeyed || !maybeKeyed[IS_KEYED_SENTINEL]);
}
function isIndexed(maybeIndexed) {
return !(!maybeIndexed || !maybeIndexed[IS_INDEXED_SENTINEL]);
}
function isAssociative(maybeAssociative) {
return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
function isOrdered(maybeOrdered) {
return !(!maybeOrdered || !maybeOrdered[IS_ORDERED_SENTINEL]);
}
function src_Iterator__Iterator(next) {
this.next = next;
}
function iteratorValue(type, k, v, iteratorResult) {
var value = 0 === type ? k :1 === type ? v :[ k, v ];
return iteratorResult ? iteratorResult.value = value :iteratorResult = {
value:value,
done:!1
}, iteratorResult;
}
function iteratorDone() {
return {
value:void 0,
done:!0
};
}
function hasIterator(maybeIterable) {
return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
return maybeIterator && "function" == typeof maybeIterator.next;
}
function getIterator(iterable) {
var iteratorFn = getIteratorFn(iterable);
return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
return "function" == typeof iteratorFn ? iteratorFn :void 0;
}
function isArrayLike(value) {
return value && "number" == typeof value.length;
}
function Seq(value) {
return null === value || void 0 === value ? emptySequence() :isIterable(value) ? value.toSeq() :seqFromValue(value);
}
function KeyedSeq(value) {
return null === value || void 0 === value ? emptySequence().toKeyedSeq() :isIterable(value) ? isKeyed(value) ? value.toSeq() :value.fromEntrySeq() :keyedSeqFromValue(value);
}
function IndexedSeq(value) {
return null === value || void 0 === value ? emptySequence() :isIterable(value) ? isKeyed(value) ? value.entrySeq() :value.toIndexedSeq() :indexedSeqFromValue(value);
}
function SetSeq(value) {
return (null === value || void 0 === value ? emptySequence() :isIterable(value) ? isKeyed(value) ? value.entrySeq() :value :indexedSeqFromValue(value)).toSetSeq();
}
function ArraySeq(array) {
this._array = array, this.size = array.length;
}
function ObjectSeq(object) {
var keys = Object.keys(object);
this._object = object, this._keys = keys, this.size = keys.length;
}
function IterableSeq(iterable) {
this._iterable = iterable, this.size = iterable.length || iterable.size;
}
function IteratorSeq(iterator) {
this._iterator = iterator, this._iteratorCache = [];
}
function isSeq(maybeSeq) {
return !(!maybeSeq || !maybeSeq[IS_SEQ_SENTINEL]);
}
function emptySequence() {
return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :"object" == typeof value ? new ObjectSeq(value) :void 0;
if (!seq) throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + value);
return seq;
}
function indexedSeqFromValue(value) {
var seq = maybeIndexedSeqFromValue(value);
if (!seq) throw new TypeError("Expected Array or iterable object of values: " + value);
return seq;
}
function seqFromValue(value) {
var seq = maybeIndexedSeqFromValue(value) || "object" == typeof value && new ObjectSeq(value);
if (!seq) throw new TypeError("Expected Array or iterable object of values, or keyed object: " + value);
return seq;
}
function maybeIndexedSeqFromValue(value) {
return isArrayLike(value) ? new ArraySeq(value) :isIterator(value) ? new IteratorSeq(value) :hasIterator(value) ? new IterableSeq(value) :void 0;
}
function seqIterate(seq, fn, reverse, useKeys) {
var cache = seq._cache;
if (cache) {
for (var maxIndex = cache.length - 1, ii = 0; maxIndex >= ii; ii++) {
var entry = cache[reverse ? maxIndex - ii :ii];
if (fn(entry[1], useKeys ? entry[0] :ii, seq) === !1) return ii + 1;
}
return ii;
}
return seq.__iterateUncached(fn, reverse);
}
function seqIterator(seq, type, reverse, useKeys) {
var cache = seq._cache;
if (cache) {
var maxIndex = cache.length - 1, ii = 0;
return new src_Iterator__Iterator(function() {
var entry = cache[reverse ? maxIndex - ii :ii];
return ii++ > maxIndex ? iteratorDone() :iteratorValue(type, useKeys ? entry[0] :ii - 1, entry[1]);
});
}
return seq.__iteratorUncached(type, reverse);
}
function Collection() {
throw TypeError("Abstract");
}
function KeyedCollection() {}
function IndexedCollection() {}
function SetCollection() {}
function is(valueA, valueB) {
return valueA === valueB || valueA !== valueA && valueB !== valueB ? !0 :valueA && valueB ? ("function" == typeof valueA.valueOf && "function" == typeof valueB.valueOf && (valueA = valueA.valueOf(), 
valueB = valueB.valueOf()), "function" == typeof valueA.equals && "function" == typeof valueB.equals ? valueA.equals(valueB) :valueA === valueB || valueA !== valueA && valueB !== valueB) :!1;
}
function fromJS(json, converter) {
return converter ? fromJSWith(converter, json, "", {
"":json
}) :fromJSDefault(json);
}
function fromJSWith(converter, json, key, parentJSON) {
return Array.isArray(json) ? converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k) {
return fromJSWith(converter, v, k, json);
})) :isPlainObj(json) ? converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k) {
return fromJSWith(converter, v, k, json);
})) :json;
}
function fromJSDefault(json) {
return Array.isArray(json) ? IndexedSeq(json).map(fromJSDefault).toList() :isPlainObj(json) ? KeyedSeq(json).map(fromJSDefault).toMap() :json;
}
function isPlainObj(value) {
return value && (value.constructor === Object || void 0 === value.constructor);
}
function smi(i32) {
return i32 >>> 1 & 1073741824 | 3221225471 & i32;
}
function hash(o) {
if (o === !1 || null === o || void 0 === o) return 0;
if ("function" == typeof o.valueOf && (o = o.valueOf(), o === !1 || null === o || void 0 === o)) return 0;
if (o === !0) return 1;
var type = typeof o;
if ("number" === type) {
var h = 0 | o;
for (h !== o && (h ^= 4294967295 * o); o > 4294967295; ) o /= 4294967295, h ^= o;
return smi(h);
}
return "string" === type ? o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) :hashString(o) :"function" == typeof o.hashCode ? o.hashCode() :hashJSObj(o);
}
function cachedHashString(string) {
var hash = stringHashCache[string];
return void 0 === hash && (hash = hashString(string), STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE && (STRING_HASH_CACHE_SIZE = 0, 
stringHashCache = {}), STRING_HASH_CACHE_SIZE++, stringHashCache[string] = hash), 
hash;
}
function hashString(string) {
for (var hash = 0, ii = 0; ii < string.length; ii++) hash = 31 * hash + string.charCodeAt(ii) | 0;
return smi(hash);
}
function hashJSObj(obj) {
var hash = weakMap && weakMap.get(obj);
if (hash) return hash;
if (hash = obj[UID_HASH_KEY]) return hash;
if (!canDefineProperty) {
if (hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY]) return hash;
if (hash = getIENodeHash(obj)) return hash;
}
if (Object.isExtensible && !Object.isExtensible(obj)) throw new Error("Non-extensible objects are not allowed as keys.");
if (hash = ++objHashUID, 1073741824 & objHashUID && (objHashUID = 0), weakMap) weakMap.set(obj, hash); else if (canDefineProperty) Object.defineProperty(obj, UID_HASH_KEY, {
enumerable:!1,
configurable:!1,
writable:!1,
value:hash
}); else if (obj.propertyIsEnumerable && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) obj.propertyIsEnumerable = function() {
return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
}, obj.propertyIsEnumerable[UID_HASH_KEY] = hash; else {
if (!obj.nodeType) throw new Error("Unable to set a non-enumerable property on object.");
obj[UID_HASH_KEY] = hash;
}
return hash;
}
function getIENodeHash(node) {
if (node && node.nodeType > 0) switch (node.nodeType) {
case 1:
return node.uniqueID;

case 9:
return node.documentElement && node.documentElement.uniqueID;
}
}
function invariant(condition, error) {
if (!condition) throw new Error(error);
}
function assertNotInfinite(size) {
invariant(1/0 !== size, "Cannot perform this action with an infinite size.");
}
function ToKeyedSequence(indexed, useKeys) {
this._iter = indexed, this._useKeys = useKeys, this.size = indexed.size;
}
function ToIndexedSequence(iter) {
this._iter = iter, this.size = iter.size;
}
function ToSetSequence(iter) {
this._iter = iter, this.size = iter.size;
}
function FromEntriesSequence(entries) {
this._iter = entries, this.size = entries.size;
}
function flipFactory(iterable) {
var flipSequence = makeSequence(iterable);
return flipSequence._iter = iterable, flipSequence.size = iterable.size, flipSequence.flip = function() {
return iterable;
}, flipSequence.reverse = function() {
var reversedSequence = iterable.reverse.apply(this);
return reversedSequence.flip = function() {
return iterable.reverse();
}, reversedSequence;
}, flipSequence.has = function(key) {
return iterable.contains(key);
}, flipSequence.contains = function(key) {
return iterable.has(key);
}, flipSequence.cacheResult = cacheResultThrough, flipSequence.__iterateUncached = function(fn, reverse) {
var this$0 = this;
return iterable.__iterate(function(v, k) {
return fn(k, v, this$0) !== !1;
}, reverse);
}, flipSequence.__iteratorUncached = function(type, reverse) {
if (type === ITERATE_ENTRIES) {
var iterator = iterable.__iterator(type, reverse);
return new src_Iterator__Iterator(function() {
var step = iterator.next();
if (!step.done) {
var k = step.value[0];
step.value[0] = step.value[1], step.value[1] = k;
}
return step;
});
}
return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS :ITERATE_VALUES, reverse);
}, flipSequence;
}
function mapFactory(iterable, mapper, context) {
var mappedSequence = makeSequence(iterable);
return mappedSequence.size = iterable.size, mappedSequence.has = function(key) {
return iterable.has(key);
}, mappedSequence.get = function(key, notSetValue) {
var v = iterable.get(key, NOT_SET);
return v === NOT_SET ? notSetValue :mapper.call(context, v, key, iterable);
}, mappedSequence.__iterateUncached = function(fn, reverse) {
var this$0 = this;
return iterable.__iterate(function(v, k, c) {
return fn(mapper.call(context, v, k, c), k, this$0) !== !1;
}, reverse);
}, mappedSequence.__iteratorUncached = function(type, reverse) {
var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
return new src_Iterator__Iterator(function() {
var step = iterator.next();
if (step.done) return step;
var entry = step.value, key = entry[0];
return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
});
}, mappedSequence;
}
function reverseFactory(iterable, useKeys) {
var reversedSequence = makeSequence(iterable);
return reversedSequence._iter = iterable, reversedSequence.size = iterable.size, 
reversedSequence.reverse = function() {
return iterable;
}, iterable.flip && (reversedSequence.flip = function() {
var flipSequence = flipFactory(iterable);
return flipSequence.reverse = function() {
return iterable.flip();
}, flipSequence;
}), reversedSequence.get = function(key, notSetValue) {
return iterable.get(useKeys ? key :-1 - key, notSetValue);
}, reversedSequence.has = function(key) {
return iterable.has(useKeys ? key :-1 - key);
}, reversedSequence.contains = function(value) {
return iterable.contains(value);
}, reversedSequence.cacheResult = cacheResultThrough, reversedSequence.__iterate = function(fn, reverse) {
var this$0 = this;
return iterable.__iterate(function(v, k) {
return fn(v, k, this$0);
}, !reverse);
}, reversedSequence.__iterator = function(type, reverse) {
return iterable.__iterator(type, !reverse);
}, reversedSequence;
}
function filterFactory(iterable, predicate, context, useKeys) {
var filterSequence = makeSequence(iterable);
return useKeys && (filterSequence.has = function(key) {
var v = iterable.get(key, NOT_SET);
return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
}, filterSequence.get = function(key, notSetValue) {
var v = iterable.get(key, NOT_SET);
return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v :notSetValue;
}), filterSequence.__iterateUncached = function(fn, reverse) {
var this$0 = this, iterations = 0;
return iterable.__iterate(function(v, k, c) {
return predicate.call(context, v, k, c) ? (iterations++, fn(v, useKeys ? k :iterations - 1, this$0)) :void 0;
}, reverse), iterations;
}, filterSequence.__iteratorUncached = function(type, reverse) {
var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse), iterations = 0;
return new src_Iterator__Iterator(function() {
for (;;) {
var step = iterator.next();
if (step.done) return step;
var entry = step.value, key = entry[0], value = entry[1];
if (predicate.call(context, value, key, iterable)) return iteratorValue(type, useKeys ? key :iterations++, value, step);
}
});
}, filterSequence;
}
function countByFactory(iterable, grouper, context) {
var groups = src_Map__Map().asMutable();
return iterable.__iterate(function(v, k) {
groups.update(grouper.call(context, v, k, iterable), 0, function(a) {
return a + 1;
});
}), groups.asImmutable();
}
function groupByFactory(iterable, grouper, context) {
var isKeyedIter = isKeyed(iterable), groups = (isOrdered(iterable) ? OrderedMap() :src_Map__Map()).asMutable();
iterable.__iterate(function(v, k) {
groups.update(grouper.call(context, v, k, iterable), function(a) {
return a = a || [], a.push(isKeyedIter ? [ k, v ] :v), a;
});
});
var coerce = iterableClass(iterable);
return groups.map(function(arr) {
return reify(iterable, coerce(arr));
});
}
function sliceFactory(iterable, begin, end, useKeys) {
var originalSize = iterable.size;
if (wholeSlice(begin, end, originalSize)) return iterable;
var resolvedBegin = resolveBegin(begin, originalSize), resolvedEnd = resolveEnd(end, originalSize);
if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
var sliceSize = resolvedEnd - resolvedBegin;
0 > sliceSize && (sliceSize = 0);
var sliceSeq = makeSequence(iterable);
return sliceSeq.size = 0 === sliceSize ? sliceSize :iterable.size && sliceSize || void 0, 
!useKeys && isSeq(iterable) && sliceSize >= 0 && (sliceSeq.get = function(index, notSetValue) {
return index = wrapIndex(this, index), index >= 0 && sliceSize > index ? iterable.get(index + resolvedBegin, notSetValue) :notSetValue;
}), sliceSeq.__iterateUncached = function(fn, reverse) {
var this$0 = this;
if (0 === sliceSize) return 0;
if (reverse) return this.cacheResult().__iterate(fn, reverse);
var skipped = 0, isSkipping = !0, iterations = 0;
return iterable.__iterate(function(v, k) {
return isSkipping && (isSkipping = skipped++ < resolvedBegin) ? void 0 :(iterations++, 
fn(v, useKeys ? k :iterations - 1, this$0) !== !1 && iterations !== sliceSize);
}), iterations;
}, sliceSeq.__iteratorUncached = function(type, reverse) {
if (sliceSize && reverse) return this.cacheResult().__iterator(type, reverse);
var iterator = sliceSize && iterable.__iterator(type, reverse), skipped = 0, iterations = 0;
return new src_Iterator__Iterator(function() {
for (;skipped++ !== resolvedBegin; ) iterator.next();
if (++iterations > sliceSize) return iteratorDone();
var step = iterator.next();
return useKeys || type === ITERATE_VALUES ? step :type === ITERATE_KEYS ? iteratorValue(type, iterations - 1, void 0, step) :iteratorValue(type, iterations - 1, step.value[1], step);
});
}, sliceSeq;
}
function takeWhileFactory(iterable, predicate, context) {
var takeSequence = makeSequence(iterable);
return takeSequence.__iterateUncached = function(fn, reverse) {
var this$0 = this;
if (reverse) return this.cacheResult().__iterate(fn, reverse);
var iterations = 0;
return iterable.__iterate(function(v, k, c) {
return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
}), iterations;
}, takeSequence.__iteratorUncached = function(type, reverse) {
var this$0 = this;
if (reverse) return this.cacheResult().__iterator(type, reverse);
var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse), iterating = !0;
return new src_Iterator__Iterator(function() {
if (!iterating) return iteratorDone();
var step = iterator.next();
if (step.done) return step;
var entry = step.value, k = entry[0], v = entry[1];
return predicate.call(context, v, k, this$0) ? type === ITERATE_ENTRIES ? step :iteratorValue(type, k, v, step) :(iterating = !1, 
iteratorDone());
});
}, takeSequence;
}
function skipWhileFactory(iterable, predicate, context, useKeys) {
var skipSequence = makeSequence(iterable);
return skipSequence.__iterateUncached = function(fn, reverse) {
var this$0 = this;
if (reverse) return this.cacheResult().__iterate(fn, reverse);
var isSkipping = !0, iterations = 0;
return iterable.__iterate(function(v, k, c) {
return isSkipping && (isSkipping = predicate.call(context, v, k, c)) ? void 0 :(iterations++, 
fn(v, useKeys ? k :iterations - 1, this$0));
}), iterations;
}, skipSequence.__iteratorUncached = function(type, reverse) {
var this$0 = this;
if (reverse) return this.cacheResult().__iterator(type, reverse);
var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse), skipping = !0, iterations = 0;
return new src_Iterator__Iterator(function() {
var step, k, v;
do {
if (step = iterator.next(), step.done) return useKeys || type === ITERATE_VALUES ? step :type === ITERATE_KEYS ? iteratorValue(type, iterations++, void 0, step) :iteratorValue(type, iterations++, step.value[1], step);
var entry = step.value;
k = entry[0], v = entry[1], skipping && (skipping = predicate.call(context, v, k, this$0));
} while (skipping);
return type === ITERATE_ENTRIES ? step :iteratorValue(type, k, v, step);
});
}, skipSequence;
}
function concatFactory(iterable, values) {
var isKeyedIterable = isKeyed(iterable), iters = [ iterable ].concat(values).map(function(v) {
return isIterable(v) ? isKeyedIterable && (v = KeyedIterable(v)) :v = isKeyedIterable ? keyedSeqFromValue(v) :indexedSeqFromValue(Array.isArray(v) ? v :[ v ]), 
v;
}).filter(function(v) {
return 0 !== v.size;
});
if (0 === iters.length) return iterable;
if (1 === iters.length) {
var singleton = iters[0];
if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) return singleton;
}
var concatSeq = new ArraySeq(iters);
return isKeyedIterable ? concatSeq = concatSeq.toKeyedSeq() :isIndexed(iterable) || (concatSeq = concatSeq.toSetSeq()), 
concatSeq = concatSeq.flatten(!0), concatSeq.size = iters.reduce(function(sum, seq) {
if (void 0 !== sum) {
var size = seq.size;
if (void 0 !== size) return sum + size;
}
}, 0), concatSeq;
}
function flattenFactory(iterable, depth, useKeys) {
var flatSequence = makeSequence(iterable);
return flatSequence.__iterateUncached = function(fn, reverse) {
function flatDeep(iter, currentDepth) {
var this$0 = this;
iter.__iterate(function(v, k) {
return (!depth || depth > currentDepth) && isIterable(v) ? flatDeep(v, currentDepth + 1) :fn(v, useKeys ? k :iterations++, this$0) === !1 && (stopped = !0), 
!stopped;
}, reverse);
}
var iterations = 0, stopped = !1;
return flatDeep(iterable, 0), iterations;
}, flatSequence.__iteratorUncached = function(type, reverse) {
var iterator = iterable.__iterator(type, reverse), stack = [], iterations = 0;
return new src_Iterator__Iterator(function() {
for (;iterator; ) {
var step = iterator.next();
if (step.done === !1) {
var v = step.value;
if (type === ITERATE_ENTRIES && (v = v[1]), depth && !(stack.length < depth) || !isIterable(v)) return useKeys ? step :iteratorValue(type, iterations++, v, step);
stack.push(iterator), iterator = v.__iterator(type, reverse);
} else iterator = stack.pop();
}
return iteratorDone();
});
}, flatSequence;
}
function flatMapFactory(iterable, mapper, context) {
var coerce = iterableClass(iterable);
return iterable.toSeq().map(function(v, k) {
return coerce(mapper.call(context, v, k, iterable));
}).flatten(!0);
}
function interposeFactory(iterable, separator) {
var interposedSequence = makeSequence(iterable);
return interposedSequence.size = iterable.size && 2 * iterable.size - 1, interposedSequence.__iterateUncached = function(fn, reverse) {
var this$0 = this, iterations = 0;
return iterable.__iterate(function(v) {
return (!iterations || fn(separator, iterations++, this$0) !== !1) && fn(v, iterations++, this$0) !== !1;
}, reverse), iterations;
}, interposedSequence.__iteratorUncached = function(type, reverse) {
var step, iterator = iterable.__iterator(ITERATE_VALUES, reverse), iterations = 0;
return new src_Iterator__Iterator(function() {
return (!step || iterations % 2) && (step = iterator.next(), step.done) ? step :iterations % 2 ? iteratorValue(type, iterations++, separator) :iteratorValue(type, iterations++, step.value, step);
});
}, interposedSequence;
}
function sortFactory(iterable, comparator, mapper) {
comparator || (comparator = defaultComparator);
var isKeyedIterable = isKeyed(iterable), index = 0, entries = iterable.toSeq().map(function(v, k) {
return [ k, v, index++, mapper ? mapper(v, k, iterable) :v ];
}).toArray();
return entries.sort(function(a, b) {
return comparator(a[3], b[3]) || a[2] - b[2];
}).forEach(isKeyedIterable ? function(v, i) {
entries[i].length = 2;
} :function(v, i) {
entries[i] = v[1];
}), isKeyedIterable ? KeyedSeq(entries) :isIndexed(iterable) ? IndexedSeq(entries) :SetSeq(entries);
}
function maxFactory(iterable, comparator, mapper) {
if (comparator || (comparator = defaultComparator), mapper) {
var entry = iterable.toSeq().map(function(v, k) {
return [ v, mapper(v, k, iterable) ];
}).reduce(function(a, b) {
return maxCompare(comparator, a[1], b[1]) ? b :a;
});
return entry && entry[0];
}
return iterable.reduce(function(a, b) {
return maxCompare(comparator, a, b) ? b :a;
});
}
function maxCompare(comparator, a, b) {
var comp = comparator(b, a);
return 0 === comp && b !== a && (void 0 === b || null === b || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters) {
var zipSequence = makeSequence(keyIter);
return zipSequence.size = new ArraySeq(iters).map(function(i) {
return i.size;
}).min(), zipSequence.__iterate = function(fn, reverse) {
for (var step, iterator = this.__iterator(ITERATE_VALUES, reverse), iterations = 0; !(step = iterator.next()).done && fn(step.value, iterations++, this) !== !1; ) ;
return iterations;
}, zipSequence.__iteratorUncached = function(type, reverse) {
var iterators = iters.map(function(i) {
return i = Iterable(i), getIterator(reverse ? i.reverse() :i);
}), iterations = 0, isDone = !1;
return new src_Iterator__Iterator(function() {
var steps;
return isDone || (steps = iterators.map(function(i) {
return i.next();
}), isDone = steps.some(function(s) {
return s.done;
})), isDone ? iteratorDone() :iteratorValue(type, iterations++, zipper.apply(null, steps.map(function(s) {
return s.value;
})));
});
}, zipSequence;
}
function reify(iter, seq) {
return isSeq(iter) ? seq :iter.constructor(seq);
}
function validateEntry(entry) {
if (entry !== Object(entry)) throw new TypeError("Expected [K, V] tuple: " + entry);
}
function resolveSize(iter) {
return assertNotInfinite(iter.size), ensureSize(iter);
}
function iterableClass(iterable) {
return isKeyed(iterable) ? KeyedIterable :isIndexed(iterable) ? IndexedIterable :SetIterable;
}
function makeSequence(iterable) {
return Object.create((isKeyed(iterable) ? KeyedSeq :isIndexed(iterable) ? IndexedSeq :SetSeq).prototype);
}
function cacheResultThrough() {
return this._iter.cacheResult ? (this._iter.cacheResult(), this.size = this._iter.size, 
this) :Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
return a > b ? 1 :b > a ? -1 :0;
}
function forceIterator(keyPath) {
var iter = getIterator(keyPath);
if (!iter) {
if (!isArrayLike(keyPath)) throw new TypeError("Expected iterable or array-like: " + keyPath);
iter = getIterator(Iterable(keyPath));
}
return iter;
}
function src_Map__Map(value) {
return null === value || void 0 === value ? emptyMap() :isMap(value) ? value :emptyMap().withMutations(function(map) {
var iter = KeyedIterable(value);
assertNotInfinite(iter.size), iter.forEach(function(v, k) {
return map.set(k, v);
});
});
}
function isMap(maybeMap) {
return !(!maybeMap || !maybeMap[IS_MAP_SENTINEL]);
}
function ArrayMapNode(ownerID, entries) {
this.ownerID = ownerID, this.entries = entries;
}
function BitmapIndexedNode(ownerID, bitmap, nodes) {
this.ownerID = ownerID, this.bitmap = bitmap, this.nodes = nodes;
}
function HashArrayMapNode(ownerID, count, nodes) {
this.ownerID = ownerID, this.count = count, this.nodes = nodes;
}
function HashCollisionNode(ownerID, keyHash, entries) {
this.ownerID = ownerID, this.keyHash = keyHash, this.entries = entries;
}
function ValueNode(ownerID, keyHash, entry) {
this.ownerID = ownerID, this.keyHash = keyHash, this.entry = entry;
}
function MapIterator(map, type, reverse) {
this._type = type, this._reverse = reverse, this._stack = map._root && mapIteratorFrame(map._root);
}
function mapIteratorValue(type, entry) {
return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
return {
node:node,
index:0,
__prev:prev
};
}
function makeMap(size, root, ownerID, hash) {
var map = Object.create(MapPrototype);
return map.size = size, map._root = root, map.__ownerID = ownerID, map.__hash = hash, 
map.__altered = !1, map;
}
function emptyMap() {
return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map, k, v) {
var newRoot, newSize;
if (map._root) {
var didChangeSize = MakeRef(CHANGE_LENGTH), didAlter = MakeRef(DID_ALTER);
if (newRoot = updateNode(map._root, map.__ownerID, 0, void 0, k, v, didChangeSize, didAlter), 
!didAlter.value) return map;
newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 :1 :0);
} else {
if (v === NOT_SET) return map;
newSize = 1, newRoot = new ArrayMapNode(map.__ownerID, [ [ k, v ] ]);
}
return map.__ownerID ? (map.size = newSize, map._root = newRoot, map.__hash = void 0, 
map.__altered = !0, map) :newRoot ? makeMap(newSize, newRoot) :emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
return node ? node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) :value === NOT_SET ? node :(SetRef(didAlter), 
SetRef(didChangeSize), new ValueNode(ownerID, keyHash, [ key, value ]));
}
function isLeafNode(node) {
return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
if (node.keyHash === keyHash) return new HashCollisionNode(ownerID, keyHash, [ node.entry, entry ]);
var newNode, idx1 = (0 === shift ? node.keyHash :node.keyHash >>> shift) & MASK, idx2 = (0 === shift ? keyHash :keyHash >>> shift) & MASK, nodes = idx1 === idx2 ? [ mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry) ] :(newNode = new ValueNode(ownerID, keyHash, entry), 
idx2 > idx1 ? [ node, newNode ] :[ newNode, node ]);
return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
ownerID || (ownerID = new OwnerID());
for (var node = new ValueNode(ownerID, hash(key), [ key, value ]), ii = 0; ii < entries.length; ii++) {
var entry = entries[ii];
node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
}
return node;
}
function packNodes(ownerID, nodes, count, excluding) {
for (var bitmap = 0, packedII = 0, packedNodes = new Array(count), ii = 0, bit = 1, len = nodes.length; len > ii; ii++, 
bit <<= 1) {
var node = nodes[ii];
void 0 !== node && ii !== excluding && (bitmap |= bit, packedNodes[packedII++] = node);
}
return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
for (var count = 0, expandedNodes = new Array(SIZE), ii = 0; 0 !== bitmap; ii++, 
bitmap >>>= 1) expandedNodes[ii] = 1 & bitmap ? nodes[count++] :void 0;
return expandedNodes[including] = node, new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}
function mergeIntoMapWith(map, merger, iterables) {
for (var iters = [], ii = 0; ii < iterables.length; ii++) {
var value = iterables[ii], iter = KeyedIterable(value);
isIterable(value) || (iter = iter.map(function(v) {
return fromJS(v);
})), iters.push(iter);
}
return mergeIntoCollectionWith(map, merger, iters);
}
function deepMerger(merger) {
return function(existing, value) {
return existing && existing.mergeDeepWith && isIterable(value) ? existing.mergeDeepWith(merger, value) :merger ? merger(existing, value) :value;
};
}
function mergeIntoCollectionWith(collection, merger, iters) {
return iters = iters.filter(function(x) {
return 0 !== x.size;
}), 0 === iters.length ? collection :0 === collection.size && 1 === iters.length ? collection.constructor(iters[0]) :collection.withMutations(function(collection) {
for (var mergeIntoMap = merger ? function(value, key) {
collection.update(key, NOT_SET, function(existing) {
return existing === NOT_SET ? value :merger(existing, value);
});
} :function(value, key) {
collection.set(key, value);
}, ii = 0; ii < iters.length; ii++) iters[ii].forEach(mergeIntoMap);
});
}
function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
var isNotSet = existing === NOT_SET, step = keyPathIter.next();
if (step.done) {
var existingValue = isNotSet ? notSetValue :existing, newValue = updater(existingValue);
return newValue === existingValue ? existing :newValue;
}
invariant(isNotSet || existing && existing.set, "invalid keyPath");
var key = step.value, nextExisting = isNotSet ? NOT_SET :existing.get(key, NOT_SET), nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
return nextUpdated === nextExisting ? existing :nextUpdated === NOT_SET ? existing.remove(key) :(isNotSet ? emptyMap() :existing).set(key, nextUpdated);
}
function popCount(x) {
return x -= x >> 1 & 1431655765, x = (858993459 & x) + (x >> 2 & 858993459), x = x + (x >> 4) & 252645135, 
x += x >> 8, x += x >> 16, 127 & x;
}
function setIn(array, idx, val, canEdit) {
var newArray = canEdit ? array :arrCopy(array);
return newArray[idx] = val, newArray;
}
function spliceIn(array, idx, val, canEdit) {
var newLen = array.length + 1;
if (canEdit && idx + 1 === newLen) return array[idx] = val, array;
for (var newArray = new Array(newLen), after = 0, ii = 0; newLen > ii; ii++) ii === idx ? (newArray[ii] = val, 
after = -1) :newArray[ii] = array[ii + after];
return newArray;
}
function spliceOut(array, idx, canEdit) {
var newLen = array.length - 1;
if (canEdit && idx === newLen) return array.pop(), array;
for (var newArray = new Array(newLen), after = 0, ii = 0; newLen > ii; ii++) ii === idx && (after = 1), 
newArray[ii] = array[ii + after];
return newArray;
}
function List(value) {
var empty = emptyList();
if (null === value || void 0 === value) return empty;
if (isList(value)) return value;
var iter = IndexedIterable(value), size = iter.size;
return 0 === size ? empty :(assertNotInfinite(size), size > 0 && SIZE > size ? makeList(0, size, SHIFT, null, new VNode(iter.toArray())) :empty.withMutations(function(list) {
list.setSize(size), iter.forEach(function(v, i) {
return list.set(i, v);
});
}));
}
function isList(maybeList) {
return !(!maybeList || !maybeList[IS_LIST_SENTINEL]);
}
function VNode(array, ownerID) {
this.array = array, this.ownerID = ownerID;
}
function iterateList(list, reverse) {
function iterateNodeOrLeaf(node, level, offset) {
return 0 === level ? iterateLeaf(node, offset) :iterateNode(node, level, offset);
}
function iterateLeaf(node, offset) {
var array = offset === tailPos ? tail && tail.array :node && node.array, from = offset > left ? 0 :left - offset, to = right - offset;
return to > SIZE && (to = SIZE), function() {
if (from === to) return DONE;
var idx = reverse ? --to :from++;
return array && array[idx];
};
}
function iterateNode(node, level, offset) {
var values, array = node && node.array, from = offset > left ? 0 :left - offset >> level, to = (right - offset >> level) + 1;
return to > SIZE && (to = SIZE), function() {
for (;;) {
if (values) {
var value = values();
if (value !== DONE) return value;
values = null;
}
if (from === to) return DONE;
var idx = reverse ? --to :from++;
values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
}
};
}
var left = list._origin, right = list._capacity, tailPos = getTailOffset(right), tail = list._tail;
return iterateNodeOrLeaf(list._root, list._level, 0);
}
function makeList(origin, capacity, level, root, tail, ownerID, hash) {
var list = Object.create(ListPrototype);
return list.size = capacity - origin, list._origin = origin, list._capacity = capacity, 
list._level = level, list._root = root, list._tail = tail, list.__ownerID = ownerID, 
list.__hash = hash, list.__altered = !1, list;
}
function emptyList() {
return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index, value) {
if (index = wrapIndex(list, index), index >= list.size || 0 > index) return list.withMutations(function(list) {
0 > index ? setListBounds(list, index).set(0, value) :setListBounds(list, 0, index + 1).set(index, value);
});
index += list._origin;
var newTail = list._tail, newRoot = list._root, didAlter = MakeRef(DID_ALTER);
return index >= getTailOffset(list._capacity) ? newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter) :newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter), 
didAlter.value ? list.__ownerID ? (list._root = newRoot, list._tail = newTail, list.__hash = void 0, 
list.__altered = !0, list) :makeList(list._origin, list._capacity, list._level, newRoot, newTail) :list;
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
var idx = index >>> level & MASK, nodeHas = node && idx < node.array.length;
if (!nodeHas && void 0 === value) return node;
var newNode;
if (level > 0) {
var lowerNode = node && node.array[idx], newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
return newLowerNode === lowerNode ? node :(newNode = editableVNode(node, ownerID), 
newNode.array[idx] = newLowerNode, newNode);
}
return nodeHas && node.array[idx] === value ? node :(SetRef(didAlter), newNode = editableVNode(node, ownerID), 
void 0 === value && idx === newNode.array.length - 1 ? newNode.array.pop() :newNode.array[idx] = value, 
newNode);
}
function editableVNode(node, ownerID) {
return ownerID && node && ownerID === node.ownerID ? node :new VNode(node ? node.array.slice() :[], ownerID);
}
function listNodeFor(list, rawIndex) {
if (rawIndex >= getTailOffset(list._capacity)) return list._tail;
if (rawIndex < 1 << list._level + SHIFT) {
for (var node = list._root, level = list._level; node && level > 0; ) node = node.array[rawIndex >>> level & MASK], 
level -= SHIFT;
return node;
}
}
function setListBounds(list, begin, end) {
var owner = list.__ownerID || new OwnerID(), oldOrigin = list._origin, oldCapacity = list._capacity, newOrigin = oldOrigin + begin, newCapacity = void 0 === end ? oldCapacity :0 > end ? oldCapacity + end :oldOrigin + end;
if (newOrigin === oldOrigin && newCapacity === oldCapacity) return list;
if (newOrigin >= newCapacity) return list.clear();
for (var newLevel = list._level, newRoot = list._root, offsetShift = 0; 0 > newOrigin + offsetShift; ) newRoot = new VNode(newRoot && newRoot.array.length ? [ void 0, newRoot ] :[], owner), 
newLevel += SHIFT, offsetShift += 1 << newLevel;
offsetShift && (newOrigin += offsetShift, oldOrigin += offsetShift, newCapacity += offsetShift, 
oldCapacity += offsetShift);
for (var oldTailOffset = getTailOffset(oldCapacity), newTailOffset = getTailOffset(newCapacity); newTailOffset >= 1 << newLevel + SHIFT; ) newRoot = new VNode(newRoot && newRoot.array.length ? [ newRoot ] :[], owner), 
newLevel += SHIFT;
var oldTail = list._tail, newTail = oldTailOffset > newTailOffset ? listNodeFor(list, newCapacity - 1) :newTailOffset > oldTailOffset ? new VNode([], owner) :oldTail;
if (oldTail && newTailOffset > oldTailOffset && oldCapacity > newOrigin && oldTail.array.length) {
newRoot = editableVNode(newRoot, owner);
for (var node = newRoot, level = newLevel; level > SHIFT; level -= SHIFT) {
var idx = oldTailOffset >>> level & MASK;
node = node.array[idx] = editableVNode(node.array[idx], owner);
}
node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
}
if (oldCapacity > newCapacity && (newTail = newTail && newTail.removeAfter(owner, 0, newCapacity)), 
newOrigin >= newTailOffset) newOrigin -= newTailOffset, newCapacity -= newTailOffset, 
newLevel = SHIFT, newRoot = null, newTail = newTail && newTail.removeBefore(owner, 0, newOrigin); else if (newOrigin > oldOrigin || oldTailOffset > newTailOffset) {
for (offsetShift = 0; newRoot; ) {
var beginIndex = newOrigin >>> newLevel & MASK;
if (beginIndex !== newTailOffset >>> newLevel & MASK) break;
beginIndex && (offsetShift += (1 << newLevel) * beginIndex), newLevel -= SHIFT, 
newRoot = newRoot.array[beginIndex];
}
newRoot && newOrigin > oldOrigin && (newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift)), 
newRoot && oldTailOffset > newTailOffset && (newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift)), 
offsetShift && (newOrigin -= offsetShift, newCapacity -= offsetShift);
}
return list.__ownerID ? (list.size = newCapacity - newOrigin, list._origin = newOrigin, 
list._capacity = newCapacity, list._level = newLevel, list._root = newRoot, list._tail = newTail, 
list.__hash = void 0, list.__altered = !0, list) :makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function mergeIntoListWith(list, merger, iterables) {
for (var iters = [], maxSize = 0, ii = 0; ii < iterables.length; ii++) {
var value = iterables[ii], iter = IndexedIterable(value);
iter.size > maxSize && (maxSize = iter.size), isIterable(value) || (iter = iter.map(function(v) {
return fromJS(v);
})), iters.push(iter);
}
return maxSize > list.size && (list = list.setSize(maxSize)), mergeIntoCollectionWith(list, merger, iters);
}
function getTailOffset(size) {
return SIZE > size ? 0 :size - 1 >>> SHIFT << SHIFT;
}
function OrderedMap(value) {
return null === value || void 0 === value ? emptyOrderedMap() :isOrderedMap(value) ? value :emptyOrderedMap().withMutations(function(map) {
var iter = KeyedIterable(value);
assertNotInfinite(iter.size), iter.forEach(function(v, k) {
return map.set(k, v);
});
});
}
function isOrderedMap(maybeOrderedMap) {
return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function makeOrderedMap(map, list, ownerID, hash) {
var omap = Object.create(OrderedMap.prototype);
return omap.size = map ? map.size :0, omap._map = map, omap._list = list, omap.__ownerID = ownerID, 
omap.__hash = hash, omap;
}
function emptyOrderedMap() {
return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
var newMap, newList, map = omap._map, list = omap._list, i = map.get(k), has = void 0 !== i;
if (v === NOT_SET) {
if (!has) return omap;
list.size >= SIZE && list.size >= 2 * map.size ? (newList = list.filter(function(entry, idx) {
return void 0 !== entry && i !== idx;
}), newMap = newList.toKeyedSeq().map(function(entry) {
return entry[0];
}).flip().toMap(), omap.__ownerID && (newMap.__ownerID = newList.__ownerID = omap.__ownerID)) :(newMap = map.remove(k), 
newList = i === list.size - 1 ? list.pop() :list.set(i, void 0));
} else if (has) {
if (v === list.get(i)[1]) return omap;
newMap = map, newList = list.set(i, [ k, v ]);
} else newMap = map.set(k, list.size), newList = list.set(list.size, [ k, v ]);
return omap.__ownerID ? (omap.size = newMap.size, omap._map = newMap, omap._list = newList, 
omap.__hash = void 0, omap) :makeOrderedMap(newMap, newList);
}
function Stack(value) {
return null === value || void 0 === value ? emptyStack() :isStack(value) ? value :emptyStack().unshiftAll(value);
}
function isStack(maybeStack) {
return !(!maybeStack || !maybeStack[IS_STACK_SENTINEL]);
}
function makeStack(size, head, ownerID, hash) {
var map = Object.create(StackPrototype);
return map.size = size, map._head = head, map.__ownerID = ownerID, map.__hash = hash, 
map.__altered = !1, map;
}
function emptyStack() {
return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
function src_Set__Set(value) {
return null === value || void 0 === value ? emptySet() :isSet(value) ? value :emptySet().withMutations(function(set) {
var iter = SetIterable(value);
assertNotInfinite(iter.size), iter.forEach(function(v) {
return set.add(v);
});
});
}
function isSet(maybeSet) {
return !(!maybeSet || !maybeSet[IS_SET_SENTINEL]);
}
function updateSet(set, newMap) {
return set.__ownerID ? (set.size = newMap.size, set._map = newMap, set) :newMap === set._map ? set :0 === newMap.size ? set.__empty() :set.__make(newMap);
}
function makeSet(map, ownerID) {
var set = Object.create(SetPrototype);
return set.size = map ? map.size :0, set._map = map, set.__ownerID = ownerID, set;
}
function emptySet() {
return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
function OrderedSet(value) {
return null === value || void 0 === value ? emptyOrderedSet() :isOrderedSet(value) ? value :emptyOrderedSet().withMutations(function(set) {
var iter = SetIterable(value);
assertNotInfinite(iter.size), iter.forEach(function(v) {
return set.add(v);
});
});
}
function isOrderedSet(maybeOrderedSet) {
return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function makeOrderedSet(map, ownerID) {
var set = Object.create(OrderedSetPrototype);
return set.size = map ? map.size :0, set._map = map, set.__ownerID = ownerID, set;
}
function emptyOrderedSet() {
return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function Record(defaultValues, name) {
var RecordType = function(values) {
return this instanceof RecordType ? (this._map = src_Map__Map(values), void 0) :new RecordType(values);
}, keys = Object.keys(defaultValues), RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
RecordTypePrototype.constructor = RecordType, name && (RecordTypePrototype._name = name), 
RecordTypePrototype._defaultValues = defaultValues, RecordTypePrototype._keys = keys, 
RecordTypePrototype.size = keys.length;
try {
keys.forEach(function(key) {
Object.defineProperty(RecordType.prototype, key, {
get:function() {
return this.get(key);
},
set:function(value) {
invariant(this.__ownerID, "Cannot set on an immutable record."), this.set(key, value);
}
});
});
} catch (error) {}
return RecordType;
}
function makeRecord(likeRecord, map, ownerID) {
var record = Object.create(Object.getPrototypeOf(likeRecord));
return record._map = map, record.__ownerID = ownerID, record;
}
function recordName(record) {
return record._name || record.constructor.name;
}
function deepEqual(a, b) {
if (a === b) return !0;
if (!isIterable(b) || void 0 !== a.size && void 0 !== b.size && a.size !== b.size || void 0 !== a.__hash && void 0 !== b.__hash && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) return !1;
if (0 === a.size && 0 === b.size) return !0;
var notAssociative = !isAssociative(a);
if (isOrdered(a)) {
var entries = a.entries();
return b.every(function(v, k) {
var entry = entries.next().value;
return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
}) && entries.next().done;
}
var flipped = !1;
if (void 0 === a.size) if (void 0 === b.size) a.cacheResult(); else {
flipped = !0;
var _ = a;
a = b, b = _;
}
var allEqual = !0, bSize = b.__iterate(function(v, k) {
return (notAssociative ? a.has(v) :flipped ? is(v, a.get(k, NOT_SET)) :is(a.get(k, NOT_SET), v)) ? void 0 :(allEqual = !1, 
!1);
});
return allEqual && a.size === bSize;
}
function Range(start, end, step) {
if (!(this instanceof Range)) return new Range(start, end, step);
if (invariant(0 !== step, "Cannot step a Range by 0"), start = start || 0, void 0 === end && (end = 1/0), 
step = void 0 === step ? 1 :Math.abs(step), start > end && (step = -step), this._start = start, 
this._end = end, this._step = step, this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1), 
0 === this.size) {
if (EMPTY_RANGE) return EMPTY_RANGE;
EMPTY_RANGE = this;
}
}
function Repeat(value, times) {
if (!(this instanceof Repeat)) return new Repeat(value, times);
if (this._value = value, this.size = void 0 === times ? 1/0 :Math.max(0, times), 
0 === this.size) {
if (EMPTY_REPEAT) return EMPTY_REPEAT;
EMPTY_REPEAT = this;
}
}
function mixin(ctor, methods) {
var keyCopier = function(key) {
ctor.prototype[key] = methods[key];
};
return Object.keys(methods).forEach(keyCopier), Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier), 
ctor;
}
function keyMapper(v, k) {
return k;
}
function entryMapper(v, k) {
return [ k, v ];
}
function not(predicate) {
return function() {
return !predicate.apply(this, arguments);
};
}
function neg(predicate) {
return function() {
return -predicate.apply(this, arguments);
};
}
function quoteString(value) {
return "string" == typeof value ? JSON.stringify(value) :value;
}
function defaultZipper() {
return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
return b > a ? 1 :a > b ? -1 :0;
}
function hashIterable(iterable) {
if (1/0 === iterable.size) return 0;
var ordered = isOrdered(iterable), keyed = isKeyed(iterable), h = ordered ? 1 :0, size = iterable.__iterate(keyed ? ordered ? function(v, k) {
h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
} :function(v, k) {
h = h + hashMerge(hash(v), hash(k)) | 0;
} :ordered ? function(v) {
h = 31 * h + hash(v) | 0;
} :function(v) {
h = h + hash(v) | 0;
});
return murmurHashOfSize(size, h);
}
function murmurHashOfSize(size, h) {
return h = src_Math__imul(h, 3432918353), h = src_Math__imul(h << 15 | h >>> -15, 461845907), 
h = src_Math__imul(h << 13 | h >>> -13, 5), h = (h + 3864292196 | 0) ^ size, h = src_Math__imul(h ^ h >>> 16, 2246822507), 
h = src_Math__imul(h ^ h >>> 13, 3266489909), h = smi(h ^ h >>> 16);
}
function hashMerge(a, b) {
return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
}
var SLICE$0 = Array.prototype.slice, DELETE = "delete", SHIFT = 5, SIZE = 1 << SHIFT, MASK = SIZE - 1, NOT_SET = {}, CHANGE_LENGTH = {
value:!1
}, DID_ALTER = {
value:!1
};
createClass(KeyedIterable, Iterable), createClass(IndexedIterable, Iterable), createClass(SetIterable, Iterable), 
Iterable.isIterable = isIterable, Iterable.isKeyed = isKeyed, Iterable.isIndexed = isIndexed, 
Iterable.isAssociative = isAssociative, Iterable.isOrdered = isOrdered, Iterable.Keyed = KeyedIterable, 
Iterable.Indexed = IndexedIterable, Iterable.Set = SetIterable;
var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", ITERATE_KEYS = 0, ITERATE_VALUES = 1, ITERATE_ENTRIES = 2, REAL_ITERATOR_SYMBOL = "function" == typeof Symbol && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator", ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
src_Iterator__Iterator.prototype.toString = function() {
return "[Iterator]";
}, src_Iterator__Iterator.KEYS = ITERATE_KEYS, src_Iterator__Iterator.VALUES = ITERATE_VALUES, 
src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES, src_Iterator__Iterator.prototype.inspect = src_Iterator__Iterator.prototype.toSource = function() {
return this.toString();
}, src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function() {
return this;
}, createClass(Seq, Iterable), Seq.of = function() {
return Seq(arguments);
}, Seq.prototype.toSeq = function() {
return this;
}, Seq.prototype.toString = function() {
return this.__toString("Seq {", "}");
}, Seq.prototype.cacheResult = function() {
return !this._cache && this.__iterateUncached && (this._cache = this.entrySeq().toArray(), 
this.size = this._cache.length), this;
}, Seq.prototype.__iterate = function(fn, reverse) {
return seqIterate(this, fn, reverse, !0);
}, Seq.prototype.__iterator = function(type, reverse) {
return seqIterator(this, type, reverse, !0);
}, createClass(KeyedSeq, Seq), KeyedSeq.prototype.toKeyedSeq = function() {
return this;
}, createClass(IndexedSeq, Seq), IndexedSeq.of = function() {
return IndexedSeq(arguments);
}, IndexedSeq.prototype.toIndexedSeq = function() {
return this;
}, IndexedSeq.prototype.toString = function() {
return this.__toString("Seq [", "]");
}, IndexedSeq.prototype.__iterate = function(fn, reverse) {
return seqIterate(this, fn, reverse, !1);
}, IndexedSeq.prototype.__iterator = function(type, reverse) {
return seqIterator(this, type, reverse, !1);
}, createClass(SetSeq, Seq), SetSeq.of = function() {
return SetSeq(arguments);
}, SetSeq.prototype.toSetSeq = function() {
return this;
}, Seq.isSeq = isSeq, Seq.Keyed = KeyedSeq, Seq.Set = SetSeq, Seq.Indexed = IndexedSeq;
var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
Seq.prototype[IS_SEQ_SENTINEL] = !0, createClass(ArraySeq, IndexedSeq), ArraySeq.prototype.get = function(index, notSetValue) {
return this.has(index) ? this._array[wrapIndex(this, index)] :notSetValue;
}, ArraySeq.prototype.__iterate = function(fn, reverse) {
for (var array = this._array, maxIndex = array.length - 1, ii = 0; maxIndex >= ii; ii++) if (fn(array[reverse ? maxIndex - ii :ii], ii, this) === !1) return ii + 1;
return ii;
}, ArraySeq.prototype.__iterator = function(type, reverse) {
var array = this._array, maxIndex = array.length - 1, ii = 0;
return new src_Iterator__Iterator(function() {
return ii > maxIndex ? iteratorDone() :iteratorValue(type, ii, array[reverse ? maxIndex - ii++ :ii++]);
});
}, createClass(ObjectSeq, KeyedSeq), ObjectSeq.prototype.get = function(key, notSetValue) {
return void 0 === notSetValue || this.has(key) ? this._object[key] :notSetValue;
}, ObjectSeq.prototype.has = function(key) {
return this._object.hasOwnProperty(key);
}, ObjectSeq.prototype.__iterate = function(fn, reverse) {
for (var object = this._object, keys = this._keys, maxIndex = keys.length - 1, ii = 0; maxIndex >= ii; ii++) {
var key = keys[reverse ? maxIndex - ii :ii];
if (fn(object[key], key, this) === !1) return ii + 1;
}
return ii;
}, ObjectSeq.prototype.__iterator = function(type, reverse) {
var object = this._object, keys = this._keys, maxIndex = keys.length - 1, ii = 0;
return new src_Iterator__Iterator(function() {
var key = keys[reverse ? maxIndex - ii :ii];
return ii++ > maxIndex ? iteratorDone() :iteratorValue(type, key, object[key]);
});
}, ObjectSeq.prototype[IS_ORDERED_SENTINEL] = !0, createClass(IterableSeq, IndexedSeq), 
IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
if (reverse) return this.cacheResult().__iterate(fn, reverse);
var iterable = this._iterable, iterator = getIterator(iterable), iterations = 0;
if (isIterator(iterator)) for (var step; !(step = iterator.next()).done && fn(step.value, iterations++, this) !== !1; ) ;
return iterations;
}, IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
if (reverse) return this.cacheResult().__iterator(type, reverse);
var iterable = this._iterable, iterator = getIterator(iterable);
if (!isIterator(iterator)) return new src_Iterator__Iterator(iteratorDone);
var iterations = 0;
return new src_Iterator__Iterator(function() {
var step = iterator.next();
return step.done ? step :iteratorValue(type, iterations++, step.value);
});
}, createClass(IteratorSeq, IndexedSeq), IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
if (reverse) return this.cacheResult().__iterate(fn, reverse);
for (var iterator = this._iterator, cache = this._iteratorCache, iterations = 0; iterations < cache.length; ) if (fn(cache[iterations], iterations++, this) === !1) return iterations;
for (var step; !(step = iterator.next()).done; ) {
var val = step.value;
if (cache[iterations] = val, fn(val, iterations++, this) === !1) break;
}
return iterations;
}, IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
if (reverse) return this.cacheResult().__iterator(type, reverse);
var iterator = this._iterator, cache = this._iteratorCache, iterations = 0;
return new src_Iterator__Iterator(function() {
if (iterations >= cache.length) {
var step = iterator.next();
if (step.done) return step;
cache[iterations] = step.value;
}
return iteratorValue(type, iterations, cache[iterations++]);
});
};
var EMPTY_SEQ;
createClass(Collection, Iterable), createClass(KeyedCollection, Collection), createClass(IndexedCollection, Collection), 
createClass(SetCollection, Collection), Collection.Keyed = KeyedCollection, Collection.Indexed = IndexedCollection, 
Collection.Set = SetCollection;
var src_Math__imul = "function" == typeof Math.imul && -2 === Math.imul(4294967295, 2) ? Math.imul :function(a, b) {
a = 0 | a, b = 0 | b;
var c = 65535 & a, d = 65535 & b;
return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
}, canDefineProperty = function() {
try {
return Object.defineProperty({}, "@", {}), !0;
} catch (e) {
return !1;
}
}(), weakMap = "function" == typeof WeakMap && new WeakMap(), objHashUID = 0, UID_HASH_KEY = "__immutablehash__";
"function" == typeof Symbol && (UID_HASH_KEY = Symbol(UID_HASH_KEY));
var STRING_HASH_CACHE_MIN_STRLEN = 16, STRING_HASH_CACHE_MAX_SIZE = 255, STRING_HASH_CACHE_SIZE = 0, stringHashCache = {};
createClass(ToKeyedSequence, KeyedSeq), ToKeyedSequence.prototype.get = function(key, notSetValue) {
return this._iter.get(key, notSetValue);
}, ToKeyedSequence.prototype.has = function(key) {
return this._iter.has(key);
}, ToKeyedSequence.prototype.valueSeq = function() {
return this._iter.valueSeq();
}, ToKeyedSequence.prototype.reverse = function() {
var this$0 = this, reversedSequence = reverseFactory(this, !0);
return this._useKeys || (reversedSequence.valueSeq = function() {
return this$0._iter.toSeq().reverse();
}), reversedSequence;
}, ToKeyedSequence.prototype.map = function(mapper, context) {
var this$0 = this, mappedSequence = mapFactory(this, mapper, context);
return this._useKeys || (mappedSequence.valueSeq = function() {
return this$0._iter.toSeq().map(mapper, context);
}), mappedSequence;
}, ToKeyedSequence.prototype.__iterate = function(fn, reverse) {
var ii, this$0 = this;
return this._iter.__iterate(this._useKeys ? function(v, k) {
return fn(v, k, this$0);
} :(ii = reverse ? resolveSize(this) :0, function(v) {
return fn(v, reverse ? --ii :ii++, this$0);
}), reverse);
}, ToKeyedSequence.prototype.__iterator = function(type, reverse) {
if (this._useKeys) return this._iter.__iterator(type, reverse);
var iterator = this._iter.__iterator(ITERATE_VALUES, reverse), ii = reverse ? resolveSize(this) :0;
return new src_Iterator__Iterator(function() {
var step = iterator.next();
return step.done ? step :iteratorValue(type, reverse ? --ii :ii++, step.value, step);
});
}, ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = !0, createClass(ToIndexedSequence, IndexedSeq), 
ToIndexedSequence.prototype.contains = function(value) {
return this._iter.contains(value);
}, ToIndexedSequence.prototype.__iterate = function(fn, reverse) {
var this$0 = this, iterations = 0;
return this._iter.__iterate(function(v) {
return fn(v, iterations++, this$0);
}, reverse);
}, ToIndexedSequence.prototype.__iterator = function(type, reverse) {
var iterator = this._iter.__iterator(ITERATE_VALUES, reverse), iterations = 0;
return new src_Iterator__Iterator(function() {
var step = iterator.next();
return step.done ? step :iteratorValue(type, iterations++, step.value, step);
});
}, createClass(ToSetSequence, SetSeq), ToSetSequence.prototype.has = function(key) {
return this._iter.contains(key);
}, ToSetSequence.prototype.__iterate = function(fn, reverse) {
var this$0 = this;
return this._iter.__iterate(function(v) {
return fn(v, v, this$0);
}, reverse);
}, ToSetSequence.prototype.__iterator = function(type, reverse) {
var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
return new src_Iterator__Iterator(function() {
var step = iterator.next();
return step.done ? step :iteratorValue(type, step.value, step.value, step);
});
}, createClass(FromEntriesSequence, KeyedSeq), FromEntriesSequence.prototype.entrySeq = function() {
return this._iter.toSeq();
}, FromEntriesSequence.prototype.__iterate = function(fn, reverse) {
var this$0 = this;
return this._iter.__iterate(function(entry) {
return entry ? (validateEntry(entry), fn(entry[1], entry[0], this$0)) :void 0;
}, reverse);
}, FromEntriesSequence.prototype.__iterator = function(type, reverse) {
var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
return new src_Iterator__Iterator(function() {
for (;;) {
var step = iterator.next();
if (step.done) return step;
var entry = step.value;
if (entry) return validateEntry(entry), type === ITERATE_ENTRIES ? step :iteratorValue(type, entry[0], entry[1], step);
}
});
}, ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough, 
createClass(src_Map__Map, KeyedCollection), src_Map__Map.prototype.toString = function() {
return this.__toString("Map {", "}");
}, src_Map__Map.prototype.get = function(k, notSetValue) {
return this._root ? this._root.get(0, void 0, k, notSetValue) :notSetValue;
}, src_Map__Map.prototype.set = function(k, v) {
return updateMap(this, k, v);
}, src_Map__Map.prototype.setIn = function(keyPath, v) {
return this.updateIn(keyPath, NOT_SET, function() {
return v;
});
}, src_Map__Map.prototype.remove = function(k) {
return updateMap(this, k, NOT_SET);
}, src_Map__Map.prototype.deleteIn = function(keyPath) {
return this.updateIn(keyPath, function() {
return NOT_SET;
});
}, src_Map__Map.prototype.update = function(k, notSetValue, updater) {
return 1 === arguments.length ? k(this) :this.updateIn([ k ], notSetValue, updater);
}, src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
updater || (updater = notSetValue, notSetValue = void 0);
var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
return updatedValue === NOT_SET ? void 0 :updatedValue;
}, src_Map__Map.prototype.clear = function() {
return 0 === this.size ? this :this.__ownerID ? (this.size = 0, this._root = null, 
this.__hash = void 0, this.__altered = !0, this) :emptyMap();
}, src_Map__Map.prototype.merge = function() {
return mergeIntoMapWith(this, void 0, arguments);
}, src_Map__Map.prototype.mergeWith = function(merger) {
var iters = SLICE$0.call(arguments, 1);
return mergeIntoMapWith(this, merger, iters);
}, src_Map__Map.prototype.mergeIn = function(keyPath) {
var iters = SLICE$0.call(arguments, 1);
return this.updateIn(keyPath, emptyMap(), function(m) {
return m.merge.apply(m, iters);
});
}, src_Map__Map.prototype.mergeDeep = function() {
return mergeIntoMapWith(this, deepMerger(void 0), arguments);
}, src_Map__Map.prototype.mergeDeepWith = function(merger) {
var iters = SLICE$0.call(arguments, 1);
return mergeIntoMapWith(this, deepMerger(merger), iters);
}, src_Map__Map.prototype.mergeDeepIn = function(keyPath) {
var iters = SLICE$0.call(arguments, 1);
return this.updateIn(keyPath, emptyMap(), function(m) {
return m.mergeDeep.apply(m, iters);
});
}, src_Map__Map.prototype.sort = function(comparator) {
return OrderedMap(sortFactory(this, comparator));
}, src_Map__Map.prototype.sortBy = function(mapper, comparator) {
return OrderedMap(sortFactory(this, comparator, mapper));
}, src_Map__Map.prototype.withMutations = function(fn) {
var mutable = this.asMutable();
return fn(mutable), mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) :this;
}, src_Map__Map.prototype.asMutable = function() {
return this.__ownerID ? this :this.__ensureOwner(new OwnerID());
}, src_Map__Map.prototype.asImmutable = function() {
return this.__ensureOwner();
}, src_Map__Map.prototype.wasAltered = function() {
return this.__altered;
}, src_Map__Map.prototype.__iterator = function(type, reverse) {
return new MapIterator(this, type, reverse);
}, src_Map__Map.prototype.__iterate = function(fn, reverse) {
var this$0 = this, iterations = 0;
return this._root && this._root.iterate(function(entry) {
return iterations++, fn(entry[1], entry[0], this$0);
}, reverse), iterations;
}, src_Map__Map.prototype.__ensureOwner = function(ownerID) {
return ownerID === this.__ownerID ? this :ownerID ? makeMap(this.size, this._root, ownerID, this.__hash) :(this.__ownerID = ownerID, 
this.__altered = !1, this);
}, src_Map__Map.isMap = isMap;
var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", MapPrototype = src_Map__Map.prototype;
MapPrototype[IS_MAP_SENTINEL] = !0, MapPrototype[DELETE] = MapPrototype.remove, 
MapPrototype.removeIn = MapPrototype.deleteIn, ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
for (var entries = this.entries, ii = 0, len = entries.length; len > ii; ii++) if (is(key, entries[ii][0])) return entries[ii][1];
return notSetValue;
}, ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
for (var removed = value === NOT_SET, entries = this.entries, idx = 0, len = entries.length; len > idx && !is(key, entries[idx][0]); idx++) ;
var exists = len > idx;
if (exists ? entries[idx][1] === value :removed) return this;
if (SetRef(didAlter), (removed || !exists) && SetRef(didChangeSize), !removed || 1 !== entries.length) {
if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) return createNodes(ownerID, entries, key, value);
var isEditable = ownerID && ownerID === this.ownerID, newEntries = isEditable ? entries :arrCopy(entries);
return exists ? removed ? idx === len - 1 ? newEntries.pop() :newEntries[idx] = newEntries.pop() :newEntries[idx] = [ key, value ] :newEntries.push([ key, value ]), 
isEditable ? (this.entries = newEntries, this) :new ArrayMapNode(ownerID, newEntries);
}
}, BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
void 0 === keyHash && (keyHash = hash(key));
var bit = 1 << ((0 === shift ? keyHash :keyHash >>> shift) & MASK), bitmap = this.bitmap;
return 0 === (bitmap & bit) ? notSetValue :this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
}, BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
void 0 === keyHash && (keyHash = hash(key));
var keyHashFrag = (0 === shift ? keyHash :keyHash >>> shift) & MASK, bit = 1 << keyHashFrag, bitmap = this.bitmap, exists = 0 !== (bitmap & bit);
if (!exists && value === NOT_SET) return this;
var idx = popCount(bitmap & bit - 1), nodes = this.nodes, node = exists ? nodes[idx] :void 0, newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
if (newNode === node) return this;
if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
if (exists && !newNode && 2 === nodes.length && isLeafNode(nodes[1 ^ idx])) return nodes[1 ^ idx];
if (exists && newNode && 1 === nodes.length && isLeafNode(newNode)) return newNode;
var isEditable = ownerID && ownerID === this.ownerID, newBitmap = exists ? newNode ? bitmap :bitmap ^ bit :bitmap | bit, newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) :spliceOut(nodes, idx, isEditable) :spliceIn(nodes, idx, newNode, isEditable);
return isEditable ? (this.bitmap = newBitmap, this.nodes = newNodes, this) :new BitmapIndexedNode(ownerID, newBitmap, newNodes);
}, HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
void 0 === keyHash && (keyHash = hash(key));
var idx = (0 === shift ? keyHash :keyHash >>> shift) & MASK, node = this.nodes[idx];
return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) :notSetValue;
}, HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
void 0 === keyHash && (keyHash = hash(key));
var idx = (0 === shift ? keyHash :keyHash >>> shift) & MASK, removed = value === NOT_SET, nodes = this.nodes, node = nodes[idx];
if (removed && !node) return this;
var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
if (newNode === node) return this;
var newCount = this.count;
if (node) {
if (!newNode && (newCount--, MIN_HASH_ARRAY_MAP_SIZE > newCount)) return packNodes(ownerID, nodes, newCount, idx);
} else newCount++;
var isEditable = ownerID && ownerID === this.ownerID, newNodes = setIn(nodes, idx, newNode, isEditable);
return isEditable ? (this.count = newCount, this.nodes = newNodes, this) :new HashArrayMapNode(ownerID, newCount, newNodes);
}, HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
for (var entries = this.entries, ii = 0, len = entries.length; len > ii; ii++) if (is(key, entries[ii][0])) return entries[ii][1];
return notSetValue;
}, HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
void 0 === keyHash && (keyHash = hash(key));
var removed = value === NOT_SET;
if (keyHash !== this.keyHash) return removed ? this :(SetRef(didAlter), SetRef(didChangeSize), 
mergeIntoNode(this, ownerID, shift, keyHash, [ key, value ]));
for (var entries = this.entries, idx = 0, len = entries.length; len > idx && !is(key, entries[idx][0]); idx++) ;
var exists = len > idx;
if (exists ? entries[idx][1] === value :removed) return this;
if (SetRef(didAlter), (removed || !exists) && SetRef(didChangeSize), removed && 2 === len) return new ValueNode(ownerID, this.keyHash, entries[1 ^ idx]);
var isEditable = ownerID && ownerID === this.ownerID, newEntries = isEditable ? entries :arrCopy(entries);
return exists ? removed ? idx === len - 1 ? newEntries.pop() :newEntries[idx] = newEntries.pop() :newEntries[idx] = [ key, value ] :newEntries.push([ key, value ]), 
isEditable ? (this.entries = newEntries, this) :new HashCollisionNode(ownerID, this.keyHash, newEntries);
}, ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
return is(key, this.entry[0]) ? this.entry[1] :notSetValue;
}, ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
var removed = value === NOT_SET, keyMatch = is(key, this.entry[0]);
return (keyMatch ? value === this.entry[1] :removed) ? this :(SetRef(didAlter), 
removed ? (SetRef(didChangeSize), void 0) :keyMatch ? ownerID && ownerID === this.ownerID ? (this.entry[1] = value, 
this) :new ValueNode(ownerID, this.keyHash, [ key, value ]) :(SetRef(didChangeSize), 
mergeIntoNode(this, ownerID, shift, hash(key), [ key, value ])));
}, ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {
for (var entries = this.entries, ii = 0, maxIndex = entries.length - 1; maxIndex >= ii; ii++) if (fn(entries[reverse ? maxIndex - ii :ii]) === !1) return !1;
}, BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {
for (var nodes = this.nodes, ii = 0, maxIndex = nodes.length - 1; maxIndex >= ii; ii++) {
var node = nodes[reverse ? maxIndex - ii :ii];
if (node && node.iterate(fn, reverse) === !1) return !1;
}
}, ValueNode.prototype.iterate = function(fn) {
return fn(this.entry);
}, createClass(MapIterator, src_Iterator__Iterator), MapIterator.prototype.next = function() {
for (var type = this._type, stack = this._stack; stack; ) {
var maxIndex, node = stack.node, index = stack.index++;
if (node.entry) {
if (0 === index) return mapIteratorValue(type, node.entry);
} else if (node.entries) {
if (maxIndex = node.entries.length - 1, maxIndex >= index) return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index :index]);
} else if (maxIndex = node.nodes.length - 1, maxIndex >= index) {
var subNode = node.nodes[this._reverse ? maxIndex - index :index];
if (subNode) {
if (subNode.entry) return mapIteratorValue(type, subNode.entry);
stack = this._stack = mapIteratorFrame(subNode, stack);
}
continue;
}
stack = this._stack = this._stack.__prev;
}
return iteratorDone();
};
var EMPTY_MAP, MAX_ARRAY_MAP_SIZE = SIZE / 4, MAX_BITMAP_INDEXED_SIZE = SIZE / 2, MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
createClass(List, IndexedCollection), List.of = function() {
return this(arguments);
}, List.prototype.toString = function() {
return this.__toString("List [", "]");
}, List.prototype.get = function(index, notSetValue) {
if (index = wrapIndex(this, index), 0 > index || index >= this.size) return notSetValue;
index += this._origin;
var node = listNodeFor(this, index);
return node && node.array[index & MASK];
}, List.prototype.set = function(index, value) {
return updateList(this, index, value);
}, List.prototype.remove = function(index) {
return this.has(index) ? 0 === index ? this.shift() :index === this.size - 1 ? this.pop() :this.splice(index, 1) :this;
}, List.prototype.clear = function() {
return 0 === this.size ? this :this.__ownerID ? (this.size = this._origin = this._capacity = 0, 
this._level = SHIFT, this._root = this._tail = null, this.__hash = void 0, this.__altered = !0, 
this) :emptyList();
}, List.prototype.push = function() {
var values = arguments, oldSize = this.size;
return this.withMutations(function(list) {
setListBounds(list, 0, oldSize + values.length);
for (var ii = 0; ii < values.length; ii++) list.set(oldSize + ii, values[ii]);
});
}, List.prototype.pop = function() {
return setListBounds(this, 0, -1);
}, List.prototype.unshift = function() {
var values = arguments;
return this.withMutations(function(list) {
setListBounds(list, -values.length);
for (var ii = 0; ii < values.length; ii++) list.set(ii, values[ii]);
});
}, List.prototype.shift = function() {
return setListBounds(this, 1);
}, List.prototype.merge = function() {
return mergeIntoListWith(this, void 0, arguments);
}, List.prototype.mergeWith = function(merger) {
var iters = SLICE$0.call(arguments, 1);
return mergeIntoListWith(this, merger, iters);
}, List.prototype.mergeDeep = function() {
return mergeIntoListWith(this, deepMerger(void 0), arguments);
}, List.prototype.mergeDeepWith = function(merger) {
var iters = SLICE$0.call(arguments, 1);
return mergeIntoListWith(this, deepMerger(merger), iters);
}, List.prototype.setSize = function(size) {
return setListBounds(this, 0, size);
}, List.prototype.slice = function(begin, end) {
var size = this.size;
return wholeSlice(begin, end, size) ? this :setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
}, List.prototype.__iterator = function(type, reverse) {
var index = 0, values = iterateList(this, reverse);
return new src_Iterator__Iterator(function() {
var value = values();
return value === DONE ? iteratorDone() :iteratorValue(type, index++, value);
});
}, List.prototype.__iterate = function(fn, reverse) {
for (var value, index = 0, values = iterateList(this, reverse); (value = values()) !== DONE && fn(value, index++, this) !== !1; ) ;
return index;
}, List.prototype.__ensureOwner = function(ownerID) {
return ownerID === this.__ownerID ? this :ownerID ? makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash) :(this.__ownerID = ownerID, 
this);
}, List.isList = isList;
var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", ListPrototype = List.prototype;
ListPrototype[IS_LIST_SENTINEL] = !0, ListPrototype[DELETE] = ListPrototype.remove, 
ListPrototype.setIn = MapPrototype.setIn, ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn, 
ListPrototype.update = MapPrototype.update, ListPrototype.updateIn = MapPrototype.updateIn, 
ListPrototype.mergeIn = MapPrototype.mergeIn, ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn, 
ListPrototype.withMutations = MapPrototype.withMutations, ListPrototype.asMutable = MapPrototype.asMutable, 
ListPrototype.asImmutable = MapPrototype.asImmutable, ListPrototype.wasAltered = MapPrototype.wasAltered, 
VNode.prototype.removeBefore = function(ownerID, level, index) {
if (index === level ? 1 << level :0 || 0 === this.array.length) return this;
var originIndex = index >>> level & MASK;
if (originIndex >= this.array.length) return new VNode([], ownerID);
var newChild, removingFirst = 0 === originIndex;
if (level > 0) {
var oldChild = this.array[originIndex];
if (newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index), 
newChild === oldChild && removingFirst) return this;
}
if (removingFirst && !newChild) return this;
var editable = editableVNode(this, ownerID);
if (!removingFirst) for (var ii = 0; originIndex > ii; ii++) editable.array[ii] = void 0;
return newChild && (editable.array[originIndex] = newChild), editable;
}, VNode.prototype.removeAfter = function(ownerID, level, index) {
if (index === level ? 1 << level :0 || 0 === this.array.length) return this;
var sizeIndex = index - 1 >>> level & MASK;
if (sizeIndex >= this.array.length) return this;
var newChild, removingLast = sizeIndex === this.array.length - 1;
if (level > 0) {
var oldChild = this.array[sizeIndex];
if (newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index), 
newChild === oldChild && removingLast) return this;
}
if (removingLast && !newChild) return this;
var editable = editableVNode(this, ownerID);
return removingLast || editable.array.pop(), newChild && (editable.array[sizeIndex] = newChild), 
editable;
};
var EMPTY_LIST, DONE = {};
createClass(OrderedMap, src_Map__Map), OrderedMap.of = function() {
return this(arguments);
}, OrderedMap.prototype.toString = function() {
return this.__toString("OrderedMap {", "}");
}, OrderedMap.prototype.get = function(k, notSetValue) {
var index = this._map.get(k);
return void 0 !== index ? this._list.get(index)[1] :notSetValue;
}, OrderedMap.prototype.clear = function() {
return 0 === this.size ? this :this.__ownerID ? (this.size = 0, this._map.clear(), 
this._list.clear(), this) :emptyOrderedMap();
}, OrderedMap.prototype.set = function(k, v) {
return updateOrderedMap(this, k, v);
}, OrderedMap.prototype.remove = function(k) {
return updateOrderedMap(this, k, NOT_SET);
}, OrderedMap.prototype.wasAltered = function() {
return this._map.wasAltered() || this._list.wasAltered();
}, OrderedMap.prototype.__iterate = function(fn, reverse) {
var this$0 = this;
return this._list.__iterate(function(entry) {
return entry && fn(entry[1], entry[0], this$0);
}, reverse);
}, OrderedMap.prototype.__iterator = function(type, reverse) {
return this._list.fromEntrySeq().__iterator(type, reverse);
}, OrderedMap.prototype.__ensureOwner = function(ownerID) {
if (ownerID === this.__ownerID) return this;
var newMap = this._map.__ensureOwner(ownerID), newList = this._list.__ensureOwner(ownerID);
return ownerID ? makeOrderedMap(newMap, newList, ownerID, this.__hash) :(this.__ownerID = ownerID, 
this._map = newMap, this._list = newList, this);
}, OrderedMap.isOrderedMap = isOrderedMap, OrderedMap.prototype[IS_ORDERED_SENTINEL] = !0, 
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
var EMPTY_ORDERED_MAP;
createClass(Stack, IndexedCollection), Stack.of = function() {
return this(arguments);
}, Stack.prototype.toString = function() {
return this.__toString("Stack [", "]");
}, Stack.prototype.get = function(index, notSetValue) {
var head = this._head;
for (index = wrapIndex(this, index); head && index--; ) head = head.next;
return head ? head.value :notSetValue;
}, Stack.prototype.peek = function() {
return this._head && this._head.value;
}, Stack.prototype.push = function() {
if (0 === arguments.length) return this;
for (var newSize = this.size + arguments.length, head = this._head, ii = arguments.length - 1; ii >= 0; ii--) head = {
value:arguments[ii],
next:head
};
return this.__ownerID ? (this.size = newSize, this._head = head, this.__hash = void 0, 
this.__altered = !0, this) :makeStack(newSize, head);
}, Stack.prototype.pushAll = function(iter) {
if (iter = IndexedIterable(iter), 0 === iter.size) return this;
assertNotInfinite(iter.size);
var newSize = this.size, head = this._head;
return iter.reverse().forEach(function(value) {
newSize++, head = {
value:value,
next:head
};
}), this.__ownerID ? (this.size = newSize, this._head = head, this.__hash = void 0, 
this.__altered = !0, this) :makeStack(newSize, head);
}, Stack.prototype.pop = function() {
return this.slice(1);
}, Stack.prototype.unshift = function() {
return this.push.apply(this, arguments);
}, Stack.prototype.unshiftAll = function(iter) {
return this.pushAll(iter);
}, Stack.prototype.shift = function() {
return this.pop.apply(this, arguments);
}, Stack.prototype.clear = function() {
return 0 === this.size ? this :this.__ownerID ? (this.size = 0, this._head = void 0, 
this.__hash = void 0, this.__altered = !0, this) :emptyStack();
}, Stack.prototype.slice = function(begin, end) {
if (wholeSlice(begin, end, this.size)) return this;
var resolvedBegin = resolveBegin(begin, this.size), resolvedEnd = resolveEnd(end, this.size);
if (resolvedEnd !== this.size) return IndexedCollection.prototype.slice.call(this, begin, end);
for (var newSize = this.size - resolvedBegin, head = this._head; resolvedBegin--; ) head = head.next;
return this.__ownerID ? (this.size = newSize, this._head = head, this.__hash = void 0, 
this.__altered = !0, this) :makeStack(newSize, head);
}, Stack.prototype.__ensureOwner = function(ownerID) {
return ownerID === this.__ownerID ? this :ownerID ? makeStack(this.size, this._head, ownerID, this.__hash) :(this.__ownerID = ownerID, 
this.__altered = !1, this);
}, Stack.prototype.__iterate = function(fn, reverse) {
if (reverse) return this.reverse().__iterate(fn);
for (var iterations = 0, node = this._head; node && fn(node.value, iterations++, this) !== !1; ) node = node.next;
return iterations;
}, Stack.prototype.__iterator = function(type, reverse) {
if (reverse) return this.reverse().__iterator(type);
var iterations = 0, node = this._head;
return new src_Iterator__Iterator(function() {
if (node) {
var value = node.value;
return node = node.next, iteratorValue(type, iterations++, value);
}
return iteratorDone();
});
}, Stack.isStack = isStack;
var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SENTINEL] = !0, StackPrototype.withMutations = MapPrototype.withMutations, 
StackPrototype.asMutable = MapPrototype.asMutable, StackPrototype.asImmutable = MapPrototype.asImmutable, 
StackPrototype.wasAltered = MapPrototype.wasAltered;
var EMPTY_STACK;
createClass(src_Set__Set, SetCollection), src_Set__Set.of = function() {
return this(arguments);
}, src_Set__Set.fromKeys = function(value) {
return this(KeyedIterable(value).keySeq());
}, src_Set__Set.prototype.toString = function() {
return this.__toString("Set {", "}");
}, src_Set__Set.prototype.has = function(value) {
return this._map.has(value);
}, src_Set__Set.prototype.add = function(value) {
return updateSet(this, this._map.set(value, !0));
}, src_Set__Set.prototype.remove = function(value) {
return updateSet(this, this._map.remove(value));
}, src_Set__Set.prototype.clear = function() {
return updateSet(this, this._map.clear());
}, src_Set__Set.prototype.union = function() {
var iters = SLICE$0.call(arguments, 0);
return iters = iters.filter(function(x) {
return 0 !== x.size;
}), 0 === iters.length ? this :0 === this.size && 1 === iters.length ? this.constructor(iters[0]) :this.withMutations(function(set) {
for (var ii = 0; ii < iters.length; ii++) SetIterable(iters[ii]).forEach(function(value) {
return set.add(value);
});
});
}, src_Set__Set.prototype.intersect = function() {
var iters = SLICE$0.call(arguments, 0);
if (0 === iters.length) return this;
iters = iters.map(function(iter) {
return SetIterable(iter);
});
var originalSet = this;
return this.withMutations(function(set) {
originalSet.forEach(function(value) {
iters.every(function(iter) {
return iter.contains(value);
}) || set.remove(value);
});
});
}, src_Set__Set.prototype.subtract = function() {
var iters = SLICE$0.call(arguments, 0);
if (0 === iters.length) return this;
iters = iters.map(function(iter) {
return SetIterable(iter);
});
var originalSet = this;
return this.withMutations(function(set) {
originalSet.forEach(function(value) {
iters.some(function(iter) {
return iter.contains(value);
}) && set.remove(value);
});
});
}, src_Set__Set.prototype.merge = function() {
return this.union.apply(this, arguments);
}, src_Set__Set.prototype.mergeWith = function() {
var iters = SLICE$0.call(arguments, 1);
return this.union.apply(this, iters);
}, src_Set__Set.prototype.sort = function(comparator) {
return OrderedSet(sortFactory(this, comparator));
}, src_Set__Set.prototype.sortBy = function(mapper, comparator) {
return OrderedSet(sortFactory(this, comparator, mapper));
}, src_Set__Set.prototype.wasAltered = function() {
return this._map.wasAltered();
}, src_Set__Set.prototype.__iterate = function(fn, reverse) {
var this$0 = this;
return this._map.__iterate(function(_, k) {
return fn(k, k, this$0);
}, reverse);
}, src_Set__Set.prototype.__iterator = function(type, reverse) {
return this._map.map(function(_, k) {
return k;
}).__iterator(type, reverse);
}, src_Set__Set.prototype.__ensureOwner = function(ownerID) {
if (ownerID === this.__ownerID) return this;
var newMap = this._map.__ensureOwner(ownerID);
return ownerID ? this.__make(newMap, ownerID) :(this.__ownerID = ownerID, this._map = newMap, 
this);
}, src_Set__Set.isSet = isSet;
var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", SetPrototype = src_Set__Set.prototype;
SetPrototype[IS_SET_SENTINEL] = !0, SetPrototype[DELETE] = SetPrototype.remove, 
SetPrototype.mergeDeep = SetPrototype.merge, SetPrototype.mergeDeepWith = SetPrototype.mergeWith, 
SetPrototype.withMutations = MapPrototype.withMutations, SetPrototype.asMutable = MapPrototype.asMutable, 
SetPrototype.asImmutable = MapPrototype.asImmutable, SetPrototype.__empty = emptySet, 
SetPrototype.__make = makeSet;
var EMPTY_SET;
createClass(OrderedSet, src_Set__Set), OrderedSet.of = function() {
return this(arguments);
}, OrderedSet.fromKeys = function(value) {
return this(KeyedIterable(value).keySeq());
}, OrderedSet.prototype.toString = function() {
return this.__toString("OrderedSet {", "}");
}, OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SENTINEL] = !0, OrderedSetPrototype.__empty = emptyOrderedSet, 
OrderedSetPrototype.__make = makeOrderedSet;
var EMPTY_ORDERED_SET;
createClass(Record, KeyedCollection), Record.prototype.toString = function() {
return this.__toString(recordName(this) + " {", "}");
}, Record.prototype.has = function(k) {
return this._defaultValues.hasOwnProperty(k);
}, Record.prototype.get = function(k, notSetValue) {
if (!this.has(k)) return notSetValue;
var defaultVal = this._defaultValues[k];
return this._map ? this._map.get(k, defaultVal) :defaultVal;
}, Record.prototype.clear = function() {
if (this.__ownerID) return this._map && this._map.clear(), this;
var SuperRecord = Object.getPrototypeOf(this).constructor;
return SuperRecord._empty || (SuperRecord._empty = makeRecord(this, emptyMap()));
}, Record.prototype.set = function(k, v) {
if (!this.has(k)) throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
var newMap = this._map && this._map.set(k, v);
return this.__ownerID || newMap === this._map ? this :makeRecord(this, newMap);
}, Record.prototype.remove = function(k) {
if (!this.has(k)) return this;
var newMap = this._map && this._map.remove(k);
return this.__ownerID || newMap === this._map ? this :makeRecord(this, newMap);
}, Record.prototype.wasAltered = function() {
return this._map.wasAltered();
}, Record.prototype.__iterator = function(type, reverse) {
var this$0 = this;
return KeyedIterable(this._defaultValues).map(function(_, k) {
return this$0.get(k);
}).__iterator(type, reverse);
}, Record.prototype.__iterate = function(fn, reverse) {
var this$0 = this;
return KeyedIterable(this._defaultValues).map(function(_, k) {
return this$0.get(k);
}).__iterate(fn, reverse);
}, Record.prototype.__ensureOwner = function(ownerID) {
if (ownerID === this.__ownerID) return this;
var newMap = this._map && this._map.__ensureOwner(ownerID);
return ownerID ? makeRecord(this, newMap, ownerID) :(this.__ownerID = ownerID, this._map = newMap, 
this);
};
var RecordPrototype = Record.prototype;
RecordPrototype[DELETE] = RecordPrototype.remove, RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn, 
RecordPrototype.merge = MapPrototype.merge, RecordPrototype.mergeWith = MapPrototype.mergeWith, 
RecordPrototype.mergeIn = MapPrototype.mergeIn, RecordPrototype.mergeDeep = MapPrototype.mergeDeep, 
RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith, RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn, 
RecordPrototype.setIn = MapPrototype.setIn, RecordPrototype.update = MapPrototype.update, 
RecordPrototype.updateIn = MapPrototype.updateIn, RecordPrototype.withMutations = MapPrototype.withMutations, 
RecordPrototype.asMutable = MapPrototype.asMutable, RecordPrototype.asImmutable = MapPrototype.asImmutable, 
createClass(Range, IndexedSeq), Range.prototype.toString = function() {
return 0 === this.size ? "Range []" :"Range [ " + this._start + "..." + this._end + (this._step > 1 ? " by " + this._step :"") + " ]";
}, Range.prototype.get = function(index, notSetValue) {
return this.has(index) ? this._start + wrapIndex(this, index) * this._step :notSetValue;
}, Range.prototype.contains = function(searchValue) {
var possibleIndex = (searchValue - this._start) / this._step;
return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
}, Range.prototype.slice = function(begin, end) {
return wholeSlice(begin, end, this.size) ? this :(begin = resolveBegin(begin, this.size), 
end = resolveEnd(end, this.size), begin >= end ? new Range(0, 0) :new Range(this.get(begin, this._end), this.get(end, this._end), this._step));
}, Range.prototype.indexOf = function(searchValue) {
var offsetValue = searchValue - this._start;
if (offsetValue % this._step === 0) {
var index = offsetValue / this._step;
if (index >= 0 && index < this.size) return index;
}
return -1;
}, Range.prototype.lastIndexOf = function(searchValue) {
return this.indexOf(searchValue);
}, Range.prototype.__iterate = function(fn, reverse) {
for (var maxIndex = this.size - 1, step = this._step, value = reverse ? this._start + maxIndex * step :this._start, ii = 0; maxIndex >= ii; ii++) {
if (fn(value, ii, this) === !1) return ii + 1;
value += reverse ? -step :step;
}
return ii;
}, Range.prototype.__iterator = function(type, reverse) {
var maxIndex = this.size - 1, step = this._step, value = reverse ? this._start + maxIndex * step :this._start, ii = 0;
return new src_Iterator__Iterator(function() {
var v = value;
return value += reverse ? -step :step, ii > maxIndex ? iteratorDone() :iteratorValue(type, ii++, v);
});
}, Range.prototype.equals = function(other) {
return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step :deepEqual(this, other);
};
var EMPTY_RANGE;
createClass(Repeat, IndexedSeq), Repeat.prototype.toString = function() {
return 0 === this.size ? "Repeat []" :"Repeat [ " + this._value + " " + this.size + " times ]";
}, Repeat.prototype.get = function(index, notSetValue) {
return this.has(index) ? this._value :notSetValue;
}, Repeat.prototype.contains = function(searchValue) {
return is(this._value, searchValue);
}, Repeat.prototype.slice = function(begin, end) {
var size = this.size;
return wholeSlice(begin, end, size) ? this :new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
}, Repeat.prototype.reverse = function() {
return this;
}, Repeat.prototype.indexOf = function(searchValue) {
return is(this._value, searchValue) ? 0 :-1;
}, Repeat.prototype.lastIndexOf = function(searchValue) {
return is(this._value, searchValue) ? this.size :-1;
}, Repeat.prototype.__iterate = function(fn) {
for (var ii = 0; ii < this.size; ii++) if (fn(this._value, ii, this) === !1) return ii + 1;
return ii;
}, Repeat.prototype.__iterator = function(type) {
var this$0 = this, ii = 0;
return new src_Iterator__Iterator(function() {
return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) :iteratorDone();
});
}, Repeat.prototype.equals = function(other) {
return other instanceof Repeat ? is(this._value, other._value) :deepEqual(other);
};
var EMPTY_REPEAT;
Iterable.Iterator = src_Iterator__Iterator, mixin(Iterable, {
toArray:function() {
assertNotInfinite(this.size);
var array = new Array(this.size || 0);
return this.valueSeq().__iterate(function(v, i) {
array[i] = v;
}), array;
},
toIndexedSeq:function() {
return new ToIndexedSequence(this);
},
toJS:function() {
return this.toSeq().map(function(value) {
return value && "function" == typeof value.toJS ? value.toJS() :value;
}).__toJS();
},
toJSON:function() {
return this.toSeq().map(function(value) {
return value && "function" == typeof value.toJSON ? value.toJSON() :value;
}).__toJS();
},
toKeyedSeq:function() {
return new ToKeyedSequence(this, !0);
},
toMap:function() {
return src_Map__Map(this.toKeyedSeq());
},
toObject:function() {
assertNotInfinite(this.size);
var object = {};
return this.__iterate(function(v, k) {
object[k] = v;
}), object;
},
toOrderedMap:function() {
return OrderedMap(this.toKeyedSeq());
},
toOrderedSet:function() {
return OrderedSet(isKeyed(this) ? this.valueSeq() :this);
},
toSet:function() {
return src_Set__Set(isKeyed(this) ? this.valueSeq() :this);
},
toSetSeq:function() {
return new ToSetSequence(this);
},
toSeq:function() {
return isIndexed(this) ? this.toIndexedSeq() :isKeyed(this) ? this.toKeyedSeq() :this.toSetSeq();
},
toStack:function() {
return Stack(isKeyed(this) ? this.valueSeq() :this);
},
toList:function() {
return List(isKeyed(this) ? this.valueSeq() :this);
},
toString:function() {
return "[Iterable]";
},
__toString:function(head, tail) {
return 0 === this.size ? head + tail :head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
},
concat:function() {
var values = SLICE$0.call(arguments, 0);
return reify(this, concatFactory(this, values));
},
contains:function(searchValue) {
return this.some(function(value) {
return is(value, searchValue);
});
},
entries:function() {
return this.__iterator(ITERATE_ENTRIES);
},
every:function(predicate, context) {
assertNotInfinite(this.size);
var returnValue = !0;
return this.__iterate(function(v, k, c) {
return predicate.call(context, v, k, c) ? void 0 :(returnValue = !1, !1);
}), returnValue;
},
filter:function(predicate, context) {
return reify(this, filterFactory(this, predicate, context, !0));
},
find:function(predicate, context, notSetValue) {
var entry = this.findEntry(predicate, context);
return entry ? entry[1] :notSetValue;
},
findEntry:function(predicate, context) {
var found;
return this.__iterate(function(v, k, c) {
return predicate.call(context, v, k, c) ? (found = [ k, v ], !1) :void 0;
}), found;
},
findLastEntry:function(predicate, context) {
return this.toSeq().reverse().findEntry(predicate, context);
},
forEach:function(sideEffect, context) {
return assertNotInfinite(this.size), this.__iterate(context ? sideEffect.bind(context) :sideEffect);
},
join:function(separator) {
assertNotInfinite(this.size), separator = void 0 !== separator ? "" + separator :",";
var joined = "", isFirst = !0;
return this.__iterate(function(v) {
isFirst ? isFirst = !1 :joined += separator, joined += null !== v && void 0 !== v ? v.toString() :"";
}), joined;
},
keys:function() {
return this.__iterator(ITERATE_KEYS);
},
map:function(mapper, context) {
return reify(this, mapFactory(this, mapper, context));
},
reduce:function(reducer, initialReduction, context) {
assertNotInfinite(this.size);
var reduction, useFirst;
return arguments.length < 2 ? useFirst = !0 :reduction = initialReduction, this.__iterate(function(v, k, c) {
useFirst ? (useFirst = !1, reduction = v) :reduction = reducer.call(context, reduction, v, k, c);
}), reduction;
},
reduceRight:function() {
var reversed = this.toKeyedSeq().reverse();
return reversed.reduce.apply(reversed, arguments);
},
reverse:function() {
return reify(this, reverseFactory(this, !0));
},
slice:function(begin, end) {
return reify(this, sliceFactory(this, begin, end, !0));
},
some:function(predicate, context) {
return !this.every(not(predicate), context);
},
sort:function(comparator) {
return reify(this, sortFactory(this, comparator));
},
values:function() {
return this.__iterator(ITERATE_VALUES);
},
butLast:function() {
return this.slice(0, -1);
},
isEmpty:function() {
return void 0 !== this.size ? 0 === this.size :!this.some(function() {
return !0;
});
},
count:function(predicate, context) {
return ensureSize(predicate ? this.toSeq().filter(predicate, context) :this);
},
countBy:function(grouper, context) {
return countByFactory(this, grouper, context);
},
equals:function(other) {
return deepEqual(this, other);
},
entrySeq:function() {
var iterable = this;
if (iterable._cache) return new ArraySeq(iterable._cache);
var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
return entriesSequence.fromEntrySeq = function() {
return iterable.toSeq();
}, entriesSequence;
},
filterNot:function(predicate, context) {
return this.filter(not(predicate), context);
},
findLast:function(predicate, context, notSetValue) {
return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
},
first:function() {
return this.find(returnTrue);
},
flatMap:function(mapper, context) {
return reify(this, flatMapFactory(this, mapper, context));
},
flatten:function(depth) {
return reify(this, flattenFactory(this, depth, !0));
},
fromEntrySeq:function() {
return new FromEntriesSequence(this);
},
get:function(searchKey, notSetValue) {
return this.find(function(_, key) {
return is(key, searchKey);
}, void 0, notSetValue);
},
getIn:function(searchKeyPath, notSetValue) {
for (var step, nested = this, iter = forceIterator(searchKeyPath); !(step = iter.next()).done; ) {
var key = step.value;
if (nested = nested && nested.get ? nested.get(key, NOT_SET) :NOT_SET, nested === NOT_SET) return notSetValue;
}
return nested;
},
groupBy:function(grouper, context) {
return groupByFactory(this, grouper, context);
},
has:function(searchKey) {
return this.get(searchKey, NOT_SET) !== NOT_SET;
},
hasIn:function(searchKeyPath) {
return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
},
isSubset:function(iter) {
return iter = "function" == typeof iter.contains ? iter :Iterable(iter), this.every(function(value) {
return iter.contains(value);
});
},
isSuperset:function(iter) {
return iter.isSubset(this);
},
keySeq:function() {
return this.toSeq().map(keyMapper).toIndexedSeq();
},
last:function() {
return this.toSeq().reverse().first();
},
max:function(comparator) {
return maxFactory(this, comparator);
},
maxBy:function(mapper, comparator) {
return maxFactory(this, comparator, mapper);
},
min:function(comparator) {
return maxFactory(this, comparator ? neg(comparator) :defaultNegComparator);
},
minBy:function(mapper, comparator) {
return maxFactory(this, comparator ? neg(comparator) :defaultNegComparator, mapper);
},
rest:function() {
return this.slice(1);
},
skip:function(amount) {
return this.slice(Math.max(0, amount));
},
skipLast:function(amount) {
return reify(this, this.toSeq().reverse().skip(amount).reverse());
},
skipWhile:function(predicate, context) {
return reify(this, skipWhileFactory(this, predicate, context, !0));
},
skipUntil:function(predicate, context) {
return this.skipWhile(not(predicate), context);
},
sortBy:function(mapper, comparator) {
return reify(this, sortFactory(this, comparator, mapper));
},
take:function(amount) {
return this.slice(0, Math.max(0, amount));
},
takeLast:function(amount) {
return reify(this, this.toSeq().reverse().take(amount).reverse());
},
takeWhile:function(predicate, context) {
return reify(this, takeWhileFactory(this, predicate, context));
},
takeUntil:function(predicate, context) {
return this.takeWhile(not(predicate), context);
},
valueSeq:function() {
return this.toIndexedSeq();
},
hashCode:function() {
return this.__hash || (this.__hash = hashIterable(this));
}
});
var IterablePrototype = Iterable.prototype;
IterablePrototype[IS_ITERABLE_SENTINEL] = !0, IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values, 
IterablePrototype.__toJS = IterablePrototype.toArray, IterablePrototype.__toStringMapper = quoteString, 
IterablePrototype.inspect = IterablePrototype.toSource = function() {
return this.toString();
}, IterablePrototype.chain = IterablePrototype.flatMap, function() {
try {
Object.defineProperty(IterablePrototype, "length", {
get:function() {
if (!Iterable.noLengthWarning) {
var stack;
try {
throw new Error();
} catch (error) {
stack = error.stack;
}
if (-1 === stack.indexOf("_wrapObject")) return console && console.warn && console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. " + stack), 
this.size;
}
}
});
} catch (e) {}
}(), mixin(KeyedIterable, {
flip:function() {
return reify(this, flipFactory(this));
},
findKey:function(predicate, context) {
var entry = this.findEntry(predicate, context);
return entry && entry[0];
},
findLastKey:function(predicate, context) {
return this.toSeq().reverse().findKey(predicate, context);
},
keyOf:function(searchValue) {
return this.findKey(function(value) {
return is(value, searchValue);
});
},
lastKeyOf:function(searchValue) {
return this.findLastKey(function(value) {
return is(value, searchValue);
});
},
mapEntries:function(mapper, context) {
var this$0 = this, iterations = 0;
return reify(this, this.toSeq().map(function(v, k) {
return mapper.call(context, [ k, v ], iterations++, this$0);
}).fromEntrySeq());
},
mapKeys:function(mapper, context) {
var this$0 = this;
return reify(this, this.toSeq().flip().map(function(k, v) {
return mapper.call(context, k, v, this$0);
}).flip());
}
});
var KeyedIterablePrototype = KeyedIterable.prototype;
KeyedIterablePrototype[IS_KEYED_SENTINEL] = !0, KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries, 
KeyedIterablePrototype.__toJS = IterablePrototype.toObject, KeyedIterablePrototype.__toStringMapper = function(v, k) {
return k + ": " + quoteString(v);
}, mixin(IndexedIterable, {
toKeyedSeq:function() {
return new ToKeyedSequence(this, !1);
},
filter:function(predicate, context) {
return reify(this, filterFactory(this, predicate, context, !1));
},
findIndex:function(predicate, context) {
var entry = this.findEntry(predicate, context);
return entry ? entry[0] :-1;
},
indexOf:function(searchValue) {
var key = this.toKeyedSeq().keyOf(searchValue);
return void 0 === key ? -1 :key;
},
lastIndexOf:function(searchValue) {
return this.toSeq().reverse().indexOf(searchValue);
},
reverse:function() {
return reify(this, reverseFactory(this, !1));
},
slice:function(begin, end) {
return reify(this, sliceFactory(this, begin, end, !1));
},
splice:function(index, removeNum) {
var numArgs = arguments.length;
if (removeNum = Math.max(0 | removeNum, 0), 0 === numArgs || 2 === numArgs && !removeNum) return this;
index = resolveBegin(index, this.size);
var spliced = this.slice(0, index);
return reify(this, 1 === numArgs ? spliced :spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
},
findLastIndex:function(predicate, context) {
var key = this.toKeyedSeq().findLastKey(predicate, context);
return void 0 === key ? -1 :key;
},
first:function() {
return this.get(0);
},
flatten:function(depth) {
return reify(this, flattenFactory(this, depth, !1));
},
get:function(index, notSetValue) {
return index = wrapIndex(this, index), 0 > index || 1/0 === this.size || void 0 !== this.size && index > this.size ? notSetValue :this.find(function(_, key) {
return key === index;
}, void 0, notSetValue);
},
has:function(index) {
return index = wrapIndex(this, index), index >= 0 && (void 0 !== this.size ? 1/0 === this.size || index < this.size :-1 !== this.indexOf(index));
},
interpose:function(separator) {
return reify(this, interposeFactory(this, separator));
},
interleave:function() {
var iterables = [ this ].concat(arrCopy(arguments)), zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables), interleaved = zipped.flatten(!0);
return zipped.size && (interleaved.size = zipped.size * iterables.length), reify(this, interleaved);
},
last:function() {
return this.get(-1);
},
skipWhile:function(predicate, context) {
return reify(this, skipWhileFactory(this, predicate, context, !1));
},
zip:function() {
var iterables = [ this ].concat(arrCopy(arguments));
return reify(this, zipWithFactory(this, defaultZipper, iterables));
},
zipWith:function(zipper) {
var iterables = arrCopy(arguments);
return iterables[0] = this, reify(this, zipWithFactory(this, zipper, iterables));
}
}), IndexedIterable.prototype[IS_INDEXED_SENTINEL] = !0, IndexedIterable.prototype[IS_ORDERED_SENTINEL] = !0, 
mixin(SetIterable, {
get:function(value, notSetValue) {
return this.has(value) ? value :notSetValue;
},
contains:function(value) {
return this.has(value);
},
keySeq:function() {
return this.valueSeq();
}
}), SetIterable.prototype.has = IterablePrototype.contains, mixin(KeyedSeq, KeyedIterable.prototype), 
mixin(IndexedSeq, IndexedIterable.prototype), mixin(SetSeq, SetIterable.prototype), 
mixin(KeyedCollection, KeyedIterable.prototype), mixin(IndexedCollection, IndexedIterable.prototype), 
mixin(SetCollection, SetIterable.prototype);
var Immutable = {
Iterable:Iterable,
Seq:Seq,
Collection:Collection,
Map:src_Map__Map,
OrderedMap:OrderedMap,
List:List,
Stack:Stack,
Set:src_Set__Set,
OrderedSet:OrderedSet,
Record:Record,
Range:Range,
Repeat:Repeat,
is:is,
fromJS:fromJS
};
return Immutable;
});
}, {} ],
2:[ function(require, module) {
function flatten(array, isDeep, guard) {
var length = array ? array.length :0;
return guard && isIterateeCall(array, isDeep, guard) && (isDeep = !1), length ? baseFlatten(array, isDeep, !1, 0) :[];
}
var baseFlatten = require("../internal/baseFlatten"), isIterateeCall = require("../internal/isIterateeCall");
module.exports = flatten;
}, {
"../internal/baseFlatten":13,
"../internal/isIterateeCall":31
} ],
3:[ function(require, module) {
function last(array) {
var length = array ? array.length :0;
return length ? array[length - 1] :undefined;
}
var undefined;
module.exports = last;
}, {} ],
4:[ function(require, module) {
function pull() {
var args = arguments, array = args[0];
if (!array || !array.length) return array;
for (var index = 0, indexOf = baseIndexOf, length = args.length; ++index < length; ) for (var fromIndex = 0, value = args[index]; (fromIndex = indexOf(array, value, fromIndex)) > -1; ) splice.call(array, fromIndex, 1);
return array;
}
var baseIndexOf = require("../internal/baseIndexOf"), arrayProto = Array.prototype, splice = arrayProto.splice;
module.exports = pull;
}, {
"../internal/baseIndexOf":17
} ],
5:[ function(require, module) {
var includes = require("./includes");
module.exports = includes;
}, {
"./includes":6
} ],
6:[ function(require, module) {
function includes(collection, target, fromIndex) {
var length = collection ? collection.length :0;
return isLength(length) || (collection = values(collection), length = collection.length), 
length ? (fromIndex = "number" == typeof fromIndex ? 0 > fromIndex ? nativeMax(length + fromIndex, 0) :fromIndex || 0 :0, 
"string" == typeof collection || !isArray(collection) && isString(collection) ? length > fromIndex && collection.indexOf(target, fromIndex) > -1 :baseIndexOf(collection, target, fromIndex) > -1) :!1;
}
var baseIndexOf = require("../internal/baseIndexOf"), isArray = require("../lang/isArray"), isLength = require("../internal/isLength"), isString = require("../lang/isString"), values = require("../object/values"), nativeMax = Math.max;
module.exports = includes;
}, {
"../internal/baseIndexOf":17,
"../internal/isLength":32,
"../lang/isArray":40,
"../lang/isString":44,
"../object/values":53
} ],
7:[ function(require, module) {
function arrayCopy(source, array) {
var index = -1, length = source.length;
for (array || (array = Array(length)); ++index < length; ) array[index] = source[index];
return array;
}
module.exports = arrayCopy;
}, {} ],
8:[ function(require, module) {
function arrayEach(array, iteratee) {
for (var index = -1, length = array.length; ++index < length && iteratee(array[index], index, array) !== !1; ) ;
return array;
}
module.exports = arrayEach;
}, {} ],
9:[ function(require, module) {
function assignDefaults(objectValue, sourceValue) {
return "undefined" == typeof objectValue ? sourceValue :objectValue;
}
module.exports = assignDefaults;
}, {} ],
10:[ function(require, module) {
function baseAssign(object, source, customizer) {
var props = keys(source);
if (!customizer) return baseCopy(source, object, props);
for (var index = -1, length = props.length; ++index < length; ) {
var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
(result === result ? result === value :value !== value) && ("undefined" != typeof value || key in object) || (object[key] = result);
}
return object;
}
var baseCopy = require("./baseCopy"), keys = require("../object/keys");
module.exports = baseAssign;
}, {
"../object/keys":50,
"./baseCopy":12
} ],
11:[ function(require, module) {
function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
var result;
if (customizer && (result = object ? customizer(value, key, object) :customizer(value)), 
"undefined" != typeof result) return result;
if (!isObject(value)) return value;
var isArr = isArray(value);
if (isArr) {
if (result = initCloneArray(value), !isDeep) return arrayCopy(value, result);
} else {
var tag = objToString.call(value), isFunc = tag == funcTag;
if (tag != objectTag && tag != argsTag && (!isFunc || object)) return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) :object ? value :{};
if (result = initCloneObject(isFunc ? {} :value), !isDeep) return baseCopy(value, result, keys(value));
}
stackA || (stackA = []), stackB || (stackB = []);
for (var length = stackA.length; length--; ) if (stackA[length] == value) return stackB[length];
return stackA.push(value), stackB.push(result), (isArr ? arrayEach :baseForOwn)(value, function(subValue, key) {
result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
}), result;
}
var arrayCopy = require("./arrayCopy"), arrayEach = require("./arrayEach"), baseCopy = require("./baseCopy"), baseForOwn = require("./baseForOwn"), initCloneArray = require("./initCloneArray"), initCloneByTag = require("./initCloneByTag"), initCloneObject = require("./initCloneObject"), isArray = require("../lang/isArray"), isObject = require("../lang/isObject"), keys = require("../object/keys"), argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, 
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = !1;
var objectProto = Object.prototype, objToString = objectProto.toString;
module.exports = baseClone;
}, {
"../lang/isArray":40,
"../lang/isObject":42,
"../object/keys":50,
"./arrayCopy":7,
"./arrayEach":8,
"./baseCopy":12,
"./baseForOwn":16,
"./initCloneArray":27,
"./initCloneByTag":28,
"./initCloneObject":29
} ],
12:[ function(require, module) {
function baseCopy(source, object, props) {
props || (props = object, object = {});
for (var index = -1, length = props.length; ++index < length; ) {
var key = props[index];
object[key] = source[key];
}
return object;
}
module.exports = baseCopy;
}, {} ],
13:[ function(require, module) {
function baseFlatten(array, isDeep, isStrict, fromIndex) {
for (var index = fromIndex - 1, length = array.length, resIndex = -1, result = []; ++index < length; ) {
var value = array[index];
if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
isDeep && (value = baseFlatten(value, isDeep, isStrict, 0));
var valIndex = -1, valLength = value.length;
for (result.length += valLength; ++valIndex < valLength; ) result[++resIndex] = value[valIndex];
} else isStrict || (result[++resIndex] = value);
}
return result;
}
var isArguments = require("../lang/isArguments"), isArray = require("../lang/isArray"), isLength = require("./isLength"), isObjectLike = require("./isObjectLike");
module.exports = baseFlatten;
}, {
"../lang/isArguments":39,
"../lang/isArray":40,
"./isLength":32,
"./isObjectLike":33
} ],
14:[ function(require, module) {
function baseFor(object, iteratee, keysFunc) {
for (var index = -1, iterable = toObject(object), props = keysFunc(object), length = props.length; ++index < length; ) {
var key = props[index];
if (iteratee(iterable[key], key, iterable) === !1) break;
}
return object;
}
var toObject = require("./toObject");
module.exports = baseFor;
}, {
"./toObject":37
} ],
15:[ function(require, module) {
function baseForIn(object, iteratee) {
return baseFor(object, iteratee, keysIn);
}
var baseFor = require("./baseFor"), keysIn = require("../object/keysIn");
module.exports = baseForIn;
}, {
"../object/keysIn":51,
"./baseFor":14
} ],
16:[ function(require, module) {
function baseForOwn(object, iteratee) {
return baseFor(object, iteratee, keys);
}
var baseFor = require("./baseFor"), keys = require("../object/keys");
module.exports = baseForOwn;
}, {
"../object/keys":50,
"./baseFor":14
} ],
17:[ function(require, module) {
function baseIndexOf(array, value, fromIndex) {
if (value !== value) return indexOfNaN(array, fromIndex);
for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
return -1;
}
var indexOfNaN = require("./indexOfNaN");
module.exports = baseIndexOf;
}, {
"./indexOfNaN":26
} ],
18:[ function(require, module) {
function baseMerge(object, source, customizer, stackA, stackB) {
if (!isObject(object)) return object;
var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
return (isSrcArr ? arrayEach :baseForOwn)(source, function(srcValue, key, source) {
if (isObjectLike(srcValue)) return stackA || (stackA = []), stackB || (stackB = []), 
baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) :undefined, isCommon = "undefined" == typeof result;
isCommon && (result = srcValue), !isSrcArr && "undefined" == typeof result || !isCommon && (result === result ? result === value :value !== value) || (object[key] = result);
}), object;
}
var undefined, arrayEach = require("./arrayEach"), baseForOwn = require("./baseForOwn"), baseMergeDeep = require("./baseMergeDeep"), isArray = require("../lang/isArray"), isLength = require("./isLength"), isObject = require("../lang/isObject"), isObjectLike = require("./isObjectLike"), isTypedArray = require("../lang/isTypedArray");
module.exports = baseMerge;
}, {
"../lang/isArray":40,
"../lang/isObject":42,
"../lang/isTypedArray":45,
"./arrayEach":8,
"./baseForOwn":16,
"./baseMergeDeep":19,
"./isLength":32,
"./isObjectLike":33
} ],
19:[ function(require, module) {
function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
for (var length = stackA.length, srcValue = source[key]; length--; ) if (stackA[length] == srcValue) return object[key] = stackB[length], 
void 0;
var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) :undefined, isCommon = "undefined" == typeof result;
isCommon && (result = srcValue, isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue)) ? result = isArray(value) ? value :value ? arrayCopy(value) :[] :isPlainObject(srcValue) || isArguments(srcValue) ? result = isArguments(value) ? toPlainObject(value) :isPlainObject(value) ? value :{} :isCommon = !1), 
stackA.push(srcValue), stackB.push(result), isCommon ? object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB) :(result === result ? result !== value :value === value) && (object[key] = result);
}
var undefined, arrayCopy = require("./arrayCopy"), isArguments = require("../lang/isArguments"), isArray = require("../lang/isArray"), isLength = require("./isLength"), isPlainObject = require("../lang/isPlainObject"), isTypedArray = require("../lang/isTypedArray"), toPlainObject = require("../lang/toPlainObject");
module.exports = baseMergeDeep;
}, {
"../lang/isArguments":39,
"../lang/isArray":40,
"../lang/isPlainObject":43,
"../lang/isTypedArray":45,
"../lang/toPlainObject":47,
"./arrayCopy":7,
"./isLength":32
} ],
20:[ function(require, module) {
function baseToString(value) {
return "string" == typeof value ? value :null == value ? "" :value + "";
}
module.exports = baseToString;
}, {} ],
21:[ function(require, module) {
function baseValues(object, props) {
for (var index = -1, length = props.length, result = Array(length); ++index < length; ) result[index] = object[props[index]];
return result;
}
module.exports = baseValues;
}, {} ],
22:[ function(require, module) {
function bindCallback(func, thisArg, argCount) {
if ("function" != typeof func) return identity;
if ("undefined" == typeof thisArg) return func;
switch (argCount) {
case 1:
return function(value) {
return func.call(thisArg, value);
};

case 3:
return function(value, index, collection) {
return func.call(thisArg, value, index, collection);
};

case 4:
return function(accumulator, value, index, collection) {
return func.call(thisArg, accumulator, value, index, collection);
};

case 5:
return function(value, other, key, object, source) {
return func.call(thisArg, value, other, key, object, source);
};
}
return function() {
return func.apply(thisArg, arguments);
};
}
var identity = require("../utility/identity");
module.exports = bindCallback;
}, {
"../utility/identity":58
} ],
23:[ function(require, module) {
function bufferClone(buffer) {
return bufferSlice.call(buffer, 0);
}
var constant = require("../utility/constant"), isNative = require("../lang/isNative"), root = require("./root"), ArrayBuffer = isNative(ArrayBuffer = root.ArrayBuffer) && ArrayBuffer, bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice, floor = Math.floor, Uint8Array = isNative(Uint8Array = root.Uint8Array) && Uint8Array, Float64Array = function() {
try {
var func = isNative(func = root.Float64Array) && func, result = new func(new ArrayBuffer(10), 0, 1) && func;
} catch (e) {}
return result;
}(), FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT :0;
bufferSlice || (bufferClone = ArrayBuffer && Uint8Array ? function(buffer) {
var byteLength = buffer.byteLength, floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) :0, offset = floatLength * FLOAT64_BYTES_PER_ELEMENT, result = new ArrayBuffer(byteLength);
if (floatLength) {
var view = new Float64Array(result, 0, floatLength);
view.set(new Float64Array(buffer, 0, floatLength));
}
return byteLength != offset && (view = new Uint8Array(result, offset), view.set(new Uint8Array(buffer, offset))), 
result;
} :constant(null)), module.exports = bufferClone;
}, {
"../lang/isNative":41,
"../utility/constant":57,
"./root":34
} ],
24:[ function(require, module) {
function createAssigner(assigner) {
return function() {
var args = arguments, length = args.length, object = args[0];
if (2 > length || null == object) return object;
var customizer = args[length - 2], thisArg = args[length - 1], guard = args[3];
length > 3 && "function" == typeof customizer ? (customizer = bindCallback(customizer, thisArg, 5), 
length -= 2) :(customizer = length > 2 && "function" == typeof thisArg ? thisArg :null, 
length -= customizer ? 1 :0), guard && isIterateeCall(args[1], args[2], guard) && (customizer = 3 == length ? null :customizer, 
length = 2);
for (var index = 0; ++index < length; ) {
var source = args[index];
source && assigner(object, source, customizer);
}
return object;
};
}
var bindCallback = require("./bindCallback"), isIterateeCall = require("./isIterateeCall");
module.exports = createAssigner;
}, {
"./bindCallback":22,
"./isIterateeCall":31
} ],
25:[ function(require, module) {
function escapeHtmlChar(chr) {
return htmlEscapes[chr];
}
var htmlEscapes = {
"&":"&amp;",
"<":"&lt;",
">":"&gt;",
'"':"&quot;",
"'":"&#39;",
"`":"&#96;"
};
module.exports = escapeHtmlChar;
}, {} ],
26:[ function(require, module) {
function indexOfNaN(array, fromIndex, fromRight) {
for (var length = array.length, index = fromIndex + (fromRight ? 0 :-1); fromRight ? index-- :++index < length; ) {
var other = array[index];
if (other !== other) return index;
}
return -1;
}
module.exports = indexOfNaN;
}, {} ],
27:[ function(require, module) {
function initCloneArray(array) {
var length = array.length, result = new array.constructor(length);
return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, 
result.input = array.input), result;
}
var objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
module.exports = initCloneArray;
}, {} ],
28:[ function(require, module) {
function initCloneByTag(object, tag, isDeep) {
var Ctor = object.constructor;
switch (tag) {
case arrayBufferTag:
return bufferClone(object);

case boolTag:
case dateTag:
return new Ctor(+object);

case float32Tag:
case float64Tag:
case int8Tag:
case int16Tag:
case int32Tag:
case uint8Tag:
case uint8ClampedTag:
case uint16Tag:
case uint32Tag:
var buffer = object.buffer;
return new Ctor(isDeep ? bufferClone(buffer) :buffer, object.byteOffset, object.length);

case numberTag:
case stringTag:
return new Ctor(object);

case regexpTag:
var result = new Ctor(object.source, reFlags.exec(object));
result.lastIndex = object.lastIndex;
}
return result;
}
var bufferClone = require("./bufferClone"), boolTag = "[object Boolean]", dateTag = "[object Date]", numberTag = "[object Number]", regexpTag = "[object RegExp]", stringTag = "[object String]", arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reFlags = /\w*$/;
module.exports = initCloneByTag;
}, {
"./bufferClone":23
} ],
29:[ function(require, module) {
function initCloneObject(object) {
var Ctor = object.constructor;
return "function" == typeof Ctor && Ctor instanceof Ctor || (Ctor = Object), new Ctor();
}
module.exports = initCloneObject;
}, {} ],
30:[ function(require, module) {
function isIndex(value, length) {
return value = +value, length = null == length ? MAX_SAFE_INTEGER :length, value > -1 && value % 1 == 0 && length > value;
}
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
module.exports = isIndex;
}, {} ],
31:[ function(require, module) {
function isIterateeCall(value, index, object) {
if (!isObject(object)) return !1;
var type = typeof index;
if ("number" == type) var length = object.length, prereq = isLength(length) && isIndex(index, length); else prereq = "string" == type && index in object;
if (prereq) {
var other = object[index];
return value === value ? value === other :other !== other;
}
return !1;
}
var isIndex = require("./isIndex"), isLength = require("./isLength"), isObject = require("../lang/isObject");
module.exports = isIterateeCall;
}, {
"../lang/isObject":42,
"./isIndex":30,
"./isLength":32
} ],
32:[ function(require, module) {
function isLength(value) {
return "number" == typeof value && value > -1 && value % 1 == 0 && MAX_SAFE_INTEGER >= value;
}
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
module.exports = isLength;
}, {} ],
33:[ function(require, module) {
function isObjectLike(value) {
return value && "object" == typeof value || !1;
}
module.exports = isObjectLike;
}, {} ],
34:[ function(require, module, exports) {
(function(global) {
var objectTypes = {
"function":!0,
object:!0
}, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, freeModule = objectTypes[typeof module] && module && !module.nodeType && module, freeGlobal = freeExports && freeModule && "object" == typeof global && global, freeWindow = objectTypes[typeof window] && window, root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || this;
module.exports = root;
}).call(this, "undefined" != typeof global ? global :"undefined" != typeof self ? self :"undefined" != typeof window ? window :{});
}, {} ],
35:[ function(require, module) {
function shimIsPlainObject(value) {
var Ctor;
if (!isObjectLike(value) || objToString.call(value) != objectTag || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, 
"function" == typeof Ctor && !(Ctor instanceof Ctor))) return !1;
var result;
return baseForIn(value, function(subValue, key) {
result = key;
}), "undefined" == typeof result || hasOwnProperty.call(value, result);
}
var baseForIn = require("./baseForIn"), isObjectLike = require("./isObjectLike"), objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, objToString = objectProto.toString;
module.exports = shimIsPlainObject;
}, {
"./baseForIn":15,
"./isObjectLike":33
} ],
36:[ function(require, module) {
function shimKeys(object) {
for (var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)), index = -1, result = []; ++index < propsLength; ) {
var key = props[index];
(allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) && result.push(key);
}
return result;
}
var isArguments = require("../lang/isArguments"), isArray = require("../lang/isArray"), isIndex = require("./isIndex"), isLength = require("./isLength"), keysIn = require("../object/keysIn"), support = require("../support"), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
module.exports = shimKeys;
}, {
"../lang/isArguments":39,
"../lang/isArray":40,
"../object/keysIn":51,
"../support":56,
"./isIndex":30,
"./isLength":32
} ],
37:[ function(require, module) {
function toObject(value) {
return isObject(value) ? value :Object(value);
}
var isObject = require("../lang/isObject");
module.exports = toObject;
}, {
"../lang/isObject":42
} ],
38:[ function(require, module) {
function cloneDeep(value, customizer, thisArg) {
return customizer = "function" == typeof customizer && bindCallback(customizer, thisArg, 1), 
baseClone(value, !0, customizer);
}
var baseClone = require("../internal/baseClone"), bindCallback = require("../internal/bindCallback");
module.exports = cloneDeep;
}, {
"../internal/baseClone":11,
"../internal/bindCallback":22
} ],
39:[ function(require, module) {
function isArguments(value) {
var length = isObjectLike(value) ? value.length :undefined;
return isLength(length) && objToString.call(value) == argsTag || !1;
}
var undefined, isLength = require("../internal/isLength"), isObjectLike = require("../internal/isObjectLike"), argsTag = "[object Arguments]", objectProto = Object.prototype, objToString = objectProto.toString;
module.exports = isArguments;
}, {
"../internal/isLength":32,
"../internal/isObjectLike":33
} ],
40:[ function(require, module) {
var isLength = require("../internal/isLength"), isNative = require("./isNative"), isObjectLike = require("../internal/isObjectLike"), arrayTag = "[object Array]", objectProto = Object.prototype, objToString = objectProto.toString, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, isArray = nativeIsArray || function(value) {
return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag || !1;
};
module.exports = isArray;
}, {
"../internal/isLength":32,
"../internal/isObjectLike":33,
"./isNative":41
} ],
41:[ function(require, module) {
function isNative(value) {
return null == value ? !1 :objToString.call(value) == funcTag ? reNative.test(fnToString.call(value)) :isObjectLike(value) && reHostCtor.test(value) || !1;
}
var escapeRegExp = require("../string/escapeRegExp"), isObjectLike = require("../internal/isObjectLike"), funcTag = "[object Function]", reHostCtor = /^\[object .+?Constructor\]$/, objectProto = Object.prototype, fnToString = Function.prototype.toString, objToString = objectProto.toString, reNative = RegExp("^" + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
module.exports = isNative;
}, {
"../internal/isObjectLike":33,
"../string/escapeRegExp":55
} ],
42:[ function(require, module) {
function isObject(value) {
var type = typeof value;
return "function" == type || value && "object" == type || !1;
}
module.exports = isObject;
}, {} ],
43:[ function(require, module) {
var isNative = require("./isNative"), shimIsPlainObject = require("../internal/shimIsPlainObject"), objectTag = "[object Object]", objectProto = Object.prototype, objToString = objectProto.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, isPlainObject = getPrototypeOf ? function(value) {
if (!value || objToString.call(value) != objectTag) return !1;
var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
return objProto ? value == objProto || getPrototypeOf(value) == objProto :shimIsPlainObject(value);
} :shimIsPlainObject;
module.exports = isPlainObject;
}, {
"../internal/shimIsPlainObject":35,
"./isNative":41
} ],
44:[ function(require, module) {
function isString(value) {
return "string" == typeof value || isObjectLike(value) && objToString.call(value) == stringTag || !1;
}
var isObjectLike = require("../internal/isObjectLike"), stringTag = "[object String]", objectProto = Object.prototype, objToString = objectProto.toString;
module.exports = isString;
}, {
"../internal/isObjectLike":33
} ],
45:[ function(require, module) {
function isTypedArray(value) {
return isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)] || !1;
}
var isLength = require("../internal/isLength"), isObjectLike = require("../internal/isObjectLike"), argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, 
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
var objectProto = Object.prototype, objToString = objectProto.toString;
module.exports = isTypedArray;
}, {
"../internal/isLength":32,
"../internal/isObjectLike":33
} ],
46:[ function(require, module) {
function toArray(value) {
var length = value ? value.length :0;
return isLength(length) ? length ? arrayCopy(value) :[] :values(value);
}
var arrayCopy = require("../internal/arrayCopy"), isLength = require("../internal/isLength"), values = require("../object/values");
module.exports = toArray;
}, {
"../internal/arrayCopy":7,
"../internal/isLength":32,
"../object/values":53
} ],
47:[ function(require, module) {
function toPlainObject(value) {
return baseCopy(value, keysIn(value));
}
var baseCopy = require("../internal/baseCopy"), keysIn = require("../object/keysIn");
module.exports = toPlainObject;
}, {
"../internal/baseCopy":12,
"../object/keysIn":51
} ],
48:[ function(require, module) {
var baseAssign = require("../internal/baseAssign"), createAssigner = require("../internal/createAssigner"), assign = createAssigner(baseAssign);
module.exports = assign;
}, {
"../internal/baseAssign":10,
"../internal/createAssigner":24
} ],
49:[ function(require, module) {
function defaults(object) {
if (null == object) return object;
var args = arrayCopy(arguments);
return args.push(assignDefaults), assign.apply(undefined, args);
}
var undefined, arrayCopy = require("../internal/arrayCopy"), assign = require("./assign"), assignDefaults = require("../internal/assignDefaults");
module.exports = defaults;
}, {
"../internal/arrayCopy":7,
"../internal/assignDefaults":9,
"./assign":48
} ],
50:[ function(require, module) {
var isLength = require("../internal/isLength"), isNative = require("../lang/isNative"), isObject = require("../lang/isObject"), shimKeys = require("../internal/shimKeys"), nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, keys = nativeKeys ? function(object) {
if (object) var Ctor = object.constructor, length = object.length;
return "function" == typeof Ctor && Ctor.prototype === object || "function" != typeof object && length && isLength(length) ? shimKeys(object) :isObject(object) ? nativeKeys(object) :[];
} :shimKeys;
module.exports = keys;
}, {
"../internal/isLength":32,
"../internal/shimKeys":36,
"../lang/isNative":41,
"../lang/isObject":42
} ],
51:[ function(require, module) {
function keysIn(object) {
if (null == object) return [];
isObject(object) || (object = Object(object));
var length = object.length;
length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;
for (var Ctor = object.constructor, index = -1, isProto = "function" == typeof Ctor && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0; ++index < length; ) result[index] = index + "";
for (var key in object) skipIndexes && isIndex(key, length) || "constructor" == key && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
return result;
}
var isArguments = require("../lang/isArguments"), isArray = require("../lang/isArray"), isIndex = require("../internal/isIndex"), isLength = require("../internal/isLength"), isObject = require("../lang/isObject"), support = require("../support"), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
module.exports = keysIn;
}, {
"../internal/isIndex":30,
"../internal/isLength":32,
"../lang/isArguments":39,
"../lang/isArray":40,
"../lang/isObject":42,
"../support":56
} ],
52:[ function(require, module) {
var baseMerge = require("../internal/baseMerge"), createAssigner = require("../internal/createAssigner"), merge = createAssigner(baseMerge);
module.exports = merge;
}, {
"../internal/baseMerge":18,
"../internal/createAssigner":24
} ],
53:[ function(require, module) {
function values(object) {
return baseValues(object, keys(object));
}
var baseValues = require("../internal/baseValues"), keys = require("./keys");
module.exports = values;
}, {
"../internal/baseValues":21,
"./keys":50
} ],
54:[ function(require, module) {
function escape(string) {
return string = baseToString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) :string;
}
var baseToString = require("../internal/baseToString"), escapeHtmlChar = require("../internal/escapeHtmlChar"), reUnescapedHtml = /[&<>"'`]/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
module.exports = escape;
}, {
"../internal/baseToString":20,
"../internal/escapeHtmlChar":25
} ],
55:[ function(require, module) {
function escapeRegExp(string) {
return string = baseToString(string), string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, "\\$&") :string;
}
var baseToString = require("../internal/baseToString"), reRegExpChars = /[.*+?^${}()|[\]\/\\]/g, reHasRegExpChars = RegExp(reRegExpChars.source);
module.exports = escapeRegExp;
}, {
"../internal/baseToString":20
} ],
56:[ function(require, module) {
var isNative = require("./lang/isNative"), root = require("./internal/root"), reThis = /\bthis\b/, objectProto = Object.prototype, document = (document = root.window) && document.document, propertyIsEnumerable = objectProto.propertyIsEnumerable, support = {};
!function() {
support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function() {
return this;
}), support.funcNames = "string" == typeof Function.name;
try {
support.dom = 11 === document.createDocumentFragment().nodeType;
} catch (e) {
support.dom = !1;
}
try {
support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
} catch (e) {
support.nonEnumArgs = !0;
}
}(0, 0), module.exports = support;
}, {
"./internal/root":34,
"./lang/isNative":41
} ],
57:[ function(require, module) {
function constant(value) {
return function() {
return value;
};
}
module.exports = constant;
}, {} ],
58:[ function(require, module) {
function identity(value) {
return value;
}
module.exports = identity;
}, {} ],
59:[ function(require, module) {
var buildCommandPatch = require("./api/command-patch"), buildCommand = require("./api/command"), Node = require("./api/node"), buildSelection = require("./api/selection"), buildSimpleCommand = require("./api/simple-command");
module.exports = function(scribe) {
this.CommandPatch = buildCommandPatch(scribe), this.Command = buildCommand(scribe), 
this.Node = Node, this.Selection = buildSelection(scribe), this.SimpleCommand = buildSimpleCommand(this, scribe);
};
}, {
"./api/command":62,
"./api/command-patch":61,
"./api/node":63,
"./api/selection":64,
"./api/simple-command":65
} ],
60:[ function(require, module) {
"use strict";
function firstDeepestChild(node) {
if (!node.hasChildNodes()) return node;
var treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_ALL, null, !1), previousNode = treeWalker.currentNode;
return treeWalker.firstChild() ? "BR" === treeWalker.currentNode.nodeName ? previousNode :firstDeepestChild(treeWalker.currentNode) :treeWalker.currentNode;
}
module.exports = {
firstDeepestChild:firstDeepestChild
};
}, {} ],
61:[ function(require, module) {
"use strict";
module.exports = function(scribe) {
function CommandPatch(commandName) {
this.commandName = commandName;
}
return CommandPatch.prototype.execute = function(value) {
scribe.transactionManager.run(function() {
document.execCommand(this.commandName, !1, value || null);
}.bind(this));
}, CommandPatch.prototype.queryState = function() {
return document.queryCommandState(this.commandName);
}, CommandPatch.prototype.queryEnabled = function() {
return document.queryCommandEnabled(this.commandName);
}, CommandPatch;
};
}, {} ],
62:[ function(require, module) {
"use strict";
module.exports = function(scribe) {
function Command(commandName) {
this.commandName = commandName, this.patch = scribe.commandPatches[this.commandName];
}
return Command.prototype.execute = function(value) {
this.patch ? this.patch.execute(value) :scribe.transactionManager.run(function() {
document.execCommand(this.commandName, !1, value || null);
}.bind(this));
}, Command.prototype.queryState = function() {
return this.patch ? this.patch.queryState() :document.queryCommandState(this.commandName);
}, Command.prototype.queryEnabled = function() {
return this.patch ? this.patch.queryEnabled() :document.queryCommandEnabled(this.commandName);
}, Command;
};
}, {} ],
63:[ function(require, module) {
"use strict";
function Node(node) {
this.node = node;
}
Node.prototype.getAncestor = function(rootElement, nodeFilter) {
var isTopContainerElement = function(element) {
return rootElement === element;
};
if (!isTopContainerElement(this.node)) for (var currentNode = this.node.parentNode; currentNode && !isTopContainerElement(currentNode); ) {
if (nodeFilter(currentNode)) return currentNode;
currentNode = currentNode.parentNode;
}
}, Node.prototype.nextAll = function() {
for (var all = [], el = this.node.nextSibling; el; ) all.push(el), el = el.nextSibling;
return all;
}, module.exports = Node;
}, {} ],
64:[ function(require, module) {
require("../element");
module.exports = function(scribe) {
function Selection() {
for (var rootDoc = document, currentElement = scribe.el.parentNode; currentElement && currentElement.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && currentElement.nodeType !== Node.DOCUMENT_NODE; ) currentElement = currentElement.parentNode;
if (currentElement && currentElement.nodeType === Node.DOCUMENT_FRAGMENT_NODE && currentElement.getSelection && (rootDoc = currentElement), 
this.selection = rootDoc.getSelection(), this.selection.rangeCount && this.selection.anchorNode) {
this.range = document.createRange();
var reverseRange = document.createRange();
this.range.setStart(this.selection.anchorNode, this.selection.anchorOffset), reverseRange.setStart(this.selection.focusNode, this.selection.focusOffset), 
this.range.compareBoundaryPoints(Range.START_TO_START, reverseRange) <= 0 ? this.range.setEnd(this.selection.focusNode, this.selection.focusOffset) :(this.range = reverseRange, 
this.range.setEnd(this.selection.anchorNode, this.selection.anchorOffset));
}
}
return Selection.prototype.getContaining = function(nodeFilter) {
var range = this.range;
if (range) {
var node = new scribe.api.Node(this.range.commonAncestorContainer), isTopContainerElement = node.node && scribe.el === node.node;
return !isTopContainerElement && nodeFilter(node.node) ? node.node :node.getAncestor(scribe.el, nodeFilter);
}
}, Selection.prototype.placeMarkers = function() {
var range = this.range;
if (range && scribe.el.offsetParent) {
var scribeNodeRange = document.createRange();
scribeNodeRange.selectNodeContents(scribe.el);
var selectionStartWithinScribeElementStart = this.range.compareBoundaryPoints(Range.START_TO_START, scribeNodeRange) >= 0, selectionEndWithinScribeElementEnd = this.range.compareBoundaryPoints(Range.END_TO_END, scribeNodeRange) <= 0;
if (selectionStartWithinScribeElementStart && selectionEndWithinScribeElementEnd) {
var startMarker = document.createElement("em");
startMarker.classList.add("scribe-marker");
var endMarker = document.createElement("em");
endMarker.classList.add("scribe-marker");
var rangeEnd = this.range.cloneRange();
if (rangeEnd.collapse(!1), rangeEnd.insertNode(endMarker), endMarker.nextSibling && endMarker.nextSibling.nodeType === Node.TEXT_NODE && "" === endMarker.nextSibling.data && endMarker.parentNode.removeChild(endMarker.nextSibling), 
endMarker.previousSibling && endMarker.previousSibling.nodeType === Node.TEXT_NODE && "" === endMarker.previousSibling.data && endMarker.parentNode.removeChild(endMarker.previousSibling), 
!this.range.collapsed) {
var rangeStart = this.range.cloneRange();
rangeStart.collapse(!0), rangeStart.insertNode(startMarker), startMarker.nextSibling && startMarker.nextSibling.nodeType === Node.TEXT_NODE && "" === startMarker.nextSibling.data && startMarker.parentNode.removeChild(startMarker.nextSibling), 
startMarker.previousSibling && startMarker.previousSibling.nodeType === Node.TEXT_NODE && "" === startMarker.previousSibling.data && startMarker.parentNode.removeChild(startMarker.previousSibling);
}
this.selection.removeAllRanges(), this.selection.addRange(this.range);
}
}
}, Selection.prototype.getMarkers = function() {
return scribe.el.querySelectorAll("em.scribe-marker");
}, Selection.prototype.removeMarkers = function() {
var markers = this.getMarkers();
Array.prototype.forEach.call(markers, function(marker) {
marker.parentNode.removeChild(marker);
});
}, Selection.prototype.selectMarkers = function(keepMarkers) {
var markers = this.getMarkers();
if (markers.length) {
var newRange = document.createRange();
newRange.setStartBefore(markers[0]), markers.length >= 2 ? newRange.setEndAfter(markers[1]) :newRange.setEndAfter(markers[0]), 
keepMarkers || this.removeMarkers(), this.selection.removeAllRanges(), this.selection.addRange(newRange);
}
}, Selection.prototype.isCaretOnNewLine = function() {
function isEmptyInlineElement(node) {
for (var treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, null, !1), currentNode = treeWalker.root; currentNode; ) {
var numberOfChildren = currentNode.childNodes.length;
if (numberOfChildren > 1 || 1 === numberOfChildren && "" !== currentNode.textContent.trim()) return !1;
if (0 === numberOfChildren) return "" === currentNode.textContent.trim();
currentNode = treeWalker.nextNode();
}
}
var containerPElement = this.getContaining(function(node) {
return "P" === node.nodeName;
});
return containerPElement ? isEmptyInlineElement(containerPElement) :!1;
}, Selection;
};
}, {
"../element":68
} ],
65:[ function(require, module) {
"use strict";
module.exports = function(api, scribe) {
function SimpleCommand(commandName, nodeName) {
scribe.api.Command.call(this, commandName), this._nodeName = nodeName;
}
return SimpleCommand.prototype = Object.create(api.Command.prototype), SimpleCommand.prototype.constructor = SimpleCommand, 
SimpleCommand.prototype.queryState = function() {
var selection = new scribe.api.Selection();
return scribe.api.Command.prototype.queryState.call(this) && !!selection.getContaining(function(node) {
return node.nodeName === this._nodeName;
}.bind(this));
}, SimpleCommand;
};
}, {} ],
66:[ function(require, module) {
function checkOptions(userSuppliedOptions) {
var options = userSuppliedOptions || {};
return options.defaultPlugins && (options.defaultPlugins = options.defaultPlugins.filter(filterByPluginExists(defaultOptions.defaultPlugins))), 
options.defaultFormatters && (options.defaultFormatters = options.defaultFormatters.filter(filterByPluginExists(defaultOptions.defaultFormatters))), 
Object.freeze(defaults(options, defaultOptions));
}
function sortByPlugin(priorityPlugin) {
return function(pluginCurrent, pluginNext) {
return pluginCurrent === priorityPlugin ? -1 :pluginNext === priorityPlugin ? 1 :0;
};
}
function filterByBlockLevelMode(isBlockLevelMode) {
return function(plugin) {
return -1 !== (isBlockLevelMode ? blockModePlugins :inlineModePlugins).indexOf(plugin);
};
}
function filterByPluginExists(pluginList) {
return function(plugin) {
return -1 !== pluginList.indexOf(plugin);
};
}
var defaults = require("lodash-amd/modern/object/defaults"), blockModePlugins = [ "setRootPElement", "enforcePElements", "ensureSelectableContainers" ], inlineModePlugins = [ "inlineElementsMode" ], defaultOptions = {
allowBlockElements:!0,
debug:!1,
undo:{
manager:!1,
enabled:!0,
limit:100,
interval:250
},
defaultCommandPatches:[ "bold", "indent", "insertHTML", "insertList", "outdent", "createLink" ],
defaultPlugins:blockModePlugins.concat(inlineModePlugins),
defaultFormatters:[ "escapeHtmlCharactersFormatter", "replaceNbspCharsFormatter" ]
};
module.exports = {
defaultOptions:defaultOptions,
checkOptions:checkOptions,
sortByPlugin:sortByPlugin,
filterByBlockLevelMode:filterByBlockLevelMode,
filterByPluginExists:filterByPluginExists
};
}, {
"lodash-amd/modern/object/defaults":49
} ],
67:[ function(require, module) {
function observeDomChanges(el, callback) {
function includeRealMutations(mutations) {
var allChangedNodes = flatten(mutations.map(function(mutation) {
var added = toArray(mutation.addedNodes), removed = toArray(mutation.removedNodes);
return added.concat(removed);
})), realChangedNodes = allChangedNodes.filter(function(n) {
return !nodeHelpers.isEmptyTextNode(n);
}).filter(function(n) {
return !elementHelpers.isSelectionMarkerNode(n);
});
return realChangedNodes.length > 0;
}
var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver, runningPostMutation = !1, observer = new MutationObserver(function(mutations) {
if (!runningPostMutation && includeRealMutations(mutations)) {
runningPostMutation = !0;
try {
callback();
} catch (e) {
throw e;
} finally {
setTimeout(function() {
runningPostMutation = !1;
}, 0);
}
}
});
return observer.observe(el, {
childList:!0,
subtree:!0
}), observer;
}
var flatten = require("lodash-amd/modern/array/flatten"), toArray = require("lodash-amd/modern/lang/toArray"), elementHelpers = require("./element"), nodeHelpers = require("./node");
module.exports = observeDomChanges;
}, {
"./element":68,
"./node":70,
"lodash-amd/modern/array/flatten":2,
"lodash-amd/modern/lang/toArray":46
} ],
68:[ function(require, module) {
function isBlockElement(node) {
return contains(blockElementNames, node.nodeName);
}
function isSelectionMarkerNode(node) {
return node.nodeType === Node.ELEMENT_NODE && "scribe-marker" === node.className;
}
function isCaretPositionNode(node) {
return node.nodeType === Node.ELEMENT_NODE && "caret-position" === node.className;
}
function unwrap(node, childNode) {
for (;childNode.childNodes.length > 0; ) node.insertBefore(childNode.childNodes[0], childNode);
node.removeChild(childNode);
}
var contains = require("lodash-amd/modern/collection/contains"), blockElementNames = [ "ADDRESS", "ARTICLE", "ASIDE", "AUDIO", "BLOCKQUOTE", "CANVAS", "DD", "DIV", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "LI", "NOSCRIPT", "OL", "OUTPUT", "P", "PRE", "SECTION", "TABLE", "TD", "TH", "TFOOT", "UL", "VIDEO" ];
module.exports = {
isBlockElement:isBlockElement,
isSelectionMarkerNode:isSelectionMarkerNode,
isCaretPositionNode:isCaretPositionNode,
unwrap:unwrap
};
}, {
"lodash-amd/modern/collection/contains":5
} ],
69:[ function(require, module) {
function EventEmitter() {
this._listeners = {};
}
var Immutable = (require("lodash-amd/modern/array/pull"), require("immutable/dist/immutable"));
EventEmitter.prototype.on = function(eventName, fn) {
var listeners = this._listeners[eventName] || Immutable.Set();
this._listeners[eventName] = listeners.add(fn);
}, EventEmitter.prototype.off = function(eventName, fn) {
var listeners = this._listeners[eventName] || Immutable.Set();
this._listeners[eventName] = fn ? listeners.delete(fn) :listeners.clear();
}, EventEmitter.prototype.trigger = function(eventName, args) {
for (var events = eventName.split(":"); events.length; ) {
var currentEvent = events.join(":"), listeners = this._listeners[currentEvent] || Immutable.Set();
listeners.forEach(function(listener) {
listener.apply(null, args);
}), events.splice(events.length - 1, 1);
}
}, module.exports = EventEmitter;
}, {
"immutable/dist/immutable":1,
"lodash-amd/modern/array/pull":4
} ],
70:[ function(require, module) {
"use strict";
function isEmptyTextNode(node) {
return node.nodeType === Node.TEXT_NODE && "" === node.textContent;
}
function insertAfter(newNode, referenceNode) {
return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
function removeNode(node) {
return node.parentNode.removeChild(node);
}
module.exports = {
isEmptyTextNode:isEmptyTextNode,
insertAfter:insertAfter,
removeNode:removeNode
};
}, {} ],
71:[ function(require, module) {
var indent = require("./commands/indent"), insertList = require("./commands/insert-list"), outdent = require("./commands/outdent"), redo = require("./commands/redo"), subscript = require("./commands/subscript"), superscript = require("./commands/superscript"), undo = require("./commands/undo");
module.exports = {
indent:indent,
insertList:insertList,
outdent:outdent,
redo:redo,
subscript:subscript,
superscript:superscript,
undo:undo
};
}, {
"./commands/indent":72,
"./commands/insert-list":73,
"./commands/outdent":74,
"./commands/redo":75,
"./commands/subscript":76,
"./commands/superscript":77,
"./commands/undo":78
} ],
72:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var indentCommand = new scribe.api.Command("indent");
indentCommand.queryEnabled = function() {
var selection = new scribe.api.Selection(), listElement = selection.getContaining(function(element) {
return "UL" === element.nodeName || "OL" === element.nodeName;
});
return scribe.api.Command.prototype.queryEnabled.call(this) && scribe.allowsBlockElements() && !listElement;
}, scribe.commands.indent = indentCommand;
};
};
}, {} ],
73:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var InsertListCommand = function(commandName) {
scribe.api.Command.call(this, commandName);
};
InsertListCommand.prototype = Object.create(scribe.api.Command.prototype), InsertListCommand.prototype.constructor = InsertListCommand, 
InsertListCommand.prototype.execute = function(value) {
function splitList(listItemElements) {
if (listItemElements.length > 0) {
var newListNode = document.createElement(listNode.nodeName);
listItemElements.forEach(function(listItemElement) {
newListNode.appendChild(listItemElement);
}), listNode.parentNode.insertBefore(newListNode, listNode.nextElementSibling);
}
}
if (this.queryState()) {
var selection = new scribe.api.Selection(), range = selection.range, listNode = selection.getContaining(function(node) {
return "OL" === node.nodeName || "UL" === node.nodeName;
}), listItemElement = selection.getContaining(function(node) {
return "LI" === node.nodeName;
});
scribe.transactionManager.run(function() {
if (listItemElement) {
var nextListItemElements = new scribe.api.Node(listItemElement).nextAll();
splitList(nextListItemElements), selection.placeMarkers();
var pNode = document.createElement("p");
pNode.innerHTML = listItemElement.innerHTML, listNode.parentNode.insertBefore(pNode, listNode.nextElementSibling), 
listItemElement.parentNode.removeChild(listItemElement);
} else {
var selectedListItemElements = Array.prototype.map.call(listNode.querySelectorAll("li"), function(listItemElement) {
return range.intersectsNode(listItemElement) && listItemElement;
}).filter(function(listItemElement) {
return listItemElement;
}), lastSelectedListItemElement = selectedListItemElements.slice(-1)[0], listItemElementsAfterSelection = new scribe.api.Node(lastSelectedListItemElement).nextAll();
splitList(listItemElementsAfterSelection), selection.placeMarkers();
var documentFragment = document.createDocumentFragment();
selectedListItemElements.forEach(function(listItemElement) {
var pElement = document.createElement("p");
pElement.innerHTML = listItemElement.innerHTML, documentFragment.appendChild(pElement);
}), listNode.parentNode.insertBefore(documentFragment, listNode.nextElementSibling), 
selectedListItemElements.forEach(function(listItemElement) {
listItemElement.parentNode.removeChild(listItemElement);
});
}
0 === listNode.childNodes.length && listNode.parentNode.removeChild(listNode), selection.selectMarkers();
}.bind(this));
} else scribe.api.Command.prototype.execute.call(this, value);
}, InsertListCommand.prototype.queryEnabled = function() {
return scribe.api.Command.prototype.queryEnabled.call(this) && scribe.allowsBlockElements();
}, scribe.commands.insertOrderedList = new InsertListCommand("insertOrderedList"), 
scribe.commands.insertUnorderedList = new InsertListCommand("insertUnorderedList");
};
};
}, {} ],
74:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var outdentCommand = new scribe.api.Command("outdent");
outdentCommand.queryEnabled = function() {
var selection = new scribe.api.Selection(), listElement = selection.getContaining(function(element) {
return "UL" === element.nodeName || "OL" === element.nodeName;
});
return scribe.api.Command.prototype.queryEnabled.call(this) && scribe.allowsBlockElements() && !listElement;
}, scribe.commands.outdent = outdentCommand;
};
};
}, {} ],
75:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var redoCommand = new scribe.api.Command("redo");
redoCommand.execute = function() {
scribe.undoManager.redo();
}, redoCommand.queryEnabled = function() {
return scribe.undoManager.position > 0;
}, scribe.commands.redo = redoCommand, scribe.options.undo.enabled && scribe.el.addEventListener("keydown", function(event) {
event.shiftKey && (event.metaKey || event.ctrlKey) && 90 === event.keyCode && (event.preventDefault(), 
redoCommand.execute());
});
};
};
}, {} ],
76:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var subscriptCommand = new scribe.api.Command("subscript");
scribe.commands.subscript = subscriptCommand;
};
};
}, {} ],
77:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var superscriptCommand = new scribe.api.Command("superscript");
scribe.commands.superscript = superscriptCommand;
};
};
}, {} ],
78:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var undoCommand = new scribe.api.Command("undo");
undoCommand.execute = function() {
scribe.undoManager.undo();
}, undoCommand.queryEnabled = function() {
return scribe.undoManager.position < scribe.undoManager.length;
}, scribe.commands.undo = undoCommand, scribe.options.undo.enabled && scribe.el.addEventListener("keydown", function(event) {
event.shiftKey || !event.metaKey && !event.ctrlKey || 90 !== event.keyCode || (event.preventDefault(), 
undoCommand.execute());
});
};
};
}, {} ],
79:[ function(require, module) {
var contains = require("lodash-amd/modern/collection/contains"), observeDomChanges = require("../../dom-observer"), children = require("../../api/children");
module.exports = function() {
return function(scribe) {
scribe.el.addEventListener("focus", function() {
var selection = new scribe.api.Selection();
if (selection.range) {
var isFirefoxBug = scribe.allowsBlockElements() && selection.range.startContainer === scribe.el;
if (isFirefoxBug) {
var focusElement = children.firstDeepestChild(scribe.el), range = selection.range;
range.setStart(focusElement, 0), range.setEnd(focusElement, 0), selection.selection.removeAllRanges(), 
selection.selection.addRange(range);
}
}
}.bind(scribe));
var applyFormatters = function() {
if (!scribe._skipFormatters) {
var selection = new scribe.api.Selection(), isEditorActive = selection.range, runFormatters = function() {
isEditorActive && selection.placeMarkers(), scribe.setHTML(scribe._htmlFormatterFactory.format(scribe.getHTML())), 
selection.selectMarkers();
}.bind(scribe);
scribe.transactionManager.run(runFormatters);
}
delete scribe._skipFormatters;
}.bind(scribe);
observeDomChanges(scribe.el, applyFormatters), scribe.allowsBlockElements() && scribe.el.addEventListener("keydown", function(event) {
if (13 === event.keyCode) {
var selection = new scribe.api.Selection(), range = selection.range, headingNode = selection.getContaining(function(node) {
return /^(H[1-6])$/.test(node.nodeName);
});
if (headingNode && range.collapsed) {
var contentToEndRange = range.cloneRange();
contentToEndRange.setEndAfter(headingNode, 0);
var contentToEndFragment = contentToEndRange.cloneContents();
"" === contentToEndFragment.firstChild.textContent && (event.preventDefault(), scribe.transactionManager.run(function() {
var pNode = document.createElement("p"), brNode = document.createElement("br");
pNode.appendChild(brNode), headingNode.parentNode.insertBefore(pNode, headingNode.nextElementSibling), 
range.setStart(pNode, 0), range.setEnd(pNode, 0), selection.selection.removeAllRanges(), 
selection.selection.addRange(range);
}));
}
}
}), scribe.allowsBlockElements() && scribe.el.addEventListener("keydown", function(event) {
if (13 === event.keyCode || 8 === event.keyCode) {
var selection = new scribe.api.Selection(), range = selection.range;
if (range.collapsed) {
var containerLIElement = selection.getContaining(function(node) {
return "LI" === node.nodeName;
});
if (containerLIElement && "" === containerLIElement.textContent.trim()) {
event.preventDefault();
var listNode = selection.getContaining(function(node) {
return "UL" === node.nodeName || "OL" === node.nodeName;
}), command = scribe.getCommand("OL" === listNode.nodeName ? "insertOrderedList" :"insertUnorderedList");
command.execute();
}
}
}
}), scribe.el.addEventListener("paste", function(event) {
if (event.clipboardData) event.preventDefault(), contains(event.clipboardData.types, "text/html") ? scribe.insertHTML(event.clipboardData.getData("text/html")) :scribe.insertPlainText(event.clipboardData.getData("text/plain")); else {
var selection = new scribe.api.Selection();
selection.placeMarkers();
var bin = document.createElement("div");
document.body.appendChild(bin), bin.setAttribute("contenteditable", !0), bin.focus(), 
setTimeout(function() {
var data = bin.innerHTML;
bin.parentNode.removeChild(bin), selection.selectMarkers(), scribe.el.focus(), scribe.insertHTML(data);
}, 1);
}
});
};
};
}, {
"../../api/children":60,
"../../dom-observer":67,
"lodash-amd/modern/collection/contains":5
} ],
80:[ function(require, module) {
var replaceNbspCharsFormatter = require("./formatters/html/replace-nbsp-chars"), escapeHtmlCharactersFormatter = require("./formatters/plain-text/escape-html-characters");
module.exports = {
replaceNbspCharsFormatter:replaceNbspCharsFormatter,
escapeHtmlCharactersFormatter:escapeHtmlCharactersFormatter
};
}, {
"./formatters/html/replace-nbsp-chars":83,
"./formatters/plain-text/escape-html-characters":84
} ],
81:[ function(require, module) {
function wrapChildNodes(scribe, parentNode) {
var groups = Array.prototype.reduce.call(parentNode.childNodes, function(accumulator, binChildNode) {
function startNewGroup() {
var newGroup = [ binChildNode ];
accumulator.push(newGroup);
}
var group = last(accumulator);
if (group) {
var isBlockGroup = scribe.element.isBlockElement(group[0]);
isBlockGroup === scribe.element.isBlockElement(binChildNode) ? group.push(binChildNode) :startNewGroup();
} else startNewGroup();
return accumulator;
}, []), consecutiveInlineElementsAndTextNodes = groups.filter(function(group) {
var isBlockGroup = scribe.element.isBlockElement(group[0]);
return !isBlockGroup;
});
consecutiveInlineElementsAndTextNodes.forEach(function(nodes) {
var pElement = document.createElement("p");
nodes[0].parentNode.insertBefore(pElement, nodes[0]), nodes.forEach(function(node) {
pElement.appendChild(node);
});
}), parentNode._isWrapped = !0;
}
function traverse(scribe, parentNode) {
for (var treeWalker = document.createTreeWalker(parentNode, NodeFilter.SHOW_ELEMENT, null, !1), node = treeWalker.firstChild(); node; ) {
if ("BLOCKQUOTE" === node.nodeName && !node._isWrapped) {
wrapChildNodes(scribe, node), traverse(scribe, parentNode);
break;
}
node = treeWalker.nextSibling();
}
}
var last = require("lodash-amd/modern/array/last");
module.exports = function() {
return function(scribe) {
scribe.registerHTMLFormatter("normalize", function(html) {
var bin = document.createElement("div");
return bin.innerHTML = html, wrapChildNodes(scribe, bin), traverse(scribe, bin), 
bin.innerHTML;
});
};
};
}, {
"lodash-amd/modern/array/last":3
} ],
82:[ function(require, module) {
function parentHasNoTextContent(element, node) {
return element.isCaretPositionNode(node) ? !0 :"" === node.parentNode.textContent.trim();
}
function traverse(element, parentNode) {
function isEmpty(node) {
return 0 === node.children.length && element.isBlockElement(node) || 1 === node.children.length && element.isSelectionMarkerNode(node.children[0]) ? !0 :element.isBlockElement(node) || 0 !== node.children.length ? !1 :parentHasNoTextContent(element, node);
}
for (var node = parentNode.firstElementChild; node; ) element.isSelectionMarkerNode(node) || (isEmpty(node) && "" === node.textContent.trim() && !contains(html5VoidElements, node.nodeName) ? node.appendChild(document.createElement("br")) :node.children.length > 0 && traverse(element, node)), 
node = node.nextElementSibling;
}
var contains = (require("../../../../element"), require("lodash-amd/modern/collection/contains")), html5VoidElements = [ "AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR" ];
module.exports = function() {
return function(scribe) {
scribe.registerHTMLFormatter("normalize", function(html) {
var bin = document.createElement("div");
return bin.innerHTML = html, traverse(scribe.element, bin), bin.innerHTML;
});
};
};
}, {
"../../../../element":68,
"lodash-amd/modern/collection/contains":5
} ],
83:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var nbspCharRegExp = /(\s|&nbsp;)+/g;
scribe.registerHTMLFormatter("export", function(html) {
return html.replace(nbspCharRegExp, " ");
});
};
};
}, {} ],
84:[ function(require, module) {
var escape = require("lodash-amd/modern/string/escape");
module.exports = function() {
return function(scribe) {
scribe.registerPlainTextFormatter(escape);
};
};
}, {
"lodash-amd/modern/string/escape":54
} ],
85:[ function(require, module) {
"use strict";
function hasContent(rootNode) {
for (var treeWalker = document.createTreeWalker(rootNode, NodeFilter.SHOW_ALL, null, !1); treeWalker.nextNode(); ) if (treeWalker.currentNode && (~[ "br" ].indexOf(treeWalker.currentNode.nodeName.toLowerCase()) || treeWalker.currentNode.length > 0)) return !0;
return !1;
}
module.exports = function() {
return function(scribe) {
scribe.el.addEventListener("keydown", function(event) {
if (13 === event.keyCode) {
var selection = new scribe.api.Selection(), range = selection.range, blockNode = selection.getContaining(function(node) {
return "LI" === node.nodeName || /^(H[1-6])$/.test(node.nodeName);
});
blockNode || (event.preventDefault(), scribe.transactionManager.run(function() {
"BR" === scribe.el.lastChild.nodeName && scribe.el.removeChild(scribe.el.lastChild);
var brNode = document.createElement("br");
range.insertNode(brNode), range.collapse(!1);
var contentToEndRange = range.cloneRange();
contentToEndRange.setEndAfter(scribe.el.lastChild, 0);
var contentToEndFragment = contentToEndRange.cloneContents();
if (!hasContent(contentToEndFragment)) {
var bogusBrNode = document.createElement("br");
range.insertNode(bogusBrNode);
}
var newRange = range.cloneRange();
newRange.setStartAfter(brNode, 0), newRange.setEndAfter(brNode, 0), selection.selection.removeAllRanges(), 
selection.selection.addRange(newRange);
}));
}
}.bind(this)), "" === scribe.getHTML().trim() && scribe.setContent("");
};
};
}, {} ],
86:[ function(require, module) {
var boldCommand = require("./patches/commands/bold"), indentCommand = require("./patches/commands/indent"), insertHTMLCommand = require("./patches/commands/insert-html"), insertListCommands = require("./patches/commands/insert-list"), outdentCommand = require("./patches/commands/outdent"), createLinkCommand = require("./patches/commands/create-link"), events = require("./patches/events");
module.exports = {
commands:{
bold:boldCommand,
indent:indentCommand,
insertHTML:insertHTMLCommand,
insertList:insertListCommands,
outdent:outdentCommand,
createLink:createLinkCommand
},
events:events
};
}, {
"./patches/commands/bold":87,
"./patches/commands/create-link":88,
"./patches/commands/indent":89,
"./patches/commands/insert-html":90,
"./patches/commands/insert-list":91,
"./patches/commands/outdent":92,
"./patches/events":93
} ],
87:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var boldCommand = new scribe.api.CommandPatch("bold");
boldCommand.queryEnabled = function() {
var selection = new scribe.api.Selection(), headingNode = selection.getContaining(function(node) {
return /^(H[1-6])$/.test(node.nodeName);
});
return scribe.api.CommandPatch.prototype.queryEnabled.apply(this, arguments) && !headingNode;
}, scribe.commandPatches.bold = boldCommand;
};
};
}, {} ],
88:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var createLinkCommand = new scribe.api.CommandPatch("createLink");
scribe.commandPatches.createLink = createLinkCommand, createLinkCommand.execute = function(value) {
var selection = new scribe.api.Selection();
if (selection.range.collapsed) {
var aElement = document.createElement("a");
aElement.setAttribute("href", value), aElement.textContent = value, selection.range.insertNode(aElement);
var newRange = document.createRange();
newRange.setStartBefore(aElement), newRange.setEndAfter(aElement), selection.selection.removeAllRanges(), 
selection.selection.addRange(newRange);
} else scribe.api.CommandPatch.prototype.execute.call(this, value);
};
};
};
}, {} ],
89:[ function(require, module) {
"use strict";
var INVISIBLE_CHAR = "\ufeff";
module.exports = function() {
return function(scribe) {
var indentCommand = new scribe.api.CommandPatch("indent");
indentCommand.execute = function(value) {
scribe.transactionManager.run(function() {
var selection = new scribe.api.Selection(), range = selection.range, isCaretOnNewLine = "P" === range.commonAncestorContainer.nodeName && "<br>" === range.commonAncestorContainer.innerHTML;
if (isCaretOnNewLine) {
var textNode = document.createTextNode(INVISIBLE_CHAR);
range.insertNode(textNode), range.setStart(textNode, 0), range.setEnd(textNode, 0), 
selection.selection.removeAllRanges(), selection.selection.addRange(range);
}
scribe.api.CommandPatch.prototype.execute.call(this, value), selection = new scribe.api.Selection();
var blockquoteNode = selection.getContaining(function(node) {
return "BLOCKQUOTE" === node.nodeName;
});
blockquoteNode && blockquoteNode.removeAttribute("style");
}.bind(this));
}, scribe.commandPatches.indent = indentCommand;
};
};
}, {} ],
90:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var insertHTMLCommandPatch = new scribe.api.CommandPatch("insertHTML"), element = scribe.element;
insertHTMLCommandPatch.execute = function(value) {
scribe.transactionManager.run(function() {
function removeChromeArtifacts(parentElement) {
for (var childElement = parentElement.firstElementChild; childElement; ) {
var childStyle = window.getComputedStyle(childElement);
"inline" !== childStyle.display && "SPAN" !== childElement.nodeName || window.getComputedStyle(parentElement)["line-height"] !== childStyle["line-height"] || (childElement.style.lineHeight = null), 
"" === childElement.getAttribute("style") && childElement.removeAttribute("style"), 
removeChromeArtifacts(childElement);
var originalChild = childElement;
childElement = childElement.nextElementSibling, "SPAN" === originalChild.nodeName && 0 === originalChild.attributes.length && element.unwrap(parentElement, originalChild);
}
}
scribe.api.CommandPatch.prototype.execute.call(this, value), removeChromeArtifacts(scribe.el);
}.bind(this));
}, scribe.commandPatches.insertHTML = insertHTMLCommandPatch;
};
};
}, {} ],
91:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var element = scribe.element, nodeHelpers = scribe.node, InsertListCommandPatch = function(commandName) {
scribe.api.CommandPatch.call(this, commandName);
};
InsertListCommandPatch.prototype = Object.create(scribe.api.CommandPatch.prototype), 
InsertListCommandPatch.prototype.constructor = InsertListCommandPatch, InsertListCommandPatch.prototype.execute = function(value) {
scribe.transactionManager.run(function() {
if (scribe.api.CommandPatch.prototype.execute.call(this, value), this.queryState()) {
var selection = new scribe.api.Selection(), listElement = selection.getContaining(function(node) {
return "OL" === node.nodeName || "UL" === node.nodeName;
});
if (listElement.nextElementSibling && 0 === listElement.nextElementSibling.childNodes.length && nodeHelpers.removeNode(listElement.nextElementSibling), 
listElement) {
var listParentNode = listElement.parentNode;
listParentNode && /^(H[1-6]|P)$/.test(listParentNode.nodeName) && (selection.placeMarkers(), 
nodeHelpers.insertAfter(listElement, listParentNode), selection.selectMarkers(), 
2 === listParentNode.childNodes.length && nodeHelpers.isEmptyTextNode(listParentNode.firstChild) && nodeHelpers.removeNode(listParentNode), 
0 === listParentNode.childNodes.length && nodeHelpers.removeNode(listParentNode));
}
var listItemElements = Array.prototype.slice.call(listElement.childNodes);
listItemElements.forEach(function(listItemElement) {
var listItemElementChildNodes = Array.prototype.slice.call(listItemElement.childNodes);
listItemElementChildNodes.forEach(function(listElementChildNode) {
if ("SPAN" === listElementChildNode.nodeName) {
var spanElement = listElementChildNode;
element.unwrap(listItemElement, spanElement);
} else listElementChildNode.nodeType === Node.ELEMENT_NODE && (listElementChildNode.style.lineHeight = null, 
"" === listElementChildNode.getAttribute("style") && listElementChildNode.removeAttribute("style"));
});
});
}
}.bind(this));
}, scribe.commandPatches.insertOrderedList = new InsertListCommandPatch("insertOrderedList"), 
scribe.commandPatches.insertUnorderedList = new InsertListCommandPatch("insertUnorderedList");
};
};
}, {} ],
92:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var outdentCommand = new scribe.api.CommandPatch("outdent");
outdentCommand.execute = function() {
scribe.transactionManager.run(function() {
var selection = new scribe.api.Selection(), range = selection.range, blockquoteNode = selection.getContaining(function(node) {
return "BLOCKQUOTE" === node.nodeName;
});
if ("BLOCKQUOTE" === range.commonAncestorContainer.nodeName) {
selection.placeMarkers(), selection.selectMarkers(!0);
var selectedNodes = range.cloneContents();
blockquoteNode.parentNode.insertBefore(selectedNodes, blockquoteNode), range.deleteContents(), 
selection.selectMarkers(), "" === blockquoteNode.textContent && blockquoteNode.parentNode.removeChild(blockquoteNode);
} else {
var pNode = selection.getContaining(function(node) {
return "P" === node.nodeName;
});
if (pNode) {
var nextSiblingNodes = new scribe.api.Node(pNode).nextAll();
if (nextSiblingNodes.length) {
var newContainerNode = document.createElement(blockquoteNode.nodeName);
nextSiblingNodes.forEach(function(siblingNode) {
newContainerNode.appendChild(siblingNode);
}), blockquoteNode.parentNode.insertBefore(newContainerNode, blockquoteNode.nextElementSibling);
}
selection.placeMarkers(), blockquoteNode.parentNode.insertBefore(pNode, blockquoteNode.nextElementSibling), 
selection.selectMarkers(), "" === blockquoteNode.innerHTML && blockquoteNode.parentNode.removeChild(blockquoteNode);
} else scribe.api.CommandPatch.prototype.execute.call(this);
}
}.bind(this));
}, scribe.commandPatches.outdent = outdentCommand;
};
};
}, {} ],
93:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var element = scribe.element;
scribe.allowsBlockElements() && scribe.el.addEventListener("keyup", function(event) {
if (8 === event.keyCode || 46 === event.keyCode) {
var selection = new scribe.api.Selection(), containerPElement = selection.getContaining(function(node) {
return "P" === node.nodeName;
});
containerPElement && scribe.transactionManager.run(function() {
selection.placeMarkers();
var pElementChildNodes = Array.prototype.slice.call(containerPElement.childNodes);
pElementChildNodes.forEach(function(pElementChildNode) {
if ("SPAN" === pElementChildNode.nodeName) {
var spanElement = pElementChildNode;
element.unwrap(containerPElement, spanElement);
} else pElementChildNode.nodeType === Node.ELEMENT_NODE && (pElementChildNode.style.lineHeight = null, 
"" === pElementChildNode.getAttribute("style") && pElementChildNode.removeAttribute("style"));
}), selection.selectMarkers();
}, !0);
}
});
};
};
}, {} ],
94:[ function(require, module) {
var setRootPElement = require("./set-root-p-element"), enforcePElements = require("./formatters/html/enforce-p-elements"), ensureSelectableContainers = require("./formatters/html/ensure-selectable-containers"), inlineElementsMode = require("./inline-elements-mode");
module.exports = {
setRootPElement:setRootPElement,
enforcePElements:enforcePElements,
ensureSelectableContainers:ensureSelectableContainers,
inlineElementsMode:inlineElementsMode
};
}, {
"./formatters/html/enforce-p-elements":81,
"./formatters/html/ensure-selectable-containers":82,
"./inline-elements-mode":85,
"./set-root-p-element":95
} ],
95:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
"" === scribe.getHTML().trim() && scribe.setContent("<p><br></p>");
};
};
}, {} ],
96:[ function(require, module) {
function Scribe(el, options) {
EventEmitter.call(this), this.el = el, this.commands = {}, this.options = config.checkOptions(options), 
this.commandPatches = {}, this._plainTextFormatterFactory = new FormatterFactory(), 
this._htmlFormatterFactory = new HTMLFormatterFactory(), this.api = new Api(this), 
this.node = nodeHelpers, this.element = elementHelpers, this.Immutable = Immutable;
var TransactionManager = buildTransactionManager(this);
this.transactionManager = new TransactionManager(), this.undoManager = !1, this.options.undo.enabled && (this.undoManager = this.options.undo.manager ? this.options.undo.manager :new UndoManager(this.options.undo.limit, this.el), 
this._merge = !1, this._forceMerge = !1, this._mergeTimer = 0, this._lastItem = {
content:""
}), this.setHTML(this.getHTML()), this.el.setAttribute("contenteditable", !0), this.el.addEventListener("input", function() {
this.transactionManager.run();
}.bind(this), !1);
var corePlugins = Immutable.OrderedSet(this.options.defaultPlugins).sort(config.sortByPlugin("setRootPElement")).filter(config.filterByBlockLevelMode(this.allowsBlockElements())).map(function(plugin) {
return plugins[plugin];
}), defaultFormatters = Immutable.List(this.options.defaultFormatters).filter(function(formatter) {
return !!formatters[formatter];
}).map(function(formatter) {
return formatters[formatter];
}), defaultPatches = Immutable.List.of(patches.events), defaultCommandPatches = Immutable.List(this.options.defaultCommandPatches).map(function(patch) {
return patches.commands[patch];
}), defaultCommands = Immutable.List.of("indent", "insertList", "outdent", "redo", "subscript", "superscript", "undo").map(function(command) {
return commands[command];
}), allPlugins = Immutable.List().concat(corePlugins, defaultFormatters, defaultPatches, defaultCommandPatches, defaultCommands);
allPlugins.forEach(function(plugin) {
this.use(plugin());
}.bind(this)), this.use(events());
}
function FormatterFactory() {
this.formatters = Immutable.List();
}
function HTMLFormatterFactory() {
this.formatters = {
sanitize:Immutable.List(),
normalize:Immutable.List(),
"export":Immutable.List()
};
}
var plugins = require("./plugins/core/plugins"), commands = require("./plugins/core/commands"), formatters = require("./plugins/core/formatters"), events = require("./plugins/core/events"), patches = require("./plugins/core/patches"), Api = require("./api"), buildTransactionManager = require("./transaction-manager"), UndoManager = require("./undo-manager"), EventEmitter = require("./event-emitter"), elementHelpers = require("./element"), nodeHelpers = require("./node"), Immutable = require("immutable/dist/immutable"), config = require("./config");
Scribe.prototype = Object.create(EventEmitter.prototype), Scribe.prototype.use = function(configurePlugin) {
return configurePlugin(this), this;
}, Scribe.prototype.setHTML = function(html, skipFormatters) {
this._lastItem.content = html, skipFormatters && (this._skipFormatters = !0), this.el.innerHTML !== html && (this.el.innerHTML = html);
}, Scribe.prototype.getHTML = function() {
return this.el.innerHTML;
}, Scribe.prototype.getContent = function() {
return this._htmlFormatterFactory.formatForExport(this.getHTML().replace(/<br>$/, ""));
}, Scribe.prototype.getTextContent = function() {
return this.el.textContent;
}, Scribe.prototype.pushHistory = function() {
var scribe = this;
if (scribe.options.undo.enabled) {
var lastContentNoMarkers = scribe._lastItem.content.replace(/<em class="scribe-marker">[^<]*?<\/em>/g, "");
if (scribe.getHTML() !== lastContentNoMarkers) {
var selection = new scribe.api.Selection();
selection.placeMarkers();
var content = scribe.getHTML();
selection.removeMarkers();
var previousItem = scribe.undoManager.item(scribe.undoManager.position);
return (scribe._merge || scribe._forceMerge) && previousItem && scribe._lastItem == previousItem[0] ? scribe._lastItem.content = content :(scribe._lastItem = {
previousItem:scribe._lastItem,
content:content,
scribe:scribe,
execute:function() {},
undo:function() {
this.scribe.restoreFromHistory(this.previousItem);
},
redo:function() {
this.scribe.restoreFromHistory(this);
}
}, scribe.undoManager.transact(scribe._lastItem, !1)), clearTimeout(scribe._mergeTimer), 
scribe._merge = !0, scribe._mergeTimer = setTimeout(function() {
scribe._merge = !1;
}, scribe.options.undo.interval), !0;
}
}
return !1;
}, Scribe.prototype.getCommand = function(commandName) {
return this.commands[commandName] || this.commandPatches[commandName] || new this.api.Command(commandName);
}, Scribe.prototype.restoreFromHistory = function(historyItem) {
this._lastItem = historyItem, this.setHTML(historyItem.content, !0);
var selection = new this.api.Selection();
selection.selectMarkers(), this.trigger("content-changed");
}, Scribe.prototype.allowsBlockElements = function() {
return this.options.allowBlockElements;
}, Scribe.prototype.setContent = function(content) {
this.allowsBlockElements() || (content += "<br>"), this.setHTML(content), this.trigger("content-changed");
}, Scribe.prototype.insertPlainText = function(plainText) {
this.insertHTML("<p>" + this._plainTextFormatterFactory.format(plainText) + "</p>");
}, Scribe.prototype.insertHTML = function(html) {
this.getCommand("insertHTML").execute(this._htmlFormatterFactory.format(html));
}, Scribe.prototype.isDebugModeEnabled = function() {
return this.options.debug;
}, Scribe.prototype.registerHTMLFormatter = function(phase, formatter) {
this._htmlFormatterFactory.formatters[phase] = this._htmlFormatterFactory.formatters[phase].push(formatter);
}, Scribe.prototype.registerPlainTextFormatter = function(formatter) {
this._plainTextFormatterFactory.formatters = this._plainTextFormatterFactory.formatters.push(formatter);
}, FormatterFactory.prototype.format = function(html) {
var formatted = this.formatters.reduce(function(formattedData, formatter) {
return formatter(formattedData);
}, html);
return formatted;
}, HTMLFormatterFactory.prototype = Object.create(FormatterFactory.prototype), HTMLFormatterFactory.prototype.constructor = HTMLFormatterFactory, 
HTMLFormatterFactory.prototype.format = function(html) {
var formatters = this.formatters.sanitize.concat(this.formatters.normalize), formatted = formatters.reduce(function(formattedData, formatter) {
return formatter(formattedData);
}, html);
return formatted;
}, HTMLFormatterFactory.prototype.formatForExport = function(html) {
return this.formatters["export"].reduce(function(formattedData, formatter) {
return formatter(formattedData);
}, html);
}, module.exports = Scribe;
}, {
"./api":59,
"./config":66,
"./element":68,
"./event-emitter":69,
"./node":70,
"./plugins/core/commands":71,
"./plugins/core/events":79,
"./plugins/core/formatters":80,
"./plugins/core/patches":86,
"./plugins/core/plugins":94,
"./transaction-manager":97,
"./undo-manager":98,
"immutable/dist/immutable":1
} ],
97:[ function(require, module) {
var assign = require("lodash-amd/modern/object/assign");
module.exports = function(scribe) {
function TransactionManager() {
this.history = [];
}
return assign(TransactionManager.prototype, {
start:function() {
this.history.push(1);
},
end:function() {
this.history.pop(), 0 === this.history.length && (scribe.pushHistory(), scribe.trigger("content-changed"));
},
run:function(transaction, forceMerge) {
this.start();
try {
transaction && transaction();
} finally {
scribe._forceMerge = forceMerge === !0, this.end(), scribe._forceMerge = !1;
}
}
}), TransactionManager;
};
}, {
"lodash-amd/modern/object/assign":48
} ],
98:[ function(require, module) {
"use strict";
function UndoManager(limit, undoScopeHost) {
this._stack = [], this._limit = limit, this._fireEvent = "undefined" != typeof CustomEvent && undoScopeHost && undoScopeHost.dispatchEvent, 
this._ush = undoScopeHost, this.position = 0, this.length = 0;
}
UndoManager.prototype.transact = function(transaction, merge) {
if (arguments.length < 2) throw new TypeError("Not enough arguments to UndoManager.transact.");
transaction.execute(), this._stack.splice(0, this.position), merge && this.length ? this._stack[0].push(transaction) :this._stack.unshift([ transaction ]), 
this.position = 0, this.length = this._limit && this._stack.length > this._limit ? this._stack.length = this._limit :this._stack.length, 
this._fireEvent && this._ush.dispatchEvent(new CustomEvent("DOMTransaction", {
detail:{
transactions:this._stack[0].slice()
},
bubbles:!0,
cancelable:!1
}));
}, UndoManager.prototype.undo = function() {
if (this.position < this.length) {
for (var i = this._stack[this.position].length - 1; i >= 0; i--) this._stack[this.position][i].undo();
this.position++, this._fireEvent && this._ush.dispatchEvent(new CustomEvent("undo", {
detail:{
transactions:this._stack[this.position - 1].slice()
},
bubbles:!0,
cancelable:!1
}));
}
}, UndoManager.prototype.redo = function() {
if (this.position > 0) {
for (var i = 0, n = this._stack[this.position - 1].length; n > i; i++) this._stack[this.position - 1][i].redo();
this.position--, this._fireEvent && this._ush.dispatchEvent(new CustomEvent("redo", {
detail:{
transactions:this._stack[this.position].slice()
},
bubbles:!0,
cancelable:!1
}));
}
}, UndoManager.prototype.item = function(index) {
return index >= 0 && index < this.length ? this._stack[index].slice() :null;
}, UndoManager.prototype.clearUndo = function() {
this._stack.length = this.length = this.position;
}, UndoManager.prototype.clearRedo = function() {
this._stack.splice(0, this.position), this.position = 0, this.length = this._stack.length;
}, module.exports = UndoManager;
}, {} ],
99:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
var blockquoteCommand = new scribe.api.SimpleCommand("blockquote", "BLOCKQUOTE");
blockquoteCommand.execute = function() {
var command = scribe.getCommand(this.queryState() ? "outdent" :"indent");
command.execute();
}, blockquoteCommand.queryEnabled = function() {
var command = scribe.getCommand(this.queryState() ? "outdent" :"indent");
return command.queryEnabled();
}, blockquoteCommand.queryState = function() {
var selection = new scribe.api.Selection(), blockquoteElement = selection.getContaining(function(element) {
return "BLOCKQUOTE" === element.nodeName;
});
return scribe.allowsBlockElements() && !!blockquoteElement;
}, scribe.commands.blockquote = blockquoteCommand, scribe.allowsBlockElements() && scribe.el.addEventListener("keydown", function(event) {
if (13 === event.keyCode) {
var command = scribe.getCommand("blockquote");
if (command.queryState()) {
var selection = new scribe.api.Selection();
selection.isCaretOnNewLine() && (event.preventDefault(), command.execute());
}
}
});
};
};
}, {} ],
100:[ function(require, module) {
"use strict";
module.exports = function() {
return function(scribe) {
function moveChildren(fromNode, toNode) {
for (var nextChild, child = fromNode.firstChild; child; ) nextChild = child.nextSibling, 
toNode.appendChild(child), child = nextChild;
}
function copyAttributes(fromNode, toNode) {
if (fromNode.hasAttributes()) for (var i = 0, ii = fromNode.attributes.length; ii > i; i++) {
var attr = fromNode.attributes[i].cloneNode(!1);
toNode.attributes.setNamedItem(attr);
}
}
function replaceNode(node, nodeName) {
var newNode = document.createElement(nodeName);
moveChildren(node, newNode), copyAttributes(node, newNode), node.parentNode.replaceChild(newNode, node);
}
function traverse(parentNode) {
for (var nextSibling, el = parentNode.firstElementChild; el; ) {
nextSibling = el.nextElementSibling, traverse(el);
var nodeName = map[el.nodeName];
nodeName && replaceNode(el, nodeName), el = nextSibling;
}
}
var map = {
B:"strong",
I:"em"
};
scribe.registerHTMLFormatter("normalize", function(html) {
if ("string" == typeof html) {
var node = document.createElement("div");
return node.innerHTML = html, traverse(node), node.innerHTML;
}
return traverse(html), html;
});
};
};
}, {} ],
101:[ function(require, module) {
"use strict";
module.exports = function(level) {
return function(scribe) {
var tag = "<h" + level + ">", nodeName = "H" + level, commandName = "h" + level, headingCommand = new scribe.api.Command("formatBlock");
headingCommand.execute = function() {
this.queryState() ? scribe.api.Command.prototype.execute.call(this, "<p>") :scribe.api.Command.prototype.execute.call(this, tag);
}, headingCommand.queryState = function() {
var selection = new scribe.api.Selection();
return !!selection.getContaining(function(node) {
return node.nodeName === nodeName;
});
}, headingCommand.queryEnabled = function() {
var selection = new scribe.api.Selection(), listNode = selection.getContaining(function(node) {
return "OL" === node.nodeName || "UL" === node.nodeName;
});
return scribe.api.Command.prototype.queryEnabled.apply(this, arguments) && scribe.allowsBlockElements() && !listNode;
}, scribe.commands[commandName] = headingCommand;
};
};
}, {} ],
102:[ function(require, module) {
function bind(func, thisArg) {
return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) :createWrapper(func, 1, null, null, thisArg);
}
var createWrapper = require("../internals/createWrapper"), slice = require("../internals/slice");
module.exports = bind;
}, {
"../internals/createWrapper":110,
"../internals/slice":118
} ],
103:[ function(require, module) {
function createCallback(func, thisArg, argCount) {
var type = typeof func;
if (null == func || "function" == type) return baseCreateCallback(func, thisArg, argCount);
if ("object" != type) return property(func);
var props = keys(func), key = props[0], a = func[key];
return 1 != props.length || a !== a || isObject(a) ? function(object) {
for (var length = props.length, result = !1; length-- && (result = baseIsEqual(object[props[length]], func[props[length]], null, !0)); ) ;
return result;
} :function(object) {
var b = object[key];
return a === b && (0 !== a || 1 / a == 1 / b);
};
}
var baseCreateCallback = require("../internals/baseCreateCallback"), baseIsEqual = require("../internals/baseIsEqual"), isObject = require("../objects/isObject"), keys = require("../objects/keys"), property = require("../utilities/property");
module.exports = createCallback;
}, {
"../internals/baseCreateCallback":107,
"../internals/baseIsEqual":109,
"../objects/isObject":123,
"../objects/keys":124,
"../utilities/property":128
} ],
104:[ function(require, module) {
var arrayPool = [];
module.exports = arrayPool;
}, {} ],
105:[ function(require, module) {
function baseBind(bindData) {
function bound() {
if (partialArgs) {
var args = slice(partialArgs);
push.apply(args, arguments);
}
if (this instanceof bound) {
var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
return isObject(result) ? result :thisBinding;
}
return func.apply(thisArg, args || arguments);
}
var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
return setBindData(bound, bindData), bound;
}
var baseCreate = require("./baseCreate"), isObject = require("../objects/isObject"), setBindData = require("./setBindData"), slice = require("./slice"), arrayRef = [], push = arrayRef.push;
module.exports = baseBind;
}, {
"../objects/isObject":123,
"./baseCreate":106,
"./setBindData":116,
"./slice":118
} ],
106:[ function(require, module) {
function baseCreate(prototype) {
return isObject(prototype) ? nativeCreate(prototype) :{};
}
var isNative = require("./isNative"), isObject = require("../objects/isObject"), nativeCreate = (require("../utilities/noop"), 
isNative(nativeCreate = Object.create) && nativeCreate);
nativeCreate || (baseCreate = function() {
function Object() {}
return function(prototype) {
if (isObject(prototype)) {
Object.prototype = prototype;
var result = new Object();
Object.prototype = null;
}
return result || window.Object();
};
}()), module.exports = baseCreate;
}, {
"../objects/isObject":123,
"../utilities/noop":127,
"./isNative":112
} ],
107:[ function(require, module) {
function baseCreateCallback(func, thisArg, argCount) {
if ("function" != typeof func) return identity;
if ("undefined" == typeof thisArg || !("prototype" in func)) return func;
var bindData = func.__bindData__;
if ("undefined" == typeof bindData && (support.funcNames && (bindData = !func.name), 
bindData = bindData || !support.funcDecomp, !bindData)) {
var source = fnToString.call(func);
support.funcNames || (bindData = !reFuncName.test(source)), bindData || (bindData = reThis.test(source), 
setBindData(func, bindData));
}
if (bindData === !1 || bindData !== !0 && 1 & bindData[1]) return func;
switch (argCount) {
case 1:
return function(value) {
return func.call(thisArg, value);
};

case 2:
return function(a, b) {
return func.call(thisArg, a, b);
};

case 3:
return function(value, index, collection) {
return func.call(thisArg, value, index, collection);
};

case 4:
return function(accumulator, value, index, collection) {
return func.call(thisArg, accumulator, value, index, collection);
};
}
return bind(func, thisArg);
}
var bind = require("../functions/bind"), identity = require("../utilities/identity"), setBindData = require("./setBindData"), support = require("../support"), reFuncName = /^\s*function[ \n\r\t]+\w/, reThis = /\bthis\b/, fnToString = Function.prototype.toString;
module.exports = baseCreateCallback;
}, {
"../functions/bind":102,
"../support":125,
"../utilities/identity":126,
"./setBindData":116
} ],
108:[ function(require, module) {
function baseCreateWrapper(bindData) {
function bound() {
var thisBinding = isBind ? thisArg :this;
if (partialArgs) {
var args = slice(partialArgs);
push.apply(args, arguments);
}
if ((partialRightArgs || isCurry) && (args || (args = slice(arguments)), partialRightArgs && push.apply(args, partialRightArgs), 
isCurry && args.length < arity)) return bitmask |= 16, baseCreateWrapper([ func, isCurryBound ? bitmask :-4 & bitmask, args, null, thisArg, arity ]);
if (args || (args = arguments), isBindKey && (func = thisBinding[key]), this instanceof bound) {
thisBinding = baseCreate(func.prototype);
var result = func.apply(thisBinding, args);
return isObject(result) ? result :thisBinding;
}
return func.apply(thisBinding, args);
}
var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5], isBind = 1 & bitmask, isBindKey = 2 & bitmask, isCurry = 4 & bitmask, isCurryBound = 8 & bitmask, key = func;
return setBindData(bound, bindData), bound;
}
var baseCreate = require("./baseCreate"), isObject = require("../objects/isObject"), setBindData = require("./setBindData"), slice = require("./slice"), arrayRef = [], push = arrayRef.push;
module.exports = baseCreateWrapper;
}, {
"../objects/isObject":123,
"./baseCreate":106,
"./setBindData":116,
"./slice":118
} ],
109:[ function(require, module) {
function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
if (callback) {
var result = callback(a, b);
if ("undefined" != typeof result) return !!result;
}
if (a === b) return 0 !== a || 1 / a == 1 / b;
var type = typeof a, otherType = typeof b;
if (!(a !== a || a && objectTypes[type] || b && objectTypes[otherType])) return !1;
if (null == a || null == b) return a === b;
var className = toString.call(a), otherClass = toString.call(b);
if (className == argsClass && (className = objectClass), otherClass == argsClass && (otherClass = objectClass), 
className != otherClass) return !1;
switch (className) {
case boolClass:
case dateClass:
return +a == +b;

case numberClass:
return a != +a ? b != +b :0 == a ? 1 / a == 1 / b :a == +b;

case regexpClass:
case stringClass:
return a == String(b);
}
var isArr = className == arrayClass;
if (!isArr) {
var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
if (aWrapped || bWrapped) return baseIsEqual(aWrapped ? a.__wrapped__ :a, bWrapped ? b.__wrapped__ :b, callback, isWhere, stackA, stackB);
if (className != objectClass) return !1;
var ctorA = a.constructor, ctorB = b.constructor;
if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && "constructor" in a && "constructor" in b) return !1;
}
var initedStack = !stackA;
stackA || (stackA = getArray()), stackB || (stackB = getArray());
for (var length = stackA.length; length--; ) if (stackA[length] == a) return stackB[length] == b;
var size = 0;
if (result = !0, stackA.push(a), stackB.push(b), isArr) {
if (length = a.length, size = b.length, result = size == length, result || isWhere) for (;size--; ) {
var index = length, value = b[size];
if (isWhere) for (;index-- && !(result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)); ) ; else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) break;
}
} else forIn(b, function(value, key, b) {
return hasOwnProperty.call(b, key) ? (size++, result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB)) :void 0;
}), result && !isWhere && forIn(a, function(value, key, a) {
return hasOwnProperty.call(a, key) ? result = --size > -1 :void 0;
});
return stackA.pop(), stackB.pop(), initedStack && (releaseArray(stackA), releaseArray(stackB)), 
result;
}
var forIn = require("../objects/forIn"), getArray = require("./getArray"), isFunction = require("../objects/isFunction"), objectTypes = require("./objectTypes"), releaseArray = require("./releaseArray"), argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]", objectProto = Object.prototype, toString = objectProto.toString, hasOwnProperty = objectProto.hasOwnProperty;
module.exports = baseIsEqual;
}, {
"../objects/forIn":120,
"../objects/isFunction":122,
"./getArray":111,
"./objectTypes":114,
"./releaseArray":115
} ],
110:[ function(require, module) {
function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
var isBind = 1 & bitmask, isBindKey = 2 & bitmask, isCurry = 4 & bitmask, isPartial = 16 & bitmask, isPartialRight = 32 & bitmask;
if (!isBindKey && !isFunction(func)) throw new TypeError();
isPartial && !partialArgs.length && (bitmask &= -17, isPartial = partialArgs = !1), 
isPartialRight && !partialRightArgs.length && (bitmask &= -33, isPartialRight = partialRightArgs = !1);
var bindData = func && func.__bindData__;
if (bindData && bindData !== !0) return bindData = slice(bindData), bindData[2] && (bindData[2] = slice(bindData[2])), 
bindData[3] && (bindData[3] = slice(bindData[3])), !isBind || 1 & bindData[1] || (bindData[4] = thisArg), 
!isBind && 1 & bindData[1] && (bitmask |= 8), !isCurry || 4 & bindData[1] || (bindData[5] = arity), 
isPartial && push.apply(bindData[2] || (bindData[2] = []), partialArgs), isPartialRight && unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs), 
bindData[1] |= bitmask, createWrapper.apply(null, bindData);
var creater = 1 == bitmask || 17 === bitmask ? baseBind :baseCreateWrapper;
return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
}
var baseBind = require("./baseBind"), baseCreateWrapper = require("./baseCreateWrapper"), isFunction = require("../objects/isFunction"), slice = require("./slice"), arrayRef = [], push = arrayRef.push, unshift = arrayRef.unshift;
module.exports = createWrapper;
}, {
"../objects/isFunction":122,
"./baseBind":105,
"./baseCreateWrapper":108,
"./slice":118
} ],
111:[ function(require, module) {
function getArray() {
return arrayPool.pop() || [];
}
var arrayPool = require("./arrayPool");
module.exports = getArray;
}, {
"./arrayPool":104
} ],
112:[ function(require, module) {
function isNative(value) {
return "function" == typeof value && reNative.test(value);
}
var objectProto = Object.prototype, toString = objectProto.toString, reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
module.exports = isNative;
}, {} ],
113:[ function(require, module) {
var maxPoolSize = 40;
module.exports = maxPoolSize;
}, {} ],
114:[ function(require, module) {
var objectTypes = {
"boolean":!1,
"function":!0,
object:!0,
number:!1,
string:!1,
undefined:!1
};
module.exports = objectTypes;
}, {} ],
115:[ function(require, module) {
function releaseArray(array) {
array.length = 0, arrayPool.length < maxPoolSize && arrayPool.push(array);
}
var arrayPool = require("./arrayPool"), maxPoolSize = require("./maxPoolSize");
module.exports = releaseArray;
}, {
"./arrayPool":104,
"./maxPoolSize":113
} ],
116:[ function(require, module) {
var isNative = require("./isNative"), noop = require("../utilities/noop"), descriptor = {
configurable:!1,
enumerable:!1,
value:null,
writable:!1
}, defineProperty = function() {
try {
var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
} catch (e) {}
return result;
}(), setBindData = defineProperty ? function(func, value) {
descriptor.value = value, defineProperty(func, "__bindData__", descriptor);
} :noop;
module.exports = setBindData;
}, {
"../utilities/noop":127,
"./isNative":112
} ],
117:[ function(require, module) {
var objectTypes = require("./objectTypes"), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, shimKeys = function(object) {
var index, iterable = object, result = [];
if (!iterable) return result;
if (!objectTypes[typeof object]) return result;
for (index in iterable) hasOwnProperty.call(iterable, index) && result.push(index);
return result;
};
module.exports = shimKeys;
}, {
"./objectTypes":114
} ],
118:[ function(require, module) {
function slice(array, start, end) {
start || (start = 0), "undefined" == typeof end && (end = array ? array.length :0);
for (var index = -1, length = end - start || 0, result = Array(0 > length ? 0 :length); ++index < length; ) result[index] = array[start + index];
return result;
}
module.exports = slice;
}, {} ],
119:[ function(require, module) {
function findKey(object, callback, thisArg) {
var result;
return callback = createCallback(callback, thisArg, 3), forOwn(object, function(value, key, object) {
return callback(value, key, object) ? (result = key, !1) :void 0;
}), result;
}
var createCallback = require("../functions/createCallback"), forOwn = require("./forOwn");
module.exports = findKey;
}, {
"../functions/createCallback":103,
"./forOwn":121
} ],
120:[ function(require, module) {
var baseCreateCallback = require("../internals/baseCreateCallback"), objectTypes = require("../internals/objectTypes"), forIn = function(collection, callback, thisArg) {
var index, iterable = collection, result = iterable;
if (!iterable) return result;
if (!objectTypes[typeof iterable]) return result;
callback = callback && "undefined" == typeof thisArg ? callback :baseCreateCallback(callback, thisArg, 3);
for (index in iterable) if (callback(iterable[index], index, collection) === !1) return result;
return result;
};
module.exports = forIn;
}, {
"../internals/baseCreateCallback":107,
"../internals/objectTypes":114
} ],
121:[ function(require, module) {
var baseCreateCallback = require("../internals/baseCreateCallback"), keys = require("./keys"), objectTypes = require("../internals/objectTypes"), forOwn = function(collection, callback, thisArg) {
var index, iterable = collection, result = iterable;
if (!iterable) return result;
if (!objectTypes[typeof iterable]) return result;
callback = callback && "undefined" == typeof thisArg ? callback :baseCreateCallback(callback, thisArg, 3);
for (var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length :0; ++ownIndex < length; ) if (index = ownProps[ownIndex], 
callback(iterable[index], index, collection) === !1) return result;
return result;
};
module.exports = forOwn;
}, {
"../internals/baseCreateCallback":107,
"../internals/objectTypes":114,
"./keys":124
} ],
122:[ function(require, module) {
function isFunction(value) {
return "function" == typeof value;
}
module.exports = isFunction;
}, {} ],
123:[ function(require, module) {
function isObject(value) {
return !(!value || !objectTypes[typeof value]);
}
var objectTypes = require("../internals/objectTypes");
module.exports = isObject;
}, {
"../internals/objectTypes":114
} ],
124:[ function(require, module) {
var isNative = require("../internals/isNative"), isObject = require("./isObject"), shimKeys = require("../internals/shimKeys"), nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, keys = nativeKeys ? function(object) {
return isObject(object) ? nativeKeys(object) :[];
} :shimKeys;
module.exports = keys;
}, {
"../internals/isNative":112,
"../internals/shimKeys":117,
"./isObject":123
} ],
125:[ function(require, module) {
var isNative = require("./internals/isNative"), reThis = /\bthis\b/, support = {};
support.funcDecomp = !isNative(window.WinRTError) && reThis.test(function() {
return this;
}), support.funcNames = "string" == typeof Function.name, module.exports = support;
}, {
"./internals/isNative":112
} ],
126:[ function(require, module, exports) {
arguments[4][58][0].apply(exports, arguments);
}, {
dup:58
} ],
127:[ function(require, module) {
function noop() {}
module.exports = noop;
}, {} ],
128:[ function(require, module) {
function property(key) {
return function(object) {
return object[key];
};
}
module.exports = property;
}, {} ],
129:[ function(require, module) {
var findKey = require("lodash-amd/modern/objects/findKey");
module.exports = function(commandsToKeyboardShortcutsMap) {
return function(scribe) {
scribe.el.addEventListener("keydown", function(event) {
var commandName = findKey(commandsToKeyboardShortcutsMap, function(isKeyboardShortcut) {
return isKeyboardShortcut(event);
});
if (commandName) {
var command = scribe.getCommand(commandName);
event.preventDefault(), command.queryEnabled() && command.execute();
}
});
};
};
}, {
"lodash-amd/modern/objects/findKey":119
} ],
130:[ function(require, module, exports) {
!function(root, factory) {
"function" == typeof define && define.amd ? define("html-janitor", factory) :"object" == typeof exports ? module.exports = factory() :root.HTMLJanitor = factory();
}(this, function() {
function HTMLJanitor(config) {
this.config = config;
}
function isBlockElement(node) {
return -1 !== blockElementNames.indexOf(node.nodeName);
}
function isInlineElement(node) {
return -1 !== inlineElementNames.indexOf(node.nodeName);
}
function createTreeWalker(node) {
return document.createTreeWalker(node, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null, !1);
}
var blockElementNames = [ "P", "LI", "TD", "TH", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "PRE" ], inlineElementNames = [ "A", "B", "STRONG", "I", "EM", "SUB", "SUP", "U", "STRIKE" ];
return HTMLJanitor.prototype.clean = function(html) {
var sandbox = document.createElement("div");
return sandbox.innerHTML = html, this._sanitize(sandbox), sandbox.innerHTML;
}, HTMLJanitor.prototype._sanitize = function(parentNode) {
var treeWalker = createTreeWalker(parentNode), node = treeWalker.firstChild();
if (node) do {
var nodeName = node.nodeName.toLowerCase(), allowedAttrs = this.config.tags[nodeName];
if (!node._sanitized) if (node.nodeType !== Node.TEXT_NODE) {
if (node.nodeType === Node.COMMENT_NODE) {
parentNode.removeChild(node), this._sanitize(parentNode);
break;
}
var containsBlockElement, isInline = isInlineElement(node);
isInline && (containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement));
var isInvalid = isInline && containsBlockElement, isNotTopContainer = !!parentNode.parentNode, isNestedBlockElement = isBlockElement(parentNode) && isBlockElement(node) && isNotTopContainer;
if (!this.config.tags[nodeName] || isInvalid || !this.config.keepNestedBlockElements && isNestedBlockElement) {
if ("SCRIPT" !== node.nodeName && "STYLE" !== node.nodeName) for (;node.childNodes.length > 0; ) parentNode.insertBefore(node.childNodes[0], node);
parentNode.removeChild(node), this._sanitize(parentNode);
break;
}
for (var a = 0; a < node.attributes.length; a += 1) {
var attr = node.attributes[a], attrName = attr.name.toLowerCase(), allowedAttrValue = allowedAttrs[attrName] || allowedAttrs === !0, notInAttrList = !allowedAttrValue, valueNotAllowed = allowedAttrValue !== !0 && attr.value !== allowedAttrValue;
(notInAttrList || valueNotAllowed) && (node.removeAttribute(attr.name), a -= 1);
}
this._sanitize(node), node._sanitized = !0;
} else if ("" === node.data.trim() && (node.previousElementSibling && isBlockElement(node.previousElementSibling) || node.nextElementSibling && isBlockElement(node.nextElementSibling))) {
parentNode.removeChild(node), this._sanitize(parentNode);
break;
}
} while (node = treeWalker.nextSibling());
}, HTMLJanitor;
});
}, {} ],
131:[ function(require, module) {
var HTMLJanitor = require("html-janitor"), merge = require("lodash-amd/modern/object/merge"), cloneDeep = require("lodash-amd/modern/lang/cloneDeep");
module.exports = function(config) {
var configAllowMarkers = merge(cloneDeep(config), {
tags:{
em:{
"class":"scribe-marker"
},
br:{}
}
});
return function(scribe) {
var janitor = new HTMLJanitor(configAllowMarkers);
scribe.registerHTMLFormatter("sanitize", janitor.clean.bind(janitor));
};
};
}, {
"html-janitor":130,
"lodash-amd/modern/lang/cloneDeep":38,
"lodash-amd/modern/object/merge":52
} ],
132:[ function(require) {
angular.module("scribe", []).factory("Scribe", function() {
return require("scribe-editor");
}).factory("scribePluginBlockquoteCommand", function() {
return require("scribe-plugin-blockquote-command");
}).factory("scribePluginHeadingCommand", function() {
return require("scribe-plugin-heading-command");
}).factory("scribePluginFormatterHtmlEnsureSemanticElements", function() {
return require("scribe-plugin-formatter-html-ensure-semantic-elements");
}).factory("scribePluginSanitizer", function() {
return require("scribe-plugin-sanitizer");
}).factory("scribePluginKeyboardShortcuts", function() {
return require("scribe-plugin-keyboard-shortcuts");
});
}, {
"scribe-editor":96,
"scribe-plugin-blockquote-command":99,
"scribe-plugin-formatter-html-ensure-semantic-elements":100,
"scribe-plugin-heading-command":101,
"scribe-plugin-keyboard-shortcuts":129,
"scribe-plugin-sanitizer":131
} ]
}, {}, [ 132 ])(132);
}), function() {
"use strict";
function wordCount(string) {
return string && "string" == typeof string ? (string = string.replace(trimRegExp, ""), 
string ? string.split(wordBreakingRegExp).length :0) :0;
}
function useHardLimit(instance) {
return "number" == typeof instance.hardWordLimit && instance.hardWordLimit > -1;
}
function scribePluginWordCountService() {
return scribePluginWordCount;
}
function scribePluginWordCount(options) {
var defaultOptions = {
wordBreakingTagsRegExp:/(<\/(p|h[1-6]|li|blockquote)>|<br>)/g
}, self = function(scribe) {
var startHTML, tm = scribe.transactionManager, originalEnd = tm.end, wordCountHelper = document.createElement("div");
scribe.el.addEventListener("keydown", function(event) {
if (ignoredKeyCodes.indexOf(event.keyCode) < 0 && useHardLimit(self)) {
var selection = new scribe.api.Selection();
selection.placeMarkers(), startHTML = scribe.getHTML(), selection.removeMarkers();
}
}), tm.end = function() {
if (1 === tm.history.length) {
var endHTML = scribe.getHTML();
wordCountHelper.innerHTML = endHTML.replace(self.wordBreakingTagsRegExp, " $1");
var count = wordCount(wordCountHelper.textContent);
if (useHardLimit(self) && count > self.hardWordLimit) {
tm.history.pop(), scribe.el.innerHTML = startHTML || scribe._lastItem.content;
var selection = new scribe.api.Selection();
selection.selectMarkers(), "function" == typeof self.limitCallback && self.limitCallback(count, self.hardWordLimit);
} else originalEnd.call(tm), "function" == typeof self.countCallback && self.countCallback(count);
startHTML = null;
} else originalEnd.call(tm);
};
};
return self.countCallback = options.countCallback, self.limitCallback = options.limitCallback, 
self.hardWordLimit = options.hardWordLimit, self.wordBreakingTagsRegExp = options.wordBreakingTagsRegExp || defaultOptions.wordBreakingTagsRegExp, 
self;
}
angular.module("scribe").factory("scribePluginWordCount", scribePluginWordCountService);
var wordBreakingRegExpSource = "[\\s\\u0020-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007F\\u00A0-\\u00BF\\u00D7\\u00F7\\u037E\\u0387\\u05BE\\u05C0\\u05C3\\u05F3\\u05F4\\u2000-\\u206F\\u20A0-\\u20CF]+", trimRegExp = new RegExp("^" + wordBreakingRegExpSource + "|" + wordBreakingRegExpSource + "$", "gi"), wordBreakingRegExp = new RegExp(wordBreakingRegExpSource, "gi"), ignoredKeyCodes = [ 9, 16, 17, 18, 20, 27, 33, 34, 35, 36, 37, 38, 39, 40, 91, 92, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 224 ];
}(), function() {
"use strict";
function formatter(html) {
return html.replace(adjacentListsRegexp, "");
}
function serviceFactory() {
return pluginFactory;
}
function pluginFactory() {
return pluginInstance;
}
function pluginInstance(scribe) {
scribe.registerHTMLFormatter("normalize", formatter);
}
angular.module("scribe").factory("scribePluginMergeAdjacentLists", serviceFactory);
var adjacentListsRegexp = /<\/ol><ol>|<\/ul><ul>/g;
}(), angular.module("dx.webui.answer", []), function() {
"use strict";
function AnswerBlockService(AnswerBlockTypesEnum) {
var defaults = {
blockId:0,
type:AnswerBlockTypesEnum.HTML,
body:"",
wordCount:0
};
return function(data) {
angular.extend(this, defaults, data);
};
}
angular.module("dx.webui.answer").factory("AnswerBlock", AnswerBlockService), AnswerBlockService.$inject = [ "AnswerBlockTypesEnum" ];
}(), angular.module("dx.webui.answer").constant("AnswerBlockTypesEnum", Object.freeze({
HTML:"html"
})), angular.module("dx.webui.question", []), angular.module("dx.webui.question").constant("CapSettingEnum", Object.freeze({
NONE:0,
SOFT:1,
HARD:2
})), angular.module("dx.webui.blockEditor", [ "dx.webui.keyboard", "dx.webui.detection", "dx.webui.sticky", "scribe" ]), 
function() {
"use strict";
function blockEditorManagerDirective(CapSettingEnum) {
function reduceBlockWordCount(sum, block) {
return sum + block.wordCount;
}
function updateWordCount($scope) {
var totalWordCount = $scope.answer.answerBlocks.reduce(reduceBlockWordCount, 0);
$scope.wordCount = totalWordCount, $scope.question.capSetting === CapSettingEnum.HARD && ($scope.remainingWords = $scope.question.capValue - totalWordCount);
}
function link($scope, $element) {
$scope.wordCountEl = $element.find(".blockEditorManager_wordCount"), updateWordCount($scope);
}
function controller($scope, AnswerBlockTypesEnum) {
var vm = this;
vm.AnswerBlockTypesEnum = AnswerBlockTypesEnum, vm.onBlockChange = function() {
updateWordCount($scope), $scope.$apply(), $scope.onChange($scope.answer);
};
}
var directive = {
restrict:"E",
scope:{
question:"=",
answer:"=",
onChange:"="
},
controllerAs:"vm",
template:'<div dx-sticky-group class="blockEditorManager clearfix"><div ng-repeat="block in answer.answerBlocks"><dx-rtf-block-editor ng-if="block.type == vm.AnswerBlockTypesEnum.HTML" question="question" answer-block="block" on-change="vm.onBlockChange" on-hard-word-limit="vm.onHardWordLimit" remaining-words="remainingWords"></dx-rtf-block-editor></div></div>',
replace:!0,
link:link,
controller:controller
};
return controller.$inject = [ "$scope", "AnswerBlockTypesEnum" ], directive;
}
angular.module("dx.webui.blockEditor").directive("dxBlockEditorManager", blockEditorManagerDirective), 
blockEditorManagerDirective.$inject = [ "CapSettingEnum" ];
}(), function() {
"use strict";
function rtfBlockEditorDirective(Scribe, scribePluginHeadingCommand, scribePluginFormatterHtmlEnsureSemanticElements, scribePluginSanitizer, scribePluginKeyboardShortcuts, scribePluginWordCount, scribePluginMergeAdjacentLists, getKeyboardShortcutChecker, getKeyboardShortcutLabel, detectPlatform, $timeout, $window) {
function parseKeyboardShortcutsConfigs(parser, configs) {
var parsed = {};
for (var key in configs) configs.hasOwnProperty(key) && (parsed[key] = parser(configs[key]));
return parsed;
}
function link($scope, $element) {
function wordCountCallback(count) {
$scope.answerBlock.wordCount = count, $scope.onChange();
}
function hardWordlimitCallback() {
$scope.$apply("hardLimitExceeded = true"), $timeout.cancel(hardLimitTimeout), hardLimitTimeout = $timeout(function() {
$scope.$apply("hardLimitExceeded = false");
}, 1e3);
}
var hardLimitTimeout, contentEl = $element.find("." + CLASSNAME_CONTENT_EL), toolbarEl = $element.find("." + CLASSNAME_TOOLBAR_EL), statusbarEl = $element.find("." + CLASSNAME_STATUSBAR_EL), keyboardShortcutsPluginConfig = parseKeyboardShortcutsConfigs(getKeyboardShortcutChecker, KEYBOARD_SHORTCUTS[SHORTCUTS_PLATFORM]), wordCountPluginInstance = scribePluginWordCount({
countCallback:wordCountCallback,
limitCallback:hardWordlimitCallback
});
contentEl[0].addEventListener("keydown", function(event) {
var TAB_KEYCODE = 9, ESC_KEYCODE = 27;
event.keyCode === TAB_KEYCODE && event.preventDefault(), event.keyCode !== ESC_KEYCODE || event.altKey || event.ctrlKey || event.metaKey || (event.shiftKey ? toolbarEl[0].focus() :statusbarEl[0].focus(), 
$window.getSelection().removeAllRanges());
}), delete keyboardShortcutsPluginConfig.undo, $scope.$watch("remainingWords", function(newVal) {
"number" == typeof newVal && newVal > -1 && (wordCountPluginInstance.hardWordLimit = $scope.answerBlock.wordCount + newVal);
});
var scribe = new Scribe(contentEl[0]);
scribe.use(wordCountPluginInstance), scribe.use(scribePluginSanitizer(MARKUP_WHITELIST)), 
scribe.use(scribePluginFormatterHtmlEnsureSemanticElements()), scribe.use(scribePluginKeyboardShortcuts(keyboardShortcutsPluginConfig)), 
scribe.use(scribePluginHeadingCommand(1)), scribe.use(scribePluginHeadingCommand(2)), 
scribe.use(scribePluginHeadingCommand(3)), scribe.use(scribePluginHeadingCommand(4)), 
scribe.use(scribePluginHeadingCommand(5)), scribe.use(scribePluginHeadingCommand(6)), 
scribe.use(scribePluginMergeAdjacentLists()), scribe.setContent($scope.answerBlock.body || "<p><br></p>"), 
scribe.on("content-changed", function() {
var block = $scope.answerBlock, body = scribe.getHTML();
body !== block.body && (block.body = body, $scope.onChange());
}), $scope.scribe = scribe, $scope.$element = $element;
}
function controller($scope, CapSettingEnum) {
var vm = this;
vm.keyboardShortcutLabels = parseKeyboardShortcutsConfigs(getKeyboardShortcutLabel, KEYBOARD_SHORTCUTS[SHORTCUTS_PLATFORM]), 
vm.wordCountClassNames = function() {
var classNames = [];
return $scope.question.capSetting === CapSettingEnum.SOFT ? (classNames.push(CLASSNAME_SOFT_LIMIT_MOD), 
$scope.answerBlock.wordCount > $scope.question.capValue && classNames.push(CLASSNAME_SOFT_LIMIT_EXCEEDED_MOD)) :$scope.question.capSetting === CapSettingEnum.HARD && (classNames.push(CLASSNAME_HARD_LIMIT_MOD), 
$scope.hardLimitExceeded && classNames.push(CLASSNAME_HARD_LIMIT_EXCEEDED_MOD)), 
classNames;
}, vm.addContentFocus = function() {
$scope.$element.addClass(CLASSNAME_FOCUS_MOD);
}, vm.removeContentFocus = function() {
$scope.$element.removeClass(CLASSNAME_FOCUS_MOD);
}, vm.getWordCountDisplay = function(wordCount, question) {
var string = "" + wordCount;
return question.capSetting === CapSettingEnum.NONE ? string += 1 === wordCount ? " word" :" words" :(string += " / " + question.capValue, 
string += 1 === question.capValue ? " word, " :" words, ", question.capSetting === CapSettingEnum.SOFT ? string += "soft" :question.capSetting === CapSettingEnum.HARD && (string += "hard"), 
string += " limit"), string;
};
}
var directive = {
restrict:"E",
scope:{
answerBlock:"=",
question:"=",
onChange:"=",
remainingWords:"="
},
controllerAs:"vm",
template:'<div class="blockEditor blockEditor-rtf"><dx-rtf-toolbar scribe="scribe" keyboard-shortcut-labels="vm.keyboardShortcutLabels" dx-sticky="top" dx-sticky-docked></dx-rtf-toolbar><div class="blockEditor_content rtfContent" spellcheck="false" ng-focus="vm.addContentFocus()" ng-blur="vm.removeContentFocus()"></div><div class="blockEditor_statusbar" tabindex="0" dx-sticky="bottom" dx-sticky-docked dx-toolbar><div dx-toolbar-spacer></div><div dx-toolbar-group class="blockEditor_wordCount" ng-class="vm.wordCountClassNames()">{{vm.getWordCountDisplay(answerBlock.wordCount, question)}}</div></div></div>',
replace:!0,
link:link,
controller:controller
}, CLASSNAME_ROOT = "blockEditor", CLASSNAME_CONTENT_EL = CLASSNAME_ROOT + "_content", CLASSNAME_TOOLBAR_EL = CLASSNAME_ROOT + "_toolbar", CLASSNAME_STATUSBAR_EL = CLASSNAME_ROOT + "_statusbar", CLASSNAME_WORD_COUNT_EL = CLASSNAME_ROOT + "_wordCount", CLASSNAME_FOCUS_MOD = CLASSNAME_ROOT + "-focus", CLASSNAME_SOFT_LIMIT_MOD = CLASSNAME_WORD_COUNT_EL + "-softLimit", CLASSNAME_HARD_LIMIT_MOD = CLASSNAME_WORD_COUNT_EL + "-hardLimit", CLASSNAME_SOFT_LIMIT_EXCEEDED_MOD = CLASSNAME_SOFT_LIMIT_MOD + "Exceeded", CLASSNAME_HARD_LIMIT_EXCEEDED_MOD = CLASSNAME_HARD_LIMIT_MOD + "Exceeded", MARKUP_WHITELIST = {
tags:{
p:{},
strong:{},
b:{},
em:{},
i:{},
u:{},
h1:{},
h2:{},
h3:{},
h4:{},
h5:{},
h6:{},
ul:{},
ol:{},
li:{}
}
}, SHORTCUTS_PLATFORM = "mac" === detectPlatform() ? "mac" :"win", KEYBOARD_SHORTCUTS = {
win:{
bold:{
modifiersAND:[ "ctrl" ],
keysOR:[ "b" ]
},
italic:{
modifiersAND:[ "ctrl" ],
keysOR:[ "i" ]
},
underline:{
modifiersAND:[ "ctrl" ],
keysOR:[ "u" ]
},
h1:{
modifiersAND:[ "ctrl", "alt" ],
keysOR:[ "1", "numPad1" ]
},
h2:{
modifiersAND:[ "ctrl", "alt" ],
keysOR:[ "2", "numPad2" ]
},
h3:{
modifiersAND:[ "ctrl", "alt" ],
keysOR:[ "3", "numPad3" ]
},
h4:{
modifiersAND:[ "ctrl", "alt" ],
keysOR:[ "4", "numPad4" ]
},
h5:{
modifiersAND:[ "ctrl", "alt" ],
keysOR:[ "5", "numPad5" ]
},
h6:{
modifiersAND:[ "ctrl", "alt" ],
keysOR:[ "6", "numPad6" ]
},
insertOrderedList:{
modifiersAND:[ "ctrl", "shift" ],
keysOR:[ "7" ]
},
insertUnorderedList:{
modifiersAND:[ "ctrl", "shift" ],
keysOR:[ "8" ]
},
removeFormat:{
modifiersAND:[ "ctrl" ],
keysOR:[ "\\" ]
},
undo:{
modifiersAND:[ "ctrl" ],
keysOR:[ "z" ]
},
redo:{
modifiersAND:[ "ctrl" ],
keysOR:[ "y" ]
}
},
mac:{
bold:{
modifiersAND:[ "meta" ],
keysOR:[ "b" ]
},
italic:{
modifiersAND:[ "meta" ],
keysOR:[ "i" ]
},
underline:{
modifiersAND:[ "meta" ],
keysOR:[ "u" ]
},
h1:{
modifiersAND:[ "meta", "alt" ],
keysOR:[ "1", "numPad1" ]
},
h2:{
modifiersAND:[ "meta", "alt" ],
keysOR:[ "2", "numPad2" ]
},
h3:{
modifiersAND:[ "meta", "alt" ],
keysOR:[ "3", "numPad3" ]
},
h4:{
modifiersAND:[ "meta", "alt" ],
keysOR:[ "4", "numPad4" ]
},
h5:{
modifiersAND:[ "meta", "alt" ],
keysOR:[ "5", "numPad5" ]
},
h6:{
modifiersAND:[ "meta", "alt" ],
keysOR:[ "6", "numPad6" ]
},
insertOrderedList:{
modifiersAND:[ "meta", "shift" ],
keysOR:[ "7" ]
},
insertUnorderedList:{
modifiersAND:[ "meta", "shift" ],
keysOR:[ "8" ]
},
removeFormat:{
modifiersAND:[ "meta" ],
keysOR:[ "\\" ]
},
undo:{
modifiersAND:[ "meta" ],
keysOR:[ "z" ]
},
redo:{
modifiersAND:[ "meta" ],
keysOR:[ "y" ]
}
}
};
return controller.$inject = [ "$scope", "CapSettingEnum" ], directive;
}
angular.module("dx.webui.blockEditor").directive("dxRtfBlockEditor", rtfBlockEditorDirective), 
rtfBlockEditorDirective.$inject = [ "Scribe", "scribePluginHeadingCommand", "scribePluginFormatterHtmlEnsureSemanticElements", "scribePluginSanitizer", "scribePluginKeyboardShortcuts", "scribePluginWordCount", "scribePluginMergeAdjacentLists", "getKeyboardShortcutChecker", "getKeyboardShortcutLabel", "detectPlatform", "$timeout", "$window" ];
}(), function() {
"use strict";
function rtfToolbarDirective() {
function link($scope, $element) {
function executeCommand() {
if ($scope.scribe) {
var command = $scope.scribe.getCommand(this.getAttribute("data-command-name"));
$scope.scribe.el.focus(), command.execute(this.getAttribute("data-command-value"));
}
}
function bindUpdateUi() {
$scope.scribe.el.addEventListener("keyup", updateUi), $scope.scribe.el.addEventListener("mouseup", updateUi), 
$scope.scribe.el.addEventListener("focus", updateUi), $scope.scribe.el.addEventListener("blur", updateUi), 
$scope.scribe.on("content-changed", updateUi);
}
function updateUi() {
$buttons.each(updateButton);
}
function updateButton() {
var command = $scope.scribe.getCommand(this.getAttribute("data-command-name")), selection = new $scope.scribe.api.Selection();
selection.range && command.queryState(this.getAttribute("data-command-value")) ? this.classList.add("active") :this.classList.remove("active"), 
selection.range && command.queryEnabled() ? this.removeAttribute("disabled") :this.setAttribute("disabled", "disabled");
}
var $buttons = $element.find("[data-command-name]");
$scope.$watch("scribe", bindUpdateUi), $buttons.on("click", executeCommand);
}
var directive = {
restrict:"E",
scope:{
scribe:"=",
keyboardShortcutLabels:"="
},
controllerAs:"vm",
template:'<div class="blockEditor_toolbar" tabindex="0" dx-toolbar dx-toolbar-nowrap layout-align="start start"><div dx-toolbar><div dx-toolbar-group><button data-command-name="bold" title="Bold ({{keyboardShortcutLabels.bold}})"><i dx-icon="bold"></i></button> <button data-command-name="italic" title="Italic ({{keyboardShortcutLabels.italic}})"><i dx-icon="italic"></i></button> <button data-command-name="underline" title="Underline ({{keyboardShortcutLabels.underline}})"><i dx-icon="underline"></i></button></div><div dx-toolbar-group><button data-command-name="h1" title="Heading 1 ({{keyboardShortcutLabels.h1}})"><i dx-icon="h1"></i></button> <button data-command-name="h2" title="Heading 2 ({{keyboardShortcutLabels.h2}})"><i dx-icon="h2"></i></button> <button data-command-name="h3" title="Heading 3 ({{keyboardShortcutLabels.h3}})"><i dx-icon="h3"></i></button> <button data-command-name="h4" title="Heading 4 ({{keyboardShortcutLabels.h4}})"><i dx-icon="h4"></i></button> <button data-command-name="h5" title="Heading 5 ({{keyboardShortcutLabels.h5}})"><i dx-icon="h5"></i></button> <button data-command-name="h6" title="Heading 6 ({{keyboardShortcutLabels.h6}})"><i dx-icon="h6"></i></button></div><div dx-toolbar-group><button data-command-name="insertOrderedList" title="Numbered list ({{keyboardShortcutLabels.insertOrderedList}})"><i dx-icon="list-number"></i></button> <button data-command-name="insertUnorderedList" title="Bullet list ({{keyboardShortcutLabels.insertUnorderedList}})"><i dx-icon="list-disc"></i></button></div><div dx-toolbar-group><button data-command-name="removeFormat" title="Remove formatting ({{keyboardShortcutLabels.removeFormat}})"><i dx-icon="remove-formatting"></i></button></div></div><div dx-toolbar-spacer></div><div dx-toolbar-group dx-toolbar-noshrink><button data-command-name="undo" title="Undo ({{keyboardShortcutLabels.undo}})"><i dx-icon="undo"></i></button> <button data-command-name="redo" title="Redo ({{keyboardShortcutLabels.redo}})"><i dx-icon="redo"></i></button></div></div>',
link:link
};
return directive;
}
angular.module("dx.webui.blockEditor").directive("dxRtfToolbar", rtfToolbarDirective);
}(), angular.module("dx.webui.keyboard", [ "dx.webui.detection" ]), angular.module("dx.webui.keyboard").constant("KeyCodesEnum", Object.freeze({
a:65,
b:66,
c:67,
d:68,
e:69,
f:70,
g:71,
h:72,
i:73,
j:74,
k:75,
l:76,
m:77,
n:78,
o:79,
p:80,
q:81,
r:82,
s:83,
t:84,
u:85,
v:86,
x:88,
y:89,
z:90,
aring:219,
auml:222,
ouml:186,
0:48,
1:49,
2:50,
3:51,
4:52,
5:53,
6:54,
7:55,
8:56,
9:57,
numPad0:96,
numPad1:97,
numPad2:98,
numPad3:99,
numPad4:100,
numPad5:101,
numPad6:102,
numPad7:103,
numPad8:104,
numPad9:105,
"\\":220,
escape:27
})), function() {
"use strict";
function getKeyboardShortcutCheckerService(KeyCodesEnum) {
return function(config) {
return function(event) {
var i, hasModifiers = !0, hasKey = !1;
for (i = config.modifiersAND.length - 1; i >= 0; i--) if (!event[config.modifiersAND[i] + "Key"]) {
hasModifiers = !1;
break;
}
for (i = config.keysOR.length - 1; i >= 0; i--) if (event.keyCode === KeyCodesEnum[config.keysOR[i]]) {
hasKey = !0;
break;
}
return hasModifiers && hasKey;
};
};
}
angular.module("dx.webui.keyboard").factory("getKeyboardShortcutChecker", getKeyboardShortcutCheckerService), 
getKeyboardShortcutCheckerService.$inject = [ "KeyCodesEnum" ];
}(), function() {
"use strict";
function getKeyboardShortcutLabelService(detectPlatform) {
var CMD_CHAR = "\u2318";
return function(config, platform) {
var label = "", mods = config.modifiersAND || [];
return platform || (platform = detectPlatform()), mods.indexOf("meta") > -1 && ("mac" === platform ? (label += CMD_CHAR, 
mods.length > 1 && (label += "+")) :label += "Meta+"), mods.indexOf("ctrl") > -1 && (label += "Ctrl+"), 
mods.indexOf("shift") > -1 && (label += "Shift+"), mods.indexOf("alt") > -1 && (label += "mac" === platform ? "Option+" :"Alt+"), 
label += config.keysOR[0].toUpperCase();
};
}
angular.module("dx.webui.keyboard").factory("getKeyboardShortcutLabel", getKeyboardShortcutLabelService), 
getKeyboardShortcutLabelService.$inject = [ "detectPlatform" ];
}(), angular.module("dx.webui.detection", []), function() {
"use strict";
function detectPlatformService($window) {
var result, cached = !1, iosRegExp = /iphone|ipod|ipad/i;
return function(useCachedResult) {
if ("undefined" == typeof useCachedResult && (useCachedResult = !0), useCachedResult && cached) return result;
var DX = $window.DX, navigatorPlatform = $window.navigator.platform.toLowerCase(), navigatorUA = $window.navigator.userAgent;
return DX && DX.flags && "undefined" != typeof DX.flags.platform ? (result = DX.flags.platform, 
cached = !0) :navigatorPlatform.indexOf("win") >= 0 ? (result = "win", cached = !0) :navigatorPlatform.indexOf("mac") >= 0 ? (result = "mac", 
cached = !0) :navigatorPlatform.indexOf("linux") >= 0 ? (result = "linux", cached = !0) :navigatorUA.indexOf("CrOS") >= 0 ? (result = "chromeos", 
cached = !0) :navigatorPlatform.match(iosRegExp) && (result = "ios", cached = !0), 
result;
};
}
angular.module("dx.webui.detection").factory("detectPlatform", detectPlatformService), 
detectPlatformService.$inject = [ "$window" ];
}(), function() {
"use strict";
function getVendorPrefixedCssPropertyService() {
var testEl, cached = {}, result = {}, prefixes = [ "Moz", "Webkit", "O", "ms" ];
return function(property, useCachedResult) {
if ("undefined" == typeof useCachedResult && (useCachedResult = !0), useCachedResult && cached[property]) return result[property];
if (testEl || (testEl = document.createElement("div")), property in testEl.style) return cached[property] = !0, 
result[property] = property, property;
for (var upper = property.charAt(0).toUpperCase() + property.slice(1), len = prefixes.length; len--; ) if (prefixes[len] + upper in testEl.style) return cached[property] = !0, 
result[property] = prefixes[len] + upper, result[property];
return !1;
};
}
angular.module("dx.webui.detection").factory("getVendorPrefixedCssProperty", getVendorPrefixedCssPropertyService);
}(), angular.module("dx.webui.scroll", []), function() {
"use strict";
function scrollDirective() {
function controller($scope, $element) {
this.$scope = $scope, this.$element = $element;
}
var directive = {
restrict:"A",
controller:controller
};
return directive;
}
angular.module("dx.webui.scroll").directive("dxScroll", scrollDirective);
}(), angular.module("dx.webui.sticky", [ "dx.webui.scroll", "dx.webui.utils", "dx.webui.detection" ]), 
function() {
"use strict";
function stickyDirective(stickyManager, $compile) {
function link($scope, $element, $attr) {
var $clone = angular.element($element[0].outerHTML), docked = "undefined" != typeof $attr.dxStickyDocked;
$clone.removeAttr("dx-sticky").attr("dx-sticky-clone", $attr.dxSticky || "top"), 
$compile($clone)($scope), stickyManager($scope, $element, $clone, docked);
}
var directive = {
restrict:"A",
link:link
};
return directive;
}
angular.module("dx.webui.sticky").directive("dxSticky", stickyDirective), stickyDirective.$inject = [ "stickyManager", "$compile" ];
}(), function() {
"use strict";
function stickyGroupDirective() {
function controller($scope, $element) {
this.$scope = $scope, this.$element = $element;
}
var directive = {
restrict:"A",
controller:controller
};
return directive;
}
angular.module("dx.webui.sticky").directive("dxStickyGroup", stickyGroupDirective);
}(), function() {
"use strict";
function stickyManagerService($$rAF, now, getVendorPrefixedCssProperty) {
function setupManager(scrollCtrl) {
function add($element, $clone, groupCtrl, docked) {
var position = $element.attr("dx-sticky") || "top", $groupElement = groupCtrl.$element, groups = manager.groups, group = groups.filter(function(groupToFilter) {
return groupToFilter.element === $groupElement;
})[0];
group || (group = {
element:$groupElement,
docked:{},
items:0
}, groups.push(group));
var items = manager[position].items, item = {
element:$element,
clone:$clone,
group:group,
position:position
};
return items.push(item), docked && (group.docked[position] = item), scrollEl.parent().prepend($clone), 
debouncedRefreshElements(), function() {
items.forEach(function(itemToRemove, index) {
itemToRemove.element[0] === $element[0] && (items.splice(index, 1), itemToRemove.clone.remove(), 
group.docked[position] === itemToRemove && delete group.docked[position], --itemToRemove.group.items <= 0 && groups.splice(groups.indexOf(itemToRemove.group), 1));
}), debouncedRefreshElements();
};
}
function refreshElements() {
manager.groups.forEach(refreshPosition), refreshElementsPosition("top"), refreshElementsPosition("bottom"), 
onScroll();
}
function refreshElementsPosition(position) {
var items = manager[position].items;
items.forEach(refreshPosition), items = manager[position].items = items.sort(function(a, b) {
return "top" === position ? a.top < b.top ? -1 :1 :a.bottom > b.bottom ? -1 :1;
});
var i, item, fold = scrollEl.prop("scrollTop");
if ("top" === position) {
for (i = items.length - 1; i >= 0; i--) if (fold > items[i].top) {
item = items[i];
break;
}
} else for (fold += scrollEl.height(), i = items.length - 1; i >= 0; i--) if (fold < items[i].bottom) {
item = items[i];
break;
}
setCurrentItem(item, position);
}
function refreshPosition(item) {
var current = item.element[0];
for (item.top = 0, item.left = 0; current && current !== scrollEl[0]; ) item.top += current.offsetTop, 
item.left += current.offsetLeft, current = current.offsetParent;
item.width = item.element.prop("offsetWidth"), item.height = item.element.prop("offsetHeight"), 
item.bottom = item.top + item.height, item.clone && item.clone.css({
left:item.left,
width:item.width
});
}
function onScroll() {
var fold = scrollEl.prop("scrollTop");
onScrollTopItems(fold), onScrollBottomItems(fold);
}
function onScrollTopItems(fold) {
var position = "top", managerTop = manager.top;
if (0 === fold ? setCurrentItem(null, position) :managerTop.next && managerTop.next.top - fold <= 0 ? setCurrentItem(managerTop.next, position) :managerTop.current && fold < managerTop.current.top && setCurrentItem(managerTop.prev, position), 
managerTop.current) {
var dockedBottomHeight = managerTop.current.group.docked.bottom ? managerTop.current.group.docked.bottom.height :0, groupBottomOverflow = managerTop.current.group.bottom - (fold + managerTop.current.height + dockedBottomHeight), nextOverflow = managerTop.next ? managerTop.next.top - managerTop.next.height - fold :0;
0 > groupBottomOverflow ? translate(managerTop.current, groupBottomOverflow) :0 > nextOverflow ? translate(managerTop.current, nextOverflow) :translate(managerTop.current, null);
}
}
function onScrollBottomItems(fold) {
var position = "bottom", managerBottom = manager.bottom;
if (fold += scrollEl[0].offsetHeight, fold === scrollEl[0].scrollHeight ? setCurrentItem(null, position) :managerBottom.next && managerBottom.next.bottom - fold > 0 ? setCurrentItem(managerBottom.next, position) :managerBottom.current && fold > managerBottom.current.bottom && setCurrentItem(managerBottom.prev, position), 
managerBottom.current) {
var dockedTopHeight = managerBottom.current.group.docked.top ? managerBottom.current.group.docked.top.height :0, groupTopOverflow = managerBottom.current.group.top + managerBottom.current.height + dockedTopHeight - fold, nextOverflow = managerBottom.next ? managerBottom.next.bottom + managerBottom.current.height - fold :0;
groupTopOverflow > 0 ? translate(managerBottom.current, groupTopOverflow) :nextOverflow > 0 ? translate(managerBottom.current, nextOverflow) :translate(managerBottom.current, null);
}
}
function setCurrentItem(item, position) {
var managerPosition = manager[position];
if (managerPosition.current !== item) {
managerPosition.current && (translate(managerPosition.current, null), setStickyState(managerPosition.current, null)), 
item && setStickyState(item, "active"), managerPosition.current = item;
var index = managerPosition.items.indexOf(item);
managerPosition.next = managerPosition.items[index + 1], managerPosition.prev = managerPosition.items[index - 1], 
setStickyState(managerPosition.next, "next"), setStickyState(managerPosition.prev, "prev");
}
}
function setStickyState(item, state) {
item && item.state !== state && (item.state && (item.clone.attr("sticky-prev-state", item.state), 
item.element.attr("sticky-prev-state", item.state)), item.clone.attr("sticky-state", state), 
item.element.attr("sticky-state", state), item.state = state);
}
function translate(item, amount) {
if (item && item.translateY !== amount) {
var value = null === amount || void 0 === amount ? "" :"translate3d(0," + amount + "px,0)";
item.translateY = amount, item.clone.css(transformCssProperty, value);
}
}
function setupAugmentedScrollEvents(element) {
function loopScrollEvent() {
+now() - lastScrollTime > SCROLL_END_DELAY ? (isScrolling = !1, element.triggerHandler("$scrollend")) :(element.triggerHandler("$scroll"), 
$$rAF(loopScrollEvent));
}
var isScrolling, lastScrollTime, SCROLL_END_DELAY = 200;
element.on("scroll touchmove", function() {
isScrolling || (isScrolling = !0, $$rAF(loopScrollEvent), element.triggerHandler("$scrollstart")), 
element.triggerHandler("$scroll"), lastScrollTime = +now();
});
}
var scrollEl = scrollCtrl.$element, debouncedRefreshElements = $$rAF.throttle(refreshElements);
setupAugmentedScrollEvents(scrollEl), scrollEl.on("$scrollstart", debouncedRefreshElements), 
scrollEl.on("$scroll", onScroll);
var manager = {
add:add,
refreshElements:refreshElements,
groups:[],
top:{
prev:null,
current:null,
next:null,
items:[]
},
bottom:{
prev:null,
current:null,
next:null,
items:[]
}
};
return manager;
}
var transformCssProperty = getVendorPrefixedCssProperty("transform");
return function($scope, $element, $clone, docked) {
var scrollCtrl = $element.controller("dxScroll");
if (scrollCtrl) {
var groupCtrl = $element.controller("dxStickyGroup");
groupCtrl || (groupCtrl = scrollCtrl);
var managerDataKey = "dxStickyManager", manager = scrollCtrl.$element.data(managerDataKey);
manager || (manager = setupManager(scrollCtrl), scrollCtrl.$element.data(managerDataKey, manager));
var deregister = manager.add($element, $clone, groupCtrl, docked);
$scope.$on("$destroy", deregister);
}
};
}
angular.module("dx.webui.sticky").factory("stickyManager", stickyManagerService), 
stickyManagerService.$inject = [ "$$rAF", "now", "getVendorPrefixedCssProperty" ];
}(), angular.module("dx.webui.utils", []), function() {
"use strict";
function rAFDecoratorConfig($provide) {
function rAFDecorator($delegate) {
return $delegate.throttle = function(cb) {
var queueArgs, alreadyQueued, queueCb, context;
return function() {
queueArgs = arguments, context = this, queueCb = cb, alreadyQueued || (alreadyQueued = !0, 
$delegate(function() {
queueCb.apply(context, queueArgs), alreadyQueued = !1;
}));
};
}, $delegate;
}
$provide.decorator("$$rAF", rAFDecorator), rAFDecorator.$inject = [ "$delegate" ];
}
angular.module("dx.webui.utils").config(rAFDecoratorConfig), rAFDecoratorConfig.$inject = [ "$provide" ];
}(), function() {
"use strict";
function nowService($window) {
return $window.performance ? $window.performance.now.bind($window.performance) :Date.now;
}
angular.module("dx.webui.utils").factory("now", nowService), nowService.$inject = [ "$window" ];
}(), angular.module("dx.webui.grading", []), angular.module("dx.webui.grading").constant("GradingTypeEnum", Object.freeze({
SCORE:0,
FORMATIVE:1
})), function() {
var $ = jQuery, LightboxOptions = function() {
function LightboxOptions() {
this.fadeDuration = 500, this.fitImagesInViewport = !0, this.resizeDuration = 700, 
this.positionFromTop = 50, this.showImageNumberLabel = !0, this.alwaysShowNavOnTouchDevices = !1, 
this.wrapAround = !1;
}
return LightboxOptions.prototype.albumLabel = function(curImageNum, albumSize) {
return "Image " + curImageNum + " of " + albumSize;
}, LightboxOptions;
}(), Lightbox = function() {
function Lightbox(options) {
this.options = options, this.album = [], this.currentImageIndex = void 0, this.init();
}
return Lightbox.prototype.init = function() {
this.enable(), this.build();
}, Lightbox.prototype.enable = function() {
var self = this;
$("body").on("click", "a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]", function(event) {
return self.start($(event.currentTarget)), !1;
});
}, Lightbox.prototype.build = function() {
var self = this;
$("<div id='lightboxOverlay' class='lightboxOverlay'></div><div id='lightbox' class='lightbox'><div class='lb-outerContainer'><div class='lb-container'><img class='lb-image' src='' /><div class='lb-nav'><a class='lb-prev' href='' ></a><a class='lb-next' href='' ></a></div><div class='lb-loader'><a class='lb-cancel'></a></div></div></div><div class='lb-dataContainer'><div class='lb-data'><div class='lb-details'><span class='lb-caption'></span><span class='lb-number'></span></div><div class='lb-closeContainer'><a class='lb-close'></a></div></div></div></div>").appendTo($("body")), 
this.$lightbox = $("#lightbox"), this.$overlay = $("#lightboxOverlay"), this.$outerContainer = this.$lightbox.find(".lb-outerContainer"), 
this.$container = this.$lightbox.find(".lb-container"), this.containerTopPadding = parseInt(this.$container.css("padding-top"), 10), 
this.containerRightPadding = parseInt(this.$container.css("padding-right"), 10), 
this.containerBottomPadding = parseInt(this.$container.css("padding-bottom"), 10), 
this.containerLeftPadding = parseInt(this.$container.css("padding-left"), 10), this.$overlay.hide().on("click", function() {
return self.end(), !1;
}), this.$lightbox.hide().on("click", function(event) {
return "lightbox" === $(event.target).attr("id") && self.end(), !1;
}), this.$outerContainer.on("click", function(event) {
return "lightbox" === $(event.target).attr("id") && self.end(), !1;
}), this.$lightbox.find(".lb-prev").on("click", function() {
return 0 === self.currentImageIndex ? self.changeImage(self.album.length - 1) :self.changeImage(self.currentImageIndex - 1), 
!1;
}), this.$lightbox.find(".lb-next").on("click", function() {
return self.currentImageIndex === self.album.length - 1 ? self.changeImage(0) :self.changeImage(self.currentImageIndex + 1), 
!1;
}), this.$lightbox.find(".lb-loader, .lb-close").on("click", function() {
return self.end(), !1;
});
}, Lightbox.prototype.start = function($link) {
function addToAlbum($link) {
self.album.push({
link:$link.attr("href"),
title:$link.attr("data-title") || $link.attr("title")
});
}
var self = this, $window = $(window);
$window.on("resize", $.proxy(this.sizeOverlay, this)), $("select, object, embed").css({
visibility:"hidden"
}), this.sizeOverlay(), this.album = [];
var $links, imageNumber = 0, dataLightboxValue = $link.attr("data-lightbox");
if (dataLightboxValue) {
$links = $($link.prop("tagName") + '[data-lightbox="' + dataLightboxValue + '"]');
for (var i = 0; i < $links.length; i = ++i) addToAlbum($($links[i])), $links[i] === $link[0] && (imageNumber = i);
} else if ("lightbox" === $link.attr("rel")) addToAlbum($link); else {
$links = $($link.prop("tagName") + '[rel="' + $link.attr("rel") + '"]');
for (var j = 0; j < $links.length; j = ++j) addToAlbum($($links[j])), $links[j] === $link[0] && (imageNumber = j);
}
var top = $window.scrollTop() + this.options.positionFromTop, left = $window.scrollLeft();
this.$lightbox.css({
top:top + "px",
left:left + "px"
}).fadeIn(this.options.fadeDuration), this.changeImage(imageNumber);
}, Lightbox.prototype.changeImage = function(imageNumber) {
var self = this;
this.disableKeyboardNav();
var $image = this.$lightbox.find(".lb-image");
this.$overlay.fadeIn(this.options.fadeDuration), $(".lb-loader").fadeIn("slow"), 
this.$lightbox.find(".lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption").hide(), 
this.$outerContainer.addClass("animating");
var preloader = new Image();
preloader.onload = function() {
var $preloader, imageHeight, imageWidth, maxImageHeight, maxImageWidth, windowHeight, windowWidth;
$image.attr("src", self.album[imageNumber].link), $preloader = $(preloader), $image.width(preloader.width), 
$image.height(preloader.height), self.options.fitImagesInViewport && (windowWidth = $(window).width(), 
windowHeight = $(window).height(), maxImageWidth = windowWidth - self.containerLeftPadding - self.containerRightPadding - 20, 
maxImageHeight = windowHeight - self.containerTopPadding - self.containerBottomPadding - 120, 
(preloader.width > maxImageWidth || preloader.height > maxImageHeight) && (preloader.width / maxImageWidth > preloader.height / maxImageHeight ? (imageWidth = maxImageWidth, 
imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10), $image.width(imageWidth), 
$image.height(imageHeight)) :(imageHeight = maxImageHeight, imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10), 
$image.width(imageWidth), $image.height(imageHeight)))), self.sizeContainer($image.width(), $image.height());
}, preloader.src = this.album[imageNumber].link, this.currentImageIndex = imageNumber;
}, Lightbox.prototype.sizeOverlay = function() {
this.$overlay.width($(window).width()).height($(document).height());
}, Lightbox.prototype.sizeContainer = function(imageWidth, imageHeight) {
function postResize() {
self.$lightbox.find(".lb-dataContainer").width(newWidth), self.$lightbox.find(".lb-prevLink").height(newHeight), 
self.$lightbox.find(".lb-nextLink").height(newHeight), self.showImage();
}
var self = this, oldWidth = this.$outerContainer.outerWidth(), oldHeight = this.$outerContainer.outerHeight(), newWidth = imageWidth + this.containerLeftPadding + this.containerRightPadding, newHeight = imageHeight + this.containerTopPadding + this.containerBottomPadding;
oldWidth !== newWidth || oldHeight !== newHeight ? this.$outerContainer.animate({
width:newWidth,
height:newHeight
}, this.options.resizeDuration, "swing", function() {
postResize();
}) :postResize();
}, Lightbox.prototype.showImage = function() {
this.$lightbox.find(".lb-loader").hide(), this.$lightbox.find(".lb-image").fadeIn("slow"), 
this.updateNav(), this.updateDetails(), this.preloadNeighboringImages(), this.enableKeyboardNav();
}, Lightbox.prototype.updateNav = function() {
var alwaysShowNav = !1;
try {
document.createEvent("TouchEvent"), alwaysShowNav = this.options.alwaysShowNavOnTouchDevices ? !0 :!1;
} catch (e) {}
this.$lightbox.find(".lb-nav").show(), this.album.length > 1 && (this.options.wrapAround ? (alwaysShowNav && this.$lightbox.find(".lb-prev, .lb-next").css("opacity", "1"), 
this.$lightbox.find(".lb-prev, .lb-next").show()) :(this.currentImageIndex > 0 && (this.$lightbox.find(".lb-prev").show(), 
alwaysShowNav && this.$lightbox.find(".lb-prev").css("opacity", "1")), this.currentImageIndex < this.album.length - 1 && (this.$lightbox.find(".lb-next").show(), 
alwaysShowNav && this.$lightbox.find(".lb-next").css("opacity", "1"))));
}, Lightbox.prototype.updateDetails = function() {
var self = this;
"undefined" != typeof this.album[this.currentImageIndex].title && "" !== this.album[this.currentImageIndex].title && this.$lightbox.find(".lb-caption").html(this.album[this.currentImageIndex].title).fadeIn("fast").find("a").on("click", function() {
location.href = $(this).attr("href");
}), this.album.length > 1 && this.options.showImageNumberLabel ? this.$lightbox.find(".lb-number").text(this.options.albumLabel(this.currentImageIndex + 1, this.album.length)).fadeIn("fast") :this.$lightbox.find(".lb-number").hide(), 
this.$outerContainer.removeClass("animating"), this.$lightbox.find(".lb-dataContainer").fadeIn(this.options.resizeDuration, function() {
return self.sizeOverlay();
});
}, Lightbox.prototype.preloadNeighboringImages = function() {
if (this.album.length > this.currentImageIndex + 1) {
var preloadNext = new Image();
preloadNext.src = this.album[this.currentImageIndex + 1].link;
}
if (this.currentImageIndex > 0) {
var preloadPrev = new Image();
preloadPrev.src = this.album[this.currentImageIndex - 1].link;
}
}, Lightbox.prototype.enableKeyboardNav = function() {
$(document).on("keyup.keyboard", $.proxy(this.keyboardAction, this));
}, Lightbox.prototype.disableKeyboardNav = function() {
$(document).off(".keyboard");
}, Lightbox.prototype.keyboardAction = function(event) {
var KEYCODE_ESC = 27, KEYCODE_LEFTARROW = 37, KEYCODE_RIGHTARROW = 39, keycode = event.keyCode, key = String.fromCharCode(keycode).toLowerCase();
keycode === KEYCODE_ESC || key.match(/x|o|c/) ? this.end() :"p" === key || keycode === KEYCODE_LEFTARROW ? 0 !== this.currentImageIndex ? this.changeImage(this.currentImageIndex - 1) :this.options.wrapAround && this.album.length > 1 && this.changeImage(this.album.length - 1) :("n" === key || keycode === KEYCODE_RIGHTARROW) && (this.currentImageIndex !== this.album.length - 1 ? this.changeImage(this.currentImageIndex + 1) :this.options.wrapAround && this.album.length > 1 && this.changeImage(0));
}, Lightbox.prototype.end = function() {
this.disableKeyboardNav(), $(window).off("resize", this.sizeOverlay), this.$lightbox.fadeOut(this.options.fadeDuration), 
this.$overlay.fadeOut(this.options.fadeDuration), $("select, object, embed").css({
visibility:"visible"
});
}, Lightbox;
}();
$(function() {
{
var options = new LightboxOptions();
new Lightbox(options);
}
});
}.call(this);

var hex_chr = "0123456789abcdef".split("");

"5d41402abc4b2a76b9719d911017c592" != md5("hello"), window.isArray = function(obj) {
return "[object Array]" === toString.call(obj);
}, window.isObject = function(obj) {
return "[object Object]" === toString.call(obj);
}, window.isFunction = function(obj) {
return "[object Function]" === toString.call(obj);
}, function() {
for (var lut = [], i = 0; 256 > i; i++) lut[i] = (16 > i ? "0" :"") + i.toString(16);
Math.uuid = function() {
var d0 = 4294967295 * Math.random() | 0, d1 = 4294967295 * Math.random() | 0, d2 = 4294967295 * Math.random() | 0, d3 = 4294967295 * Math.random() | 0;
return lut[255 & d0] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255] + "-" + lut[255 & d1] + lut[d1 >> 8 & 255] + "-" + lut[d1 >> 16 & 15 | 64] + lut[d1 >> 24 & 255] + "-" + lut[63 & d2 | 128] + lut[d2 >> 8 & 255] + "-" + lut[d2 >> 16 & 255] + lut[d2 >> 24 & 255] + lut[255 & d3] + lut[d3 >> 8 & 255] + lut[d3 >> 16 & 255] + lut[d3 >> 24 & 255];
};
}();