(function(){
	"use strict";

	angular.module("scribe").factory("scribePluginWordCount", scribePluginWordCountService);

	var wordBreakingRegExpSource = "[" +
		"\\s" + // White-space characters
		// Unicode ranges to cover a lot of stuff
		// Sort by lowest-highest so it's easy to visually scan and see if something is included.
		"\\u0020-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007F" + // Basic latin
		"\\u00A0-\\u00BF\\u00D7\\u00F7" + // Latin-1 Supplement
		"\\u037E\\u0387" + // Greek
		"\\u05BE\\u05C0\\u05C3\\u05F3\\u05F4" + // Hebrew
		"\\u2000-\\u206F" + // General punctuation
		"\\u20A0-\\u20CF" + // Currency symbols
		"]+";

	var trimRegExp = new RegExp("^" + wordBreakingRegExpSource + "|" + wordBreakingRegExpSource + "$", "gi");
	var wordBreakingRegExp = new RegExp(wordBreakingRegExpSource, "gi");

	// Values taken from https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Value_of_keyCode
	var ignoredKeyCodes = [
		9, // Tab (We're expecting that tab will change element focus and not insert a tab character)
		16, // Shift
		17, // Control
		18, // Alt
		20, // Caps Lock
		27, // Escape
		33, // PageUp
		34, // PageDown
		35, // End
		36, // Home
		37, // ArrowLeft
		38, // ArrowUp
		39, // ArrowRight
		40, // ArrowDown
		91, // OSLeft (OSRight in Gecko on Win/Linux)
		92, // OSRight
		93, // ContextMenu (OSRight in Chrome/Safari on Mac, ContextMenu is 0 there)
		112, // F1
		113, // F2
		114, // F3
		115, // F4
		116, // F5
		117, // F6
		118, // F7
		119, // F8
		120, // F9
		121, // F10
		122, // F11
		123, // F12
		124, // F13
		125, // F14
		126, // F15
		127, // F16
		128, // F17
		129, // F18
		130, // F19
		131, // F20
		132, // F21
		133, // F22
		134, // F23
		135, // F24
		224 // OSLeft/OSRight (Gecko on Mac)
	];

	function wordCount(string) {
		if (!string || typeof string !== "string") {
			return 0;
		}
		string = string.replace(trimRegExp, "");
		if (!string) {
			return 0;
		}
		return string.split(wordBreakingRegExp).length;
	}

	function useHardLimit(instance) {
		return typeof instance.hardWordLimit === "number" && instance.hardWordLimit > -1;
	}

	function scribePluginWordCountService() {
		return scribePluginWordCount;
	}

	function scribePluginWordCount(options) {
		var defaultOptions = {
			// Use the closing tag (</p>) unless the tag is self-closing (<br>).
			// The HTML will come from Element.innerHTML so don't use a slash in
			// self-closing elements.
			wordBreakingTagsRegExp: /(<\/(p|h[1-6]|li|blockquote)>|<br>)/g
		};

		var self = function scribePluginWordCountInstance(scribe) {
			var tm = scribe.transactionManager;
			var originalEnd = tm.end;
			var wordCountHelper = document.createElement("div");
			var startHTML;

			scribe.el.addEventListener("keydown", function(event) {
				if (ignoredKeyCodes.indexOf(event.keyCode) < 0 && useHardLimit(self)) {
					var selection = new scribe.api.Selection();
					selection.placeMarkers();
					startHTML = scribe.getHTML();
					selection.removeMarkers();
				}
			});

			tm.end = function end() {
				if (tm.history.length === 1) {
					// el.textContent will join the text of all elements, so block elements
					// that do not end with a work-breaking character will not cause a work break.
					// This "<h1>One</h1><p>Two</p>" becomes "OneTwo", so we have to make sure
					// there is a word-breaking character at the end of every block element.
					var endHTML = scribe.getHTML();
					wordCountHelper.innerHTML = endHTML.replace(self.wordBreakingTagsRegExp, " $1");
					var count = wordCount(wordCountHelper.textContent);

					if (useHardLimit(self) && count > self.hardWordLimit) {
						// Pop the history since we won't call the original end method that would do it.
						tm.history.pop();
						scribe.el.innerHTML = startHTML || scribe._lastItem.content;
						var selection = new scribe.api.Selection();
						selection.selectMarkers();
						if (typeof self.limitCallback === "function") {
							self.limitCallback(count, self.hardWordLimit);
						}
					} else {
						originalEnd.call(tm);
						if (typeof self.countCallback === "function") {
							self.countCallback(count);
						}
					}

					startHTML = null;
				} else {
					originalEnd.call(tm);
				}
			};
		};

		// Assign the options to the instance so they can be changed later on.
		self.countCallback = options.countCallback;
		self.limitCallback = options.limitCallback;
		self.hardWordLimit = options.hardWordLimit;
		self.wordBreakingTagsRegExp = options.wordBreakingTagsRegExp || defaultOptions.wordBreakingTagsRegExp;

		return self;
	}

}());
