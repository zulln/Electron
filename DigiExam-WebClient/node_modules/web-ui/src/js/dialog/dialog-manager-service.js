(function(){
	"use strict";

	angular.module("dx.webui.dialog").factory("dialogManager", service);

	function service(
		$compile,
		$rootScope,
		$window,
		$http,
		$q,
		$sce,
		KeyCodesEnum
	) {

		var mostRecentDialog;
		var backdrop = angular.element("@@include(inlineTemplate('backdrop.html'))");
		var bodyElement = angular.element($window.document.body);
		var escapeToCloseIsEnabled = false;
		var clickOutsideToCloseIsEnabled = false;

		backdrop.hide().prependTo($window.document.body);

		return {
			show: function show(options) {
				if (!options.template && !options.templateUrl) {
					throw new Error("You must specify a template or templateUrl.");
				}

				options = angular.extend({
					hasBackdrop: true,
					escapeToClose: true,
					clickOutsideToClose: true,
					focusOnOpen: true
					// $scope: $rootScope.scope (optional)
				}, options);

				if (mostRecentDialog) {
					closeMostRecentDialog();
				}

				var dialog = mostRecentDialog = new Dialog(options);

				if (options.templateUrl) {
					dialog.templatePromise = $http.get(options.templateUrl).then(renderDialog, templateLoadingError);
				} else {
					// Create a promise for inline templates too so the dialog interface is consistent.
					var deferred = $q.defer();
					deferred.resolve(dialog);
					dialog.templatePromise = deferred.promise;
					renderDialog({data: options.template});
				}

				function renderDialog(response) {
					var $el = dialog.$element = $compile(response.data)(dialog.$scope);

					// Only show the dialog on the page if it is still the most
					// recent dialog to be opened and has not been closed yet.
					if (dialog === mostRecentDialog) {
						$el.prependTo(bodyElement);

						if (options.focusOnOpen) {
							focusOnOpen(dialog);
						}

						var scrollTop = bodyElement.scrollTop();
						// NOTE(kenneth): Positioning that is compatible with the PopupService (Bootstrap Modal) in the Web App, except we don't scroll to top.
						$el.css("top", scrollTop + Math.round($window.innerHeight / 10));
						// TODO(kenneth): Use this positioning when we don't use the PopupService (Bootstrap Modal) in the Web App any longer.
						//var dialogHeight = $el.outerHeight();
						//$el.css("top", Math.max(scrollTop + 40, scrollTop + ($window.innerHeight / 2) - (dialogHeight / 2)));

						if (options.hasBackdrop) {
							backdrop.show();
						}

						updateEscapeToCloseBinding(options.escapeToClose);
						updateClickOutsideToCloseBinding(options.clickOutsideToClose);
					}

					// Return value for the templatePromise when loading a template from URL.
					return dialog;
				}

				return dialog;
			},

			closeMostRecent: closeMostRecentDialog,

			// Shortcuts to ".show()" a predefined type of dialog.

			confirm: function confirm(options) {
				options = angular.extend({
					template: "@@include(inlineTemplate('confirm.html'))",
					escapeToClose: false,
					clickOutsideToClose: false,
					rejectCallback: closeMostRecentDialog,
					actionIsDangerous: false
					// title: String (plain text or HTML)
					// body: String (plain text or HTML)
					// acceptText: String
					// rejectText: String
					// acceptCallback: Function
				}, options);

				var $scope = options.$scope = options.$scope || $rootScope.$new();

				// Not using extend so we don't set unwanted options on the scope.
				$scope.title = $scope.title || $sce.trustAsHtml(options.title);
				$scope.body = $scope.body || $sce.trustAsHtml(options.body);
				$scope.acceptText = $scope.acceptText || options.acceptText;
				$scope.acceptCallback = $scope.acceptCallback || options.acceptCallback;
				$scope.rejectText = $scope.rejectText || options.rejectText;
				$scope.rejectCallback = $scope.rejectCallback || options.rejectCallback;
				$scope.actionIsDangerous = $scope.actionIsDangerous || options.actionIsDangerous;

				return this.show(options);
			},

			alert: function alert(options) {
				options = angular.extend({
					template: "@@include(inlineTemplate('alert.html'))",
					acceptCallback: closeMostRecentDialog
					// title: String (plain text or HTML)
					// body: String (plain text or HTML)
					// acceptText: String
				}, options);

				var $scope = options.$scope = options.$scope || $rootScope.$new();

				// Not using extend so we don't set unwanted options on the scope.
				$scope.title = $scope.title || $sce.trustAsHtml(options.title);
				$scope.body = $scope.body || $sce.trustAsHtml(options.body);
				$scope.acceptText = $scope.acceptText || options.acceptText;
				$scope.acceptCallback = $scope.acceptCallback || options.acceptCallback;

				return this.show(options);
			}
		};

		// Use a constructor so instances are easier to see in the dev-tools.
		function Dialog(options) {
			this.options = options;
			this.$scope = options.$scope || $rootScope.$new();
		}

		function closeMostRecentDialog() {
			if (mostRecentDialog) {
				mostRecentDialog.$scope.$destroy();
				// The dialog might be closed before its element has been compiled.
				if (mostRecentDialog.$element) {
					mostRecentDialog.$element.remove();
				}
				backdrop.hide();
				updateEscapeToCloseBinding(false);
				updateClickOutsideToCloseBinding(false);
				mostRecentDialog = null;
			}
		}

		function focusOnOpen(dialog) {
			// TODO(kenneth): Maybe refactor this into a generic dx-autofocus attribute?
			var target = dialog.$element.find("[dx-dialog-autofocus]")[0];
			if (target) {
				target.focus();
			}
		}

		function updateEscapeToCloseBinding(enable) {
			if (escapeToCloseIsEnabled !== enable) {
				bodyElement[enable ? "on" : "off"]("keyup", handleEscapeToClose);
				escapeToCloseIsEnabled = enable;
			}
		}

		function handleEscapeToClose(event) {
			if (event.keyCode === KeyCodesEnum.escape) {
				closeMostRecentDialog();
			}
		}

		function updateClickOutsideToCloseBinding(enable) {
			if (clickOutsideToCloseIsEnabled !== enable) {
				bodyElement[enable ? "on" : "off"]("click", handleClickOutsideToClose);
				clickOutsideToCloseIsEnabled = enable;
			}
		}

		function handleClickOutsideToClose(event) {
			var dialogEl = mostRecentDialog.$element[0];
			if (!dialogEl.contains(event.target)) {
				closeMostRecentDialog();
			}
		}

		function templateLoadingError(response) {
			throw Error(
				"Failed to load template: " +
				response.status +
				" " +
				response.statusText +
				", URL: " +
				response.config.url
			);
		}

	}

}());
