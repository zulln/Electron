(function(){
	"use strict";

	angular.module("dx.webui.blockEditor").directive("dxRtfBlockEditor", rtfBlockEditorDirective);

	function rtfBlockEditorDirective(
		Scribe,
		scribePluginHeadingCommand,
		scribePluginFormatterHtmlEnsureSemanticElements,
		scribePluginSanitizer,
		scribePluginKeyboardShortcuts,
		scribePluginWordCount,
		scribePluginMergeAdjacentLists,
		getKeyboardShortcutChecker,
		getKeyboardShortcutLabel,
		detectPlatform,
		$timeout,
		$window
	) {

		var directive = {
			restrict: "E",
			scope: {
				answerBlock: "=",
				// TODO(kenneth): Remove question after the statusbar has been moved to the Block Editor Manager.
				// The question is only needed because I quick-fixed the statusbar to be in the RTF editor,
				// both the toolbar and statusbar should be in the block editor manager and shared between editors
				// when we use multiple blocks later on.
				question: "=",
				onChange: "=",
				// TODO(kenneth): Use this to pass in the "limitCallback" for the word count scribe plugin once the statusbar is in the Block Editor Manager.
				//onHardWordLimit: "=",
				remainingWords: "="
			},
			controllerAs: "vm",
			template: "@@include(inlineTemplate('rtf-block-editor-directive.html'))",
			replace: true,
			link: link,
			controller: controller
		};

		var CLASSNAME_ROOT = "blockEditor";
		var CLASSNAME_CONTENT_EL = CLASSNAME_ROOT + "_content";
		var CLASSNAME_TOOLBAR_EL = CLASSNAME_ROOT + "_toolbar";
		var CLASSNAME_STATUSBAR_EL = CLASSNAME_ROOT + "_statusbar";
		var CLASSNAME_WORD_COUNT_EL = CLASSNAME_ROOT + "_wordCount";
		var CLASSNAME_FOCUS_MOD = CLASSNAME_ROOT + "-focus";
		var CLASSNAME_SOFT_LIMIT_MOD = CLASSNAME_WORD_COUNT_EL + "-softLimit";
		var CLASSNAME_HARD_LIMIT_MOD = CLASSNAME_WORD_COUNT_EL + "-hardLimit";
		var CLASSNAME_SOFT_LIMIT_EXCEEDED_MOD = CLASSNAME_SOFT_LIMIT_MOD + "Exceeded";
		var CLASSNAME_HARD_LIMIT_EXCEEDED_MOD = CLASSNAME_HARD_LIMIT_MOD + "Exceeded";

		// Whitelist options: https://github.com/guardian/html-janitor
		var MARKUP_WHITELIST = {
			tags: {
				p: {},
				strong: {},
				b: {},
				em: {},
				i: {},
				u: {},
				h1: {},
				h2: {},
				h3: {},
				h4: {},
				h5: {},
				h6: {},
				ul: {},
				ol: {},
				li: {}
			}
		};

		// Use Windows shortcuts for all platforms except for Mac.
		var SHORTCUTS_PLATFORM = detectPlatform() === "mac" ? "mac" : "win";

		// NOTE(kenneth): Keep this document updated! http://docs.digiexam.se:8080/display/PRODSPEC/Keyboard+Shortcuts
		var KEYBOARD_SHORTCUTS = {
			win: {
				bold: {modifiersAND: ["ctrl"], keysOR: ["b"]},
				italic: {modifiersAND: ["ctrl"], keysOR: ["i"]},
				underline: {modifiersAND: ["ctrl"], keysOR: ["u"]},
				h1: {modifiersAND: ["ctrl", "alt"], keysOR: ["1", "numPad1"]},
				h2: {modifiersAND: ["ctrl", "alt"], keysOR: ["2", "numPad2"]},
				h3: {modifiersAND: ["ctrl", "alt"], keysOR: ["3", "numPad3"]},
				h4: {modifiersAND: ["ctrl", "alt"], keysOR: ["4", "numPad4"]},
				h5: {modifiersAND: ["ctrl", "alt"], keysOR: ["5", "numPad5"]},
				h6: {modifiersAND: ["ctrl", "alt"], keysOR: ["6", "numPad6"]},
				insertOrderedList: {modifiersAND: ["ctrl", "shift"], keysOR: ["7"]},
				insertUnorderedList: {modifiersAND: ["ctrl", "shift"], keysOR: ["8"]},
				removeFormat: {modifiersAND: ["ctrl"], keysOR: ["\\"]},
				undo: {modifiersAND: ["ctrl"], keysOR: ["z"]},
				redo: {modifiersAND: ["ctrl"], keysOR: ["y"]}
			},

			mac: {
				bold: {modifiersAND: ["meta"], keysOR: ["b"]},
				italic: {modifiersAND: ["meta"], keysOR: ["i"]},
				underline: {modifiersAND: ["meta"], keysOR: ["u"]},
				h1: {modifiersAND: ["meta", "alt"], keysOR: ["1", "numPad1"]},
				h2: {modifiersAND: ["meta", "alt"], keysOR: ["2", "numPad2"]},
				h3: {modifiersAND: ["meta", "alt"], keysOR: ["3", "numPad3"]},
				h4: {modifiersAND: ["meta", "alt"], keysOR: ["4", "numPad4"]},
				h5: {modifiersAND: ["meta", "alt"], keysOR: ["5", "numPad5"]},
				h6: {modifiersAND: ["meta", "alt"], keysOR: ["6", "numPad6"]},
				insertOrderedList: {modifiersAND: ["meta", "shift"], keysOR: ["7"]},
				insertUnorderedList: {modifiersAND: ["meta", "shift"], keysOR: ["8"]},
				removeFormat: {modifiersAND: ["meta"], keysOR: ["\\"]},
				undo: {modifiersAND: ["meta"], keysOR: ["z"]},
				redo: {modifiersAND: ["meta"], keysOR: ["y"]}
			}
		};

		function parseKeyboardShortcutsConfigs(parser, configs) {
			var parsed = {};
			for (var key in configs) {
				if (configs.hasOwnProperty(key)) {
					parsed[key] = parser(configs[key]);
				}
			}
			return parsed;
		}

		function link($scope, $element) {
			var contentEl = $element.find("." + CLASSNAME_CONTENT_EL);
			var toolbarEl = $element.find("." + CLASSNAME_TOOLBAR_EL);
			var statusbarEl = $element.find("." + CLASSNAME_STATUSBAR_EL);
			var keyboardShortcutsPluginConfig = parseKeyboardShortcutsConfigs(getKeyboardShortcutChecker, KEYBOARD_SHORTCUTS[SHORTCUTS_PLATFORM]);
			var hardLimitTimeout;
			var wordCountPluginInstance = scribePluginWordCount({
				countCallback: wordCountCallback,
				limitCallback: hardWordlimitCallback
				// TODO(kenneth): Use this again once the statusbar is in the Block Editor Manager.
				//limitCallback: $scope.onHardWordLimit
			});

			// Use the Escape key instead of the Tab key for changing element focus from the editor
			contentEl[0].addEventListener("keydown", function handleEditorFocus(event) {
				var TAB_KEYCODE = 9;
				var ESC_KEYCODE = 27;

				// Because the Tab key is commonly used in text editors we do not want it
				// to change the element focus, and since we do not currently use it for
				// indenting text or lists we will just disable it.
				if (event.keyCode === TAB_KEYCODE) {
					event.preventDefault();
				}

				if (event.keyCode === ESC_KEYCODE && !(event.altKey || event.ctrlKey || event.metaKey)) {
					// Focus the editor toolbar when Shift+Escape keys are pressed,
					// allowing the user to focus elements before the editor.
					if (event.shiftKey) {
						toolbarEl[0].focus();
					// Focus the editor statusbar when only the Escape key is pressed,
					// allowing the user to focus elements after the editor.
					} else {
						statusbarEl[0].focus();
					}
					// Remove the selection so that the arrow keys can be used for scrolling and
					// any text input does not refocus the editor now that the focus has been changed.
					$window.getSelection().removeAllRanges();
				}
			});

			// NOTE(kenneth): Workaround so that the undo command won't be executed twice.
			// Scribe adds the Ctrl/Cmd+Z keyboard shortcut by default, so adding it ourselves too
			// will cause the shortcut to exist twice, and that executes the command twice.
			// We still keep undo in the configuration so we can generate a shortcut label from it.
			delete keyboardShortcutsPluginConfig.undo;

			$scope.$watch("remainingWords", function(newVal) {
				if (typeof newVal === "number" && newVal > -1) {
					wordCountPluginInstance.hardWordLimit = $scope.answerBlock.wordCount + newVal;
				}
			});

			function wordCountCallback(count) {
				$scope.answerBlock.wordCount = count;
				$scope.onChange();
			}

			function hardWordlimitCallback() {
				$scope.$apply("hardLimitExceeded = true");
				$timeout.cancel(hardLimitTimeout);
				hardLimitTimeout = $timeout(function() {
					$scope.$apply("hardLimitExceeded = false");
				}, 1000);
			}

			var scribe = new Scribe(contentEl[0]);
			scribe.use(wordCountPluginInstance);
			scribe.use(scribePluginSanitizer(MARKUP_WHITELIST));
			scribe.use(scribePluginFormatterHtmlEnsureSemanticElements());
			scribe.use(scribePluginKeyboardShortcuts(keyboardShortcutsPluginConfig));
			scribe.use(scribePluginHeadingCommand(1));
			scribe.use(scribePluginHeadingCommand(2));
			scribe.use(scribePluginHeadingCommand(3));
			scribe.use(scribePluginHeadingCommand(4));
			scribe.use(scribePluginHeadingCommand(5));
			scribe.use(scribePluginHeadingCommand(6));
			scribe.use(scribePluginMergeAdjacentLists());
			// Because of a Scribe bug the content should not be set to an empty string.
			// https://github.com/guardian/scribe/issues/368
			scribe.setContent($scope.answerBlock.body || "<p><br></p>");
			scribe.on("content-changed", function() {
				var block = $scope.answerBlock;
				var body = scribe.getHTML();
				if (body !== block.body) {
					block.body = body;
					// el.textContent will join the text of all elements, so block elements
					// that do not end with a work-breaking character will not cause a work break.
					// This "<h1>One</h1><p>Two</p>" becomes "OneTwo", so we have to make sure
					// there is a word-breaking character at the end of every block element.
					$scope.onChange();
				}
			});

			$scope.scribe = scribe;
			$scope.$element = $element;
		}

		/*@ngInject*/
		function controller(
			$scope,
			CapSettingEnum
		) {
			var vm = this;

			vm.keyboardShortcutLabels = parseKeyboardShortcutsConfigs(getKeyboardShortcutLabel, KEYBOARD_SHORTCUTS[SHORTCUTS_PLATFORM]);

			// The hardLimitExceeded class is handled by the `hardWordlimitCallback()` function.
			vm.wordCountClassNames = function() {
				var classNames = [];
				if ($scope.question.capSetting === CapSettingEnum.SOFT) {
					classNames.push(CLASSNAME_SOFT_LIMIT_MOD);
					if ($scope.answerBlock.wordCount > $scope.question.capValue) {
						classNames.push(CLASSNAME_SOFT_LIMIT_EXCEEDED_MOD);
					}
				} else if ($scope.question.capSetting === CapSettingEnum.HARD) {
					classNames.push(CLASSNAME_HARD_LIMIT_MOD);
					if ($scope.hardLimitExceeded) {
						classNames.push(CLASSNAME_HARD_LIMIT_EXCEEDED_MOD);
					}
				}
				return classNames;
			};

			vm.addContentFocus = function() {
				$scope.$element.addClass(CLASSNAME_FOCUS_MOD);
			};

			vm.removeContentFocus = function() {
				$scope.$element.removeClass(CLASSNAME_FOCUS_MOD);
			};

			vm.getWordCountDisplay = function getWordCountDisplay(wordCount, question) {
				var string = "" + wordCount;

				if (question.capSetting === CapSettingEnum.NONE) {
					string += wordCount === 1 ? " word" : " words";
				} else {
					string += " / " + question.capValue;
					string += question.capValue === 1 ? " word, " : " words, ";
					if (question.capSetting === CapSettingEnum.SOFT) {
						string += "soft";
					} else if (question.capSetting === CapSettingEnum.HARD) {
						string += "hard";
					}
					string += " limit";
				}

				return string;
			};
		}

		return directive;

	}

}());
