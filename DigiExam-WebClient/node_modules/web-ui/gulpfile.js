"use strict";

var argv = require('minimist')(process.argv.slice(2));
argv.watchTask = argv._.indexOf("watch") > -1;

var gulp = require("gulp-help")(require("gulp"), {hideDepsMessage: true, afterPrintCallback: function() { console.log("  Boolean arguments can be set to false using --no-name.\n"); }});
var plugins = require("gulp-load-plugins")();
var runSequence = require("run-sequence");
var combiner = require("stream-combiner2");
var del = require("del");
var karma = require("karma").server;
var taskErrorHandler = require("./utils/gulp-task-error-handler")(!argv.watchTask);
var testTaskErrorHandler = require("./utils/gulp-test-task-error-handler");

// Config

var config = {
	autoprefixer: ["last 2 versions", "ie >= 9", "Firefox ESR"],
	cssBase64: {
		baseDir: "./",
		extensions: ["woff"],
		debug: true,
	},
	karma: {
		file: __dirname + "/config/karma.js",
	},
	eslint: "./config/eslint.json",
	htmlhint: require("./config/htmlhint.js"),
	fileInclude: {
		inlineTemplates: require("./config/file-include-inline-templates.js"),
	},
};

var src = {
	css: {
		dir: "src/css/",
		files: "src/css/**/*.scss",
	},
	js: {
		files: "src/js/**/!(*.specs).js",
	},
	html: {
		templates: "src/js/**/*.html",
	},
};

var dest = "dist/";

// Tasks

gulp.task("default", "Build and test.", function(callback) {
	runSequence(
		"clean",
		["css", "js"],
		"test",
		callback
	);
});

gulp.task("watch", "Watch the source files for changes and build when they do change.", ["default"], function() {
	gulp.watch(src.css.files, ["css"]);
	gulp.watch([src.js.files, src.html.templates], ["js"]);
});

gulp.task("clean", false, function(callback) {
	del(dest, callback);
});

gulp.task("css", false, function() {
	return combiner.obj(
		// TODO(kenneth): gulp-ruby-sass will not throw an error on SASS syntax errors: https://github.com/sindresorhus/gulp-ruby-sass/issues/209
		plugins.rubySass(src.css.dir, {stopOnError: true, sourcemap: true}),
			plugins.bytediff.start(),
				plugins.base64(config.cssBase64),
				plugins.autoprefixer.apply(this, config.autoprefixer),
				plugins.minifyCss(),
				plugins.rename({suffix: ".min"}),
			plugins.bytediff.stop(),
			plugins.sourcemaps.write("./", {sourceRoot: src.css.dir}),
		gulp.dest(dest)
	).on("error", taskErrorHandler);
});

gulp.task("js", false, ["html"], function () {
	return combiner.obj(
		gulp.src(src.js.files),
			plugins.ngAnnotate(),
			plugins.eslint(config.eslint),
			plugins.eslint.format(),
			plugins.if(!argv.watchTask, plugins.eslint.failAfterError()),
			plugins.fileInclude(config.fileInclude.inlineTemplates),
		gulp.dest(dest)
	).on("error", taskErrorHandler);
});

gulp.task("html", false, function () {
	return combiner.obj(
		gulp.src(src.html.templates),
			plugins.htmlhint(config.htmlhint.partials),
			plugins.htmlhint[argv.watchTask ? "reporter" : "failReporter"]()
	).on("error", taskErrorHandler);
});

gulp.task("test", "Test using PhantomJS.", testTask(false));
gulp.task("test-watch", "Watch the source and test files and test using PhantomJS when they change.", testTask(true));

function testTask(testWatch) {
	return function test(callback) {
		karma.start({
			configFile: config.karma.file,
			autoWatch: testWatch,
			singleRun: !testWatch,
		}, testTaskErrorHandler(callback, !argv.watchTask))
	};
}
