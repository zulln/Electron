(function iife() {
	"use strict";

	// Most of this is based on the Angular Material Design $materialSticky service.

	angular.module("dx.webui.sticky").factory("stickyManager", stickyManagerService);

	function stickyManagerService(
		$$rAF,
		now,
		getVendorPrefixedCssProperty
	) {
		var transformCssProperty = getVendorPrefixedCssProperty("transform");

		return function registerStickyElement($scope, $element, $clone, docked) {
			var scrollCtrl = $element.controller("dxScroll");
			if (!scrollCtrl) {
				return;
			}

			var groupCtrl = $element.controller("dxStickyGroup");
			if (!groupCtrl) {
				groupCtrl = scrollCtrl;
			}

			var managerDataKey = "dxStickyManager";
			var manager = scrollCtrl.$element.data(managerDataKey);
			if (!manager) {
				manager = setupManager(scrollCtrl);
				scrollCtrl.$element.data(managerDataKey, manager);
			}

			var deregister = manager.add($element, $clone, groupCtrl, docked);
			$scope.$on("$destroy", deregister);
		};

		function setupManager(scrollCtrl) {
			var scrollEl = scrollCtrl.$element;

			// Refresh elements is very expensive, so we use the debounced
			// version when possible.
			var debouncedRefreshElements = $$rAF.throttle(refreshElements);

			// setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,
			// more reliable than `scroll` on android.
			setupAugmentedScrollEvents(scrollEl);
			scrollEl.on("$scrollstart", debouncedRefreshElements);
			scrollEl.on("$scroll", onScroll);

			var manager = {
				add: add,
				refreshElements: refreshElements,
				groups: [],
				top: {
					prev: null,
					current: null,
					next: null,
					items: [],
				},
				bottom: {
					prev: null,
					current: null,
					next: null,
					items: [],
				},
			};

			return manager;

			function add($element, $clone, groupCtrl, docked) {
				var position = $element.attr("dx-sticky") || "top";
				var $groupElement = groupCtrl.$element;

				var groups = manager.groups;
				var group = groups.filter(function isGroupElementCtrlElement(groupToFilter) {
					return groupToFilter.element === $groupElement;
				})[0];

				if (!group) {
					group = {
						element: $groupElement,
						docked: {},
						// Keeps track of how many items are in this group so we know when
						// to stop refreshing the group and remove it
						items: 0,
					};
					groups.push(group);
				}

				var items = manager[position].items;
				var item = {
					element: $element,
					clone: $clone,
					group: group,
					position: position,
				};
				items.push(item);

				if (docked) {
					group.docked[position] = item;
				}

				scrollEl.parent().prepend($clone);

				debouncedRefreshElements();

				return function remove() {
					items.forEach(function removeItem(itemToRemove, index) {
						if (itemToRemove.element[0] === $element[0]) {
							items.splice(index, 1);
							itemToRemove.clone.remove();
							if (group.docked[position] === itemToRemove) {
								delete group.docked[position];
							}
							if (--itemToRemove.group.items <= 0) {
								groups.splice(groups.indexOf(itemToRemove.group), 1);
							}
						}
					});
					debouncedRefreshElements();
				};
			}

			function refreshElements() {
				manager.groups.forEach(refreshPosition);
				refreshElementsPosition("top");
				refreshElementsPosition("bottom");
				// Call `onScroll()` once as a workaround to make `manager.add()` work with
				// sticky groups. `refreshElements()` only checks which elements should
				// be stickied but not if they are outside their group and if so should
				// be pushed to stay within the group.
				onScroll();
			}

			function refreshElementsPosition(position) {
				var items = manager[position].items;

				// Sort our collection of elements by their current position in the DOM.
				// We need to do this because our elements' order of being added may not
				// be the same as their order of display.
				items.forEach(refreshPosition);
				items = manager[position].items = items.sort(function sortItem(a, b) {
					if (position === "top") {
						return a.top < b.top ? -1 : 1;
					}
					return a.bottom > b.bottom ? -1 : 1;
				});

				// Find which item in the list should be active,
				// based upon the current scroll position
				var i;
				var item;
				var fold = scrollEl.prop("scrollTop");
				if (position === "top") {
					for (i = items.length - 1; i >= 0; i--) {
						if (fold > items[i].top) {
							item = items[i];
							break;
						}
					}
				} else {
					fold += scrollEl.height();
					for (i = items.length - 1; i >= 0; i--) {
						if (fold < items[i].bottom) {
							item = items[i];
							break;
						}
					}
				}

				setCurrentItem(item, position);
				//setCurrentItem(currentItem, position);
			}

			// Find the `top` or `bottom` of an item relative to the scroll element,
			// and also the width and height.
			function refreshPosition(item) {
				// Find the top of an item by adding to the offsetHeight until we reach the
				// content element.
				var current = item.element[0];
				item.top = 0;
				item.left = 0;
				while (current && current !== scrollEl[0]) {
					item.top += current.offsetTop;
					item.left += current.offsetLeft;
					current = current.offsetParent;
				}
				item.width = item.element.prop("offsetWidth");
				item.height = item.element.prop("offsetHeight");
				item.bottom = item.top + item.height;
				if (item.clone) {
					item.clone.css({
						left: item.left,
						width: item.width,
					});
				}
			}

			function onScroll() {
				var viewportTop = scrollEl.prop("scrollTop");
				onScrollTopItems(viewportTop);
				onScrollBottomItems(viewportTop + scrollEl[0].offsetHeight);
			}

			function onScrollTopItems(viewportTop) {
				var position = "top";
				var managerTop = manager.top;

				// At the top?
				if (viewportTop === 0) {
					setCurrentItem(null, position);
				// Sticky the next item if we've scrolled past its position.
				} else if (managerTop.next && managerTop.next.top - viewportTop <= 0) {
					setCurrentItem(managerTop.next, position);
				// Sticky the previous item if we've scrolled up past
				// the original position of the currently stickied item.
				} else if (managerTop.current && viewportTop < managerTop.current.top) {
					setCurrentItem(managerTop.prev, position);
				}

				if (managerTop.current) {
					var dockedBottomHeight = managerTop.current.group.docked.bottom ? managerTop.current.group.docked.bottom.height : 0;
					var groupBottomOverflow = managerTop.current.group.bottom - (viewportTop + managerTop.current.height + dockedBottomHeight);
					var nextOverflow = managerTop.next ? managerTop.next.top - managerTop.next.height - viewportTop : 0;

					// Push the current item up when it has reached the end of its group.
					if (groupBottomOverflow < 0) {
						translate(managerTop.current, groupBottomOverflow);
					// Push the current item up when we're almost at the next item.
					} else if (nextOverflow < 0) {
						translate(managerTop.current, nextOverflow);
					} else {
						translate(managerTop.current, null);
					}
				}
			}

			function onScrollBottomItems(viewportBottom) {
				var position = "bottom";
				var managerBottom = manager.bottom;

				// At the bottom?
				if (viewportBottom === scrollEl[0].scrollHeight) {
					setCurrentItem(null, position);
				// Sticky the next item if we've scrolled past its position.
				} else if (managerBottom.next && managerBottom.next.bottom - viewportBottom > 0) {
					setCurrentItem(managerBottom.next, position);
				// Sticky the previous item if we've scrolled down past
				// the original position of the currently stickied item.
				} else if (managerBottom.current && viewportBottom > managerBottom.current.bottom) {
					setCurrentItem(managerBottom.prev, position);
				}

				if (managerBottom.current) {
					var dockedTopHeight = managerBottom.current.group.docked.top ? managerBottom.current.group.docked.top.height : 0;
					var groupTopOverflow = managerBottom.current.group.top + managerBottom.current.height + dockedTopHeight - viewportBottom;
					var nextOverflow = managerBottom.next ? managerBottom.next.bottom + managerBottom.current.height - viewportBottom : 0;

					// Push the current item down when it has reached the top of its group.
					if (groupTopOverflow > 0) {
						translate(managerBottom.current, groupTopOverflow);
					// Push the current item down when we're almost at the next item.
					} else if (nextOverflow > 0) {
						translate(managerBottom.current, nextOverflow);
					} else {
						translate(managerBottom.current, null);
					}
				}
			}

			function setCurrentItem(item, position) {
				var managerPosition = manager[position];

				if (managerPosition.current === item) {
					return;
				}
				// Deactivate currently active item
				if (managerPosition.current) {
					translate(managerPosition.current, null);
					setStickyState(managerPosition.current, null);
				}

				// Activate new item if given
				if (item) {
					setStickyState(item, "active");
				}

				managerPosition.current = item;
				var index = managerPosition.items.indexOf(item);
				// If index === -1, index + 1 = 0. It works out.
				managerPosition.next = managerPosition.items[index + 1];
				managerPosition.prev = managerPosition.items[index - 1];
				setStickyState(managerPosition.next, "next");
				setStickyState(managerPosition.prev, "prev");
			}

			function setStickyState(item, state) {
				if (!item || item.state === state) {
					return;
				}
				if (item.state) {
					item.clone.attr("sticky-prev-state", item.state);
					item.element.attr("sticky-prev-state", item.state);
				}
				item.clone.attr("sticky-state", state);
				item.element.attr("sticky-state", state);
				item.state = state;
			}

			function translate(item, amount) {
				if (!item || item.translateY === amount) {
					return;
				}
				var value = amount === null || typeof amount === "undefined" ? "" : "translate3d(0," + amount + "px,0)";
				item.translateY = amount;
				item.clone.css(transformCssProperty, value);
			}

			// Android 4.4 don't accurately give scroll events.
			// To fix this problem, we setup a fake scroll event. We say:
			// > If a scroll or touchmove event has happened in the last DELAY milliseconds,
			//   then send a `$scroll` event every animationFrame.
			// Additionally, we add $scrollstart and $scrollend events.
			function setupAugmentedScrollEvents(element) {
				var SCROLL_END_DELAY = 200;
				var isScrolling;
				var lastScrollTime;
				element.on("scroll touchmove", function augmentOnScroll() {
					if (!isScrolling) {
						isScrolling = true;
						$$rAF(loopScrollEvent);
						element.triggerHandler("$scrollstart");
					}
					element.triggerHandler("$scroll");
					lastScrollTime = +now();
				});

				function loopScrollEvent() {
					if (+now() - lastScrollTime > SCROLL_END_DELAY) {
						isScrolling = false;
						element.triggerHandler("$scrollend");
					} else {
						element.triggerHandler("$scroll");
						$$rAF(loopScrollEvent);
					}
				}
			}
		}
	}
	stickyManagerService.$inject = ["$$rAF", "now", "getVendorPrefixedCssProperty"];
}());
